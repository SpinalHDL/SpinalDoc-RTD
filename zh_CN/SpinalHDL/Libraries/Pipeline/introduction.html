<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>简介 &mdash; SpinalHDL  文档</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/gh-fork-ribbon.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/spinaldoc.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/logo3_32x32.png"/>
    <link rel="canonical" href="https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Libraries/Pipeline/introduction.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/skins/default.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/wavedrom.min.js"></script>
        <script src="../../../_static/dialog.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="杂项" href="../Misc/index.html" />
    <link rel="prev" title="Pipeline" href="index.html" />
     
    <!-- source/_templates/layout.html -->
    
    
    

</head>

<body class="wy-body-for-nav">
     
    
    
    
    <div class="div-svg-github-corner github-corner-abs">
    <a href="https://github.com/SpinalHDL/SpinalDoc-RTD/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst" class="github-corner github-fork-ribbon" aria-label="Edit on GitHub" data-ribbon="Edit on GitHub" title="Edit on GitHub">
      <object id="svg-github-corner" data="../../../_static/github-corner-right.svg" class="svg-github-corner github-corner-abs" width="80" height="80"></object>
    </a>
    </div>
    
    
    

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SpinalHDL
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Foreword/index.html">前言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Foreword/index.html#why-moving-away-from-traditional-hdl">为什么要放弃传统的 HDL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#vhdl-verilog-aren-t-hardware-description-languages">VHDL/Verilog 不是硬件描述语言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#event-driven-paradigm-doesn-t-make-any-sense-for-rtl">事件驱动范式对于 RTL 没有任何意义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#recent-revisions-of-vhdl-and-verilog-aren-t-usable">VHDL 和 Verilog 的最新版本不可用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#vhdl-records-verilog-struct-are-broken-systemverilog-is-good-on-this-if-you-can-use-it">VHDL 结构记录（record），Verilog 结构（struct）已经破碎（SystemVerilog 在这方面很好，如果您可以使用它）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#vhdl-and-verilog-are-so-verbose">VHDL 和 Verilog 太冗长了</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#meta-hardware-description-capabilities">元硬件描述能力</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction/index.html">简介</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/SpinalHDL.html">关于 SpinalHDL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#what-is-spinalhdl">什么是SpinalHDL？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#what-spinalhdl-is-not">SpinalHDL 不是什么</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#the-spinal-development-flow">Spinal开发流程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#advantages-of-using-spinalhdl-over-vhdl-verilog">SpinalHDL 相对于 VHDL / Verilog 的优势</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/A%20simple%20example.html">一个简单的例子</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/A%20simple%20example.html#component">Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/A%20simple%20example.html#ports">端口</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/A%20simple%20example.html#internal-logic">内部逻辑</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html">使用 SpinalHDL 的项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html#repositories">仓库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html#companies">公司</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html#universities">大学</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Getting%20in%20touch.html">联系方式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/License.html">许可证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Contributing.html">贡献</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/faq.html">常见问题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#what-is-the-overhead-of-spinalhdl-generated-rtl-compared-to-human-written-vhdl-verilog">与人工编写的 VHDL/Verilog 相比，SpinalHDL 生成的 RTL 的开销是多少？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#what-if-spinalhdl-becomes-unsupported-in-the-future">如果 SpinalHDL 将来没有支持了怎么办？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#does-spinalhdl-keep-comments-in-generated-vhdl-verilog">SpinalHDL 是否在生成的 VHDL/Verilog 中保留注释？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#could-spinalhdl-scale-up-to-big-projects">SpinalHDL 可以扩展到大型项目吗？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#how-spinalhdl-came-to-be">SpinalHDL 是如何诞生的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#why-develop-a-new-language-when-there-is-vhdl-verilog-systemverilog">既然有了VHDL/Verilog/SystemVerilog，为什么还要开发新的语言呢？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#how-to-use-an-unreleased-version-of-spinalhdl-but-committed-on-git">如何使用 SpinalHDL 的未发布版本（但在 git 上提交）？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Other%20learning%20materials.html">其他学习资料</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Getting%20Started/index.html">入门</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html">安装和设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#required-recommended-tools">必需/推荐的工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#linux-installation">Linux安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#mac-os-x-installation">Mac OS X 安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#windows-installation">Windows安装</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#msys2-verilator-for-simulation">用于仿真的 MSYS2 verilator工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#msys2-for-formal-verification">用 MSYS2 实施形式化验证</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#oci-container">OCI容器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#installing-sbt-in-an-internet-free-linux-environment">在无网络的 Linux 环境中安装 SBT</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#create-a-first-spinalhdl-project">创建第一个 SpinalHDL 项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#the-directory-structure-of-a-project">项目的目录结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#using-spinal-on-spinalhdl-code">在 SpinalHDL 代码中使用 Spinal</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/SBT.html">在 CLI （命令行）中结合 SBT 使用 Spinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/VSCodium.html">在 VSCodium 中使用 Spinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/IntelliJ.html">从 IntelliJ IDEA 使用 Spinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/index.html">Scala 使用指南</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html">基础内容</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#types">类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#variables">变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#functions">函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#object">对象（Object）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#entry-point-main">入口点（main）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#class">类</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#templates-type-parameterization">模板/类型参数化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/coding_conventions.html">编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/coding_conventions.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/coding_conventions.html#class-vs-case-class">类与样例类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html">交互</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#how-spinalhdl-works-behind-the-api">SpinalHDL 在 API 隐藏后的工作原理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#everything-is-a-reference">一切都是引用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#hardware-types">硬件类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#names-of-signals-in-the-generated-rtl">生成的 RTL 中的信号名称</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#scala-is-for-elaboration-spinalhdl-for-hardware-description">Scala 用于实例细化，SpinalHDL 用于硬件描述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#scala-elaboration-capabilities-if-for-functional-programming">Scala 实例细化能力（if、for、函数式编程）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/index.html#id1">Scala 使用指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/index.html#introduction">简介</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/index.html">VHDL 用户入门</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html">与VHDL对比</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#process">过程（Process）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#implicit-vs-explicit-definitions">隐式与显式定义对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#clock-domains">时钟域</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#component-s-internal-organization">组件的内部组织方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#safety">安全性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#functions-and-procedures">功能与流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#buses-and-interfaces">总线和接口</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#signal-declaration">信号声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#component-instantiation">组件实例化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#casting">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#resizing">调整位宽</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#parameterization">参数化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#meta-hardware-description">元硬件描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html">VHDL 等效语法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#entity-and-architecture">实体和架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#data-types">数据类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#signal">信号</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#assignments">赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#literals">字面量（Literals）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#registers">寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#process-blocks">过程块</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/index.html">快速参考</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/core.html">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/lib.html">Lib</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/symbolic.html">Symbolic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Data%20types/index.html">数据类型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/bool.html">Bool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bool.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bool.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bool.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#logic">逻辑运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#edge-detection">边缘检测</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#misc">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#maskedboolean">掩码布尔值</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/bits.html">位</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bits.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bits.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#logic">逻辑运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#bit-extraction">位提取</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#misc">杂项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bits.html#maskedliteral">掩码字面量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Int.html">UInt/SInt</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Int.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Int.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#logic">逻辑运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#arithmetic">算术运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#bit-extraction">位提取</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#misc">杂项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Int.html#fixpoint-operations">定点小数操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#lower-bit-operations">低位运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#high-bit-operations">高位操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#fixto-function">fixTo 函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/enum.html">SpinalEnum</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/enum.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/enum.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#encoding">编码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/enum.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#types">类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#type-cast">类型转换</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/bundle.html">Bundle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#conditional-signals">条件信号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#convert-bits-back-to-bundle">将位转换回线束</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#io-element-direction">IO元件方向</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#in-out">in/out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#master-slave">master/slave</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Vec.html">Vec</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Vec.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Vec.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#examples">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Vec.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#misc">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#lib-helper-functions">库辅助函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Fix.html">UFix/SFix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#unsigned-fixed-point">无符号定点小数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#signed-fixed-point">有符号定点小数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#format">格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#examples">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#assignments">赋值</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#valid-assignments">有效赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#from-a-scala-constant">来自 Scala 常量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#raw-value">原始值</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#id2">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#arithmetic">算术运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#misc">杂项</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Floating.html">浮点小数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Floating.html#description">描述</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#ieee-754-floating-format">IEEE-754 浮点小数格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#recoded-floating-format">重新编码的浮动小数格式</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Floating.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#ieee-754-number">IEEE-754 编码数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#recoded-floating-point-number">重新编码的浮点数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Floating.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#type-cast">类型转换</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/AFix.html">AFix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#mathematical-operations">数学运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#inequality-operations">不等式运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#bitshifting">位移操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#saturation-and-rounding">饱和与舍入</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#assignment">赋值</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Structuring/index.html">结构设计</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/components_hierarchy.html">组件和层次结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#input-output-definition">输入/输出定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#pruned-signals">裁剪信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#parametrized-hardware-generic-in-vhdl-parameter-in-verilog">参数化硬件（VHDL 中的“Generic”，Verilog 中的“Parameter”）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#synthesized-component-names">综合后组件名称</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/area.html">Area</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/function.html">函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/function.html#rgb-to-gray">RGB信号转灰度信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/function.html#valid-ready-payload-bus">Valid Ready Payload 总线</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/clock_domain.html">时钟域</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#instantiation">实例化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#configuration">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#internal-clock">内部时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#external-clock">外部时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#signal-priorities-in-hdl-generation">生成 HDL 时的信号优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#context">语境</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#clock-domain-crossing">跨时钟域设计</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#special-clocking-areas">特殊计时逻辑区</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#slow-area">慢时钟逻辑区</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#bootreset">启动复位</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#resetarea">复位时钟域</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#clockenablearea">时钟使能逻辑区</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/blackbox.html">实例化 VHDL 和 Verilog IP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#defining-an-blackbox">定义一个黑盒</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#generics">泛型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#instantiating-a-blackbox">实例化黑盒</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#clock-and-reset-mapping">时钟和复位信号的映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#io-prefix">io前缀</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#rename-all-io-of-a-blackbox">重命名黑盒中的所有io</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#add-rtl-source">添加 RTL 源</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#vhdl-no-numeric-type">VHDL - 无数值类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/naming.html">保留名称的方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#nameable-base-class">Nameable 基类</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#name-extraction-from-scala">从 Scala 中提取名称</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#area-in-a-component">组件中的区域</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#area-in-a-function">函数中的逻辑区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#composite-in-a-function">函数中的复合区（Composite）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#composite-chains">复合区级联链</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#composite-in-a-bundle-s-function">在一个线束（Bundle）的函数中的复合区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#unnamed-signal-handling">Unnamed signal handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#verilog-expression-splitting">Verilog 表达式分割</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#verilog-long-expression-splitting">Verilog 长表达式分割</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#when-statement-condition">When 语句条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#in-last-resort">最后一招</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/parametrization.html">参数化</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/parametrization.html#elaboration-time-parameters">实例细化时参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/parametrization.html#optional-hardware">可选硬件</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Semantic/index.html">语义</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Semantic/assignments.html">赋值</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/assignments.html#width-checking">位宽检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/assignments.html#combinatorial-loops">组合逻辑环(Combinatorial loops)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/assignments.html#combinit">CombInit</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Semantic/when_switch.html">When/Switch/Mux</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#when">When</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#whenbuilder">WhenBuilder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#switch">Switch</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Semantic/when_switch.html#example">示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Semantic/when_switch.html#additional-options">其他选项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#local-declaration">本地声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#mux">Mux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#bitwise-selection">按位选择</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Semantic/when_switch.html#id1">示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Semantic/rules.html">规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/rules.html#concurrency">并发</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/rules.html#last-valid-assignment-wins">最后有效赋值生效</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/rules.html#signal-and-register-interactions-with-scala-oop-reference-functions">信号和寄存器与 Scala 语言的协作（OOP 引用 + 函数）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Sequential%20logic/index.html">时序逻辑</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Sequential%20logic/registers.html">寄存器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#instantiation">实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#reset-value">复位值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#initialization-value-for-simulation-purposes">用于仿真目的的初始化值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#register-vectors">寄存器组</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#transforming-a-wire-into-a-register">将线缆/信号转换为寄存器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Sequential%20logic/memory.html">RAM/ROM存储器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#synchronous-enable-quirk">同步使能注意事项</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#read-under-write-policy">写入时读取策略</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#mixed-width-ram">混合位宽存储器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#automatic-blackboxing">自动黑盒化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Sequential%20logic/memory.html#blackboxing-policy">黑盒策略</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Sequential%20logic/memory.html#standard-memory-blackboxes">标准存储器黑盒</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Design%20errors/index.html">设计错误</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/assignment_overlap.html">赋值覆盖(Assignment overlap)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/assignment_overlap.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/assignment_overlap.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html">跨时钟域违例(Clock crossing violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#example">示例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#crossclockdomain-tag">crossClockDomain标签</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#setsynchronouswith">setSynchronousWith</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#buffercc">BufferCC</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html">组合逻辑环(Combinatorial loop)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html#false-positives">误报</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/hierarchy_violation.html">层次违例(Hierarchy violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/hierarchy_violation.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/hierarchy_violation.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/iobundle.html">IO线束</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/iobundle.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/iobundle.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/latch_detected.html">锁存器检测(Latch detected)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/latch_detected.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/latch_detected.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/latch_detected.html#due-to-mux">因多路复用器产生的错误</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/no_driver_on.html">无驱动检测(No driver on)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/no_driver_on.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/no_driver_on.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html">空指针异常(NullPointerException)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html#example">示例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html#issue-explanation">问题说明</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html">超出范围的常数(Out of Range Constant)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html#specifying-exceptions">特殊情况</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/register_defined_as_component_input.html">定义为组件输入的寄存器(Register defined as component input)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/register_defined_as_component_input.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/register_defined_as_component_input.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/scope_violation.html">作用域违例(Scope violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/scope_violation.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/scope_violation.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html">Spinal无法克隆类(Spinal can’t clone class)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html#example-1">例子1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html#example-2">例子2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/unassigned_register.html">未赋值的寄存器(Unassigned register)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unassigned_register.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unassigned_register.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unassigned_register.html#register-with-only-init">只有初始化(init)的寄存器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/unreachable_is_statement.html">无法访问的is语句(Unreachable is statement)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unreachable_is_statement.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unreachable_is_statement.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/width_mismatch.html">位宽不匹配(Width mismatch)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/width_mismatch.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/width_mismatch.html#assignment-example">赋值示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/width_mismatch.html#operator-example">运算操作示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Other%20language%20features/index.html">其他语言功能</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/utils.html">实用工具</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#general">介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/utils.html#cat">Cat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#cloning-hardware-datatypes">克隆硬件数据类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#passing-a-datatype-as-construction-parameter">将数据类型作为构造函数参数传递</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/utils.html#the-old-way">老办法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/utils.html#the-safe-way">安全的方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#frequency-and-time">频率和时间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#binary-prefix">二进制前缀</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/stub.html">存根（Stub）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/assertion.html">Assertions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/report.html">Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/scope_property.html">ScopeProperty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html">模拟信号和输入输出</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#analog">模拟信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#inout">输入/出</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#inoutwrapper">输入/出包装器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#manually-driving-analog-bundles">手动驱动模拟线束</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html">VHDL 和 Verilog 生成</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#generate-vhdl-and-verilog-from-a-spinalhdl-component">从 SpinalHDL 组件生成 VHDL 和 Verilog</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#parametrization-from-scala">Scala 的参数化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#parametrization-from-shell">来自 shell 的参数化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#generated-vhdl-and-verilog">生成的 VHDL 和 Verilog</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#organization">组织</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#combinational-logic">组合逻辑</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#sequential-logic">时序逻辑</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#vhdl-and-verilog-attributes">VHDL 和 Verilog 属性</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">模块库</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../utils.html">实用工具</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../utils.html#state-less-utilities">免状态工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../utils.html#state-full-utilities">全状态工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../utils.html#counter">计数器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utils.html#timeout">超时</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utils.html#resetctrl">复位控制</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../utils.html#special-utilities">特殊工具</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../stream.html">Stream</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#semantics">语义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#functions">函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#utils">实用工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamfifo">StreamFifo</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamfifocc">StreamFifoCC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamccbytoggle">StreamCCByToggle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamwidthadapter">StreamWidthAdapter（反压流位宽适应器）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamarbiter">StreamArbiter（反压流仲裁器）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamjoin">StreamJoin</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamfork">StreamFork</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streammux">StreamMux</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamdemux">StreamDemux</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamdispatchersequencial">StreamDispatcherSequencial</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamtransactionextender">StreamTransactionExtender</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#simulation-support">仿真支持</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../flow.html">Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#functions">函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#code-example">代码示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#simulation-support">仿真支持</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../fragment.html">Fragment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fragment.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fragment.html#functions">函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../fsm.html">状态机</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fsm.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fsm.html#statemachine">StateMachine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#entry-point">入口点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#transitions">转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#state-encoding">状态编码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../fsm.html#states">状态</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#statedelay">StateDelay（状态延迟）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#statefsm">StateFsm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#stateparallelfsm">StateParallelFsm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#notes-about-the-entry-state">关于入口状态的注释</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../vexriscv.html">VexRiscv（RV32IM CPU）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bus_slave_factory.html">总线从端生成器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bus_slave_factory.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bus_slave_factory.html#functionality">功能</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../fiber.html">纤程框架</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fiber.html#simple-dummy-example">简单的示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fiber.html#handle-t">Handle[T]</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../fiber.html#soon-handle">soon(handle)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../binarySystem.html">二进制系统</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#string-to-int-long-bigint">String转为Int/Long/BigInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#int-long-bigint-to-string">Int/Long/BigInt转为String</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#int-long-bigint-to-binary-list">Int/Long/BigInt转为二进制列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#binary-list-to-int-long-bigint">二进制列表转为Int/Long/BigInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#bigint-enricher">BigInt放大器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../regIf.html">RegIf</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#automatic-allocation">自动分配</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#access-types">28种访问类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#automatic-documentation-generation">自动生成文档</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#special-access-usage">特殊访问用途</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#byte-mask">字节掩码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#typical-example">典型例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#interrupt-factory">中断生成器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#ip-level-interrupt-factory">IP级中断生成器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#sys-level-interrupt-merge">SYS级中断合并</a></li>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#spinal-factory">Spinal的生成器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#defaultreadvalue">默认读取值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#developers-area">开发者区域</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Bus/index.html">总线</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Bus/amba3/ahblite3.html">AHB-Lite3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/ahblite3.html#configuration-and-instantiation">Configuration and instantiation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/ahblite3.html#variations">变体</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/amba3/apb3.html">Apb3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/apb3.html#configuration-and-instantiation">Configuration and instantiation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/apb3.html#functions-and-operators">函数和运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/amba4/axi4.html">Axi4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba4/axi4.html#configuration-and-instantiation">Configuration and instantiation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba4/axi4.html#variations">变体</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba4/axi4.html#functions-and-operators">函数和运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/avalon/avalonmm.html">AvalonMM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/avalon/avalonmm.html#configuration-and-instantiation">Configuration and instantiation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/tilelink/tilelink.html">Tilelink</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink.html#configuration-and-instantiation">Configuration and instantiation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html">tilelink.fabric.Node</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-toplevel">顶层示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-gpiofiber">GPIOFiber示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-ramfiber">RamFiber示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-cpufiber">CpuFiber示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-widthadapter">位宽适配器(WidthAdapter)示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Com/index.html">通信接口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Com/spiXdr.html">SPI XDR</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/spiXdr.html#configuration">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/spiXdr.html#software-driver">软件驱动</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Com/uart.html">串口</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/uart.html#bus-definition">总线定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/uart.html#uartctrl">UartCtrl</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Com/usb_device.html">USB设备</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#architecture">架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#registers">寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#descriptors">描述符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#usage">用法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Com/usb_ohci.html">USB OHCI</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_ohci.html#usage">用法</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../IO/index.html">IO口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../IO/readableOpenDrain.html">可读开漏IO(ReadableOpenDrain)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../IO/tristate.html">三态</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../IO/tristate.html#id1">三态</a></li>
<li class="toctree-l4"><a class="reference internal" href="../IO/tristate.html#tristatearray">三态阵列</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Graphics/index.html">图形</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Graphics/colors.html">颜色</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/colors.html#rgb">RGB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Graphics/vga.html">VGA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/vga.html#vga-bus">VGA总线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/vga.html#vga-timings">VGA时序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/vga.html#vga-controller">VGA控制器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../EDA/index.html">自动设计工具(EDA)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../EDA/altera/qsysify.html">QSysify</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/qsysify.html#example">示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/qsysify.html#tags">标签</a></li>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/qsysify.html#adding-new-interface-support">添加新的接口支持</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../EDA/altera/quartus_flow.html">QuartusFlow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/quartus_flow.html#for-a-single-rtl-file">对于单个rtl文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/quartus_flow.html#for-an-existing-project">对于一个现有项目</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Pipeline</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">简介</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-example">简单示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#payload">Payload</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node">Node</a></li>
<li class="toctree-l3"><a class="reference internal" href="#links">Links</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#directlink">DirectLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stagelink">StageLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#s2mlink">S2mLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ctrllink">CtrlLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-links">其他链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="#your-custom-link">您的自定义链接</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#builder">Builder</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composability">组合能力（Composability）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retiming-variable-length">Retiming / Variable length</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-cpu-example">简单的CPU示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Misc/index.html">杂项</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html">Plic映射器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html#plicmapper-apply"><code class="docutils literal notranslate"><span class="pre">PlicMapper.apply</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html#plicmapping-sifive"><code class="docutils literal notranslate"><span class="pre">PlicMapping.sifive</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html#plicmapping-light"><code class="docutils literal notranslate"><span class="pre">PlicMapping.light</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Misc/service_plugin.html">插件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#execution-order">执行顺序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#simple-example">简单示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#interlocking-ordering">联锁/排序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Simulation/index.html">仿真</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/install/index.html">用于仿真的 SBT 设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/install/index.html#backend-dependent-installation-instructions">后台依赖的安装说明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/GHDL.html">GHDL 的设置和安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/Icarus%20Verilog.html">Icarus Verilog 的设置和安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/VCS.html">VCS 仿真配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/Verilator.html">Verilator 的设置和安装</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/bootstraps.html">启动仿真器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#configuration">配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#running-multiple-tests-on-the-same-hardware">在同一硬件上运行多个测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#throw-success-or-failure-of-the-simulation-from-a-thread">从线程中抛出仿真成功或失败结果</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#capturing-wave-for-a-given-window-before-failure">在失败之前捕获给定时间窗内的波形</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/signal.html">仿真过程中访问信号</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/signal.html#read-and-write-signals">读写信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/signal.html#accessing-signals-inside-the-component-s-hierarchy">访问组件层次结构内部的信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/signal.html#load-and-store-of-memory-in-simulation">仿真中内存的加载和存储</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/clock.html">时钟域</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#stimulus-api">激励函数API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#wait-api">等待相关API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#callback-api">回调函数API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#default-clockdomain">默认时钟域</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#new-clockdomain">新时钟域</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/threadFull.html">全线程API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/threadFull.html#fork-and-join-simulation-threads">分裂和合并仿真线程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/threadFull.html#sleep-and-waituntil">休眠和等待</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/threadLess.html">无线程API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/sensitive.html">敏感API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/simulator_specifics.html">仿真器的具体细节</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-verilator-backend">SpinalHDL 如何使用 Verilator 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-ghdl-icarus-verilog-backend">SpinalHDL 如何使用 GHDL/Icarus Verilog 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-synopsys-vcs-backend">SpinalHDL 如何使用 Synopsys VCS 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-xilinx-xsim-backend">SpinalHDL 如何使用 Xilinx XSim 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#performance">性能</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/engine.html">仿真引擎</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/examples/index.html">示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/asynchronous.html">异步加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/dual_clock_fifo.html">双时钟域FIFO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/single_clock_fifo.html">单时钟域FIFO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/synchronous.html">同步加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/uart_decoder.html">串口解码器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/uart_encoder.html">串口编码器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Formal%20verification/index.html">形式化验证</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#general">介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#formal-backend">形式化验证后端</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#installing-requirements">安装要求</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#example">示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#external-assertions">外部断言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#internal-assertions">内部断言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#external-stimulus">外部激励</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#more-assertions-past">更多关于断言/past（以前某个时钟内的状态）的例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#assuming-memory-content">假设内存中的内容</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#utilities-and-primitives">实用工具和原语</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#assertions-clock-reset">断言/时钟/复位</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#specifying-the-initial-value-of-a-signal">指定信号的初始值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#specifying-a-initial-assumption">指定初始假设</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#memory-content-mem">内存内容（Mem）检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#specifying-assertion-in-the-reset-scope">在复位的时候进行断言检查，可以这样做</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#formal-primitives">形式化验证的原语</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#limitations">局限性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#naming-polices">命名策略</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#for-component">对于组件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#for-interfaces-implement-imasterslave">对于实现 IMasterSlave的接口</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Examples/index.html">示例</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/Simple%20ones/index.html">简单示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html">APB3定义</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#implementation">实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#usage">用法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/carry_adder.html">进位加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/color_summing.html">颜色求和</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/counter_with_clear.html">带清零的计数器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/pll_resetctrl.html">锁相环黑盒和复位控制器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/pll_resetctrl.html#the-pll-blackbox-definition">PLL BlackBox定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/pll_resetctrl.html#toplevel-definition">TopLevel定义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/rgb_to_gray.html">RGB信号转灰度信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/sinus_rom.html">正弦 ROM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/Intermediates%20ones/index.html">中级示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html">分形计算器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#elaboration-parameters-generics">细化参数（泛型）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#bundle-definition">Bundle定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#component-implementation">组件实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html">串口</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#data-structures">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#implementation">实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#simple-usage">简单应用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#example-with-test-bench">带TestBench的例子</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#bonus-having-fun-with-stream">额外奖励：享受 Stream 带来的乐趣</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html">VGA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html#data-structures">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html#vga-controller">VGA控制器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/Advanced%20ones/index.html">高级示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html">JTAG TAP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#jtag-bus">JTAG总线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#jtag-state-machine">JTAG状态机</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#id1">JTAG TAP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#jtag-instructions">Jtag指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#user-friendly-wrapper">用户友好型包装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#usage-demonstration">使用演示</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html">内存映射UART</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html#implementation">实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/pinesec.html">Pinesec</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/slots.html">插槽(Slots)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/slots.html#introduction">简介</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html">计时器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html#id2">计时器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html#bridging-function">桥接函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/index.html#getting-started">入门</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Legacy/index.html">历史遗留</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Legacy/riscv.html">RiscV</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#features">特性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#base-fpga-project">基础FPGA项目</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#how-to-generate-the-cpu-vhdl">如何生成CPU VHDL</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#how-to-debug">如何调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#todo">Todo</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Legacy/pinsec/index.html">pinsec</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/introduction.html">简介</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/introduction.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/introduction.html#board-support">板级支持</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/hardware.html">硬件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#riscv">RISCV</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#axi4">AXI4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#apb3">APB3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#generate-the-rtl">生成RTL</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html">SoC顶层(Pinsec)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#defining-all-io">定义所有IO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#clock-and-resets">时钟和复位</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#main-components">主要组件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#peripherals">外设</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#bus-interconnects">总线互连</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#misc">杂项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/software.html">软件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/software.html#riscv-tool-chain">RISCV工具链</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/software.html#openocd-gdb-eclipse-configuration">OpenOCD/GDB/Eclipse配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../miscelenea/index.html">杂项</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/frequent_errors.html">常见错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/frequent_errors.html#exception-in-thread-main-java-lang-nullpointerexception">“main”线程中异常 java.lang.NullPointerException</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/frequent_errors.html#hierarchy-violation">层次违例(Hierarchy violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/frequent_errors.html#signal-x-can-t-be-assigned-by-y">Signal X can’t be assigned by Y</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/frequent_errors.html#input-signal-x-can-t-be-assigned-by-y">Input signal X can’t be assigned by Y</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/frequent_errors.html#output-signal-x-can-t-be-assigned-by-y">Output signal X can’t be assigned by Y</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/core/core_components.html"><code class="docutils literal notranslate"><span class="pre">spinal.core</span></code> 组件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#clock-domains-definitions">时钟域定义</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#clock-domain-syntax">时钟域语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#clock-configuration">时钟配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#external-clock">外部时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#cross-clock-domain">跨时钟域设计</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#assignments">赋值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#when-switch">When / Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#component-hierarchy">组件/层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#area">Area</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#function">函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#rgb-to-gray">RGB信号转灰度信号</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#valid-ready-payload-bus">Valid Ready Payload 总线</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#vhdl-generation">VHDL生成</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#instantiate-vhdl-and-verilog-ip">实例化 VHDL 和 Verilog IP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#utils">实用工具</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/core/elements.html">Element</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/core/elements.html#range">范围</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Developers%20area/index.html">开发者专区</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html">总线从端（Factory）实现</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#implementation">实现</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#busslavefactory">BusSlaveFactory</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#busslavefactorydelayed">BusSlaveFactoryDelayed</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#avalonmmslavefactory">AvalonMMSlaveFactory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#conclusion">结论</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/howotuselocalspinalclone.html">项目中如何使用本地的SpinalHDL克隆作为依赖</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howotuselocalspinalclone.html#create-local-git-clone-of-spinalhdl">创建本地的SpinalHDL git 克隆</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howotuselocalspinalclone.html#configure-buildsystem">配置构建系统</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/howotuselocalspinalclone.html#configure-sbt-update-build-sbt">配置 sbt (更新 <code class="docutils literal notranslate"><span class="pre">build.sbt</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/howotuselocalspinalclone.html#configure-mill-update-build-sc">配置 mill (更新 <code class="docutils literal notranslate"><span class="pre">build.sc</span></code>)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howotuselocalspinalclone.html#done">完成</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/howtodocument.html">如何修改本文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howtodocument.html#title-convention">标题约定</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howtodocument.html#wavedrom-integration">Wavedrom 的集成</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howtodocument.html#new-section">新章节</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/howtodocument.html#example">示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/mill%20support.html">通过Mill构建（输出）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#compile-the-library">编译SpinalHDL库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#run-all-test-suites">运行所有测试套件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#run-a-specified-test-suite">运行指定的测试套件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#run-a-specified-app">运行指定程序（App）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#publish-locally">本地发布</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html">SpinalHDL 内部数据模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#general-structure">总体结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#exploring-the-datamodel">探索数据模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#compilation-phases">编译环节</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#modifying-a-netlist-as-a-user-without-plugins">在不使用插件的情况下，以用户身份修改网表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#user-space-netlist-analysis">用户空间网表分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#enumerating-every-clockdomain-in-use">遍历、枚举正在使用的每个时钟域</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/types.html">类型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bool">Bool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#declaration">声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#operators">运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#the-bitvector-family-bits-uint-sint">BitVector 系列 - (<code class="docutils literal notranslate"><span class="pre">Bits</span></code>, <code class="docutils literal notranslate"><span class="pre">UInt</span></code>, <code class="docutils literal notranslate"><span class="pre">SInt</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#declaration-syntax">声明语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#id1">运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#masked-comparison">掩码过滤结果比较</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bits">位</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#uint-sint">UInt、SInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bool-bits-uint-sint">Bool, Bits, UInt, SInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#vec">Vec</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bundle">Bundle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#simple-example-rgb-vga">简单示例（RGB/VGA）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#interface-example-apb">接口示例（APB）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#enum">Enum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#data-bool-bits-uint-sint-enum-bundle-vec">Data (Bool, Bits, UInt, SInt, Enum, Bundle, Vec)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#literals-as-signal-declaration">使用字面量声明信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#continuous-assignment-literals-as-signal-declaration">用连续赋值字面量作来声明信号</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpinalHDL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">模块库</a></li>
          <li class="breadcrumb-item"><a href="index.html">Pipeline</a></li>
      <li class="breadcrumb-item active">简介</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/SpinalHDL/SpinalDoc-RTD/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst" class="fa fa-github"> 在 GitHub 上编辑</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             


  <section id="introduction">
<h1>简介<a class="headerlink" href="#introduction" title="此标题的永久链接"></a></h1>
<p>spinal.lib.misc.pipeline提供了一套流水线API。相对于手动流水线它的主要优点是：</p>
<ul class="simple">
<li><p>您不必预先准备好整个流水系统中所需的所有信号元素。您可以根据设计需要，以更特别的方式创建和使用可分级的信号，而无需重构所有中间阶段来处理信号</p></li>
<li><p>流水线的信号可以利用SpinalHDL的强大参数化能力，并且如果设计构建中不需要特定的参数化特征，则可以进行优化/移除，而不需要以显著的方式修改流水系统设计或项目代码库。</p></li>
<li><p>Manual retiming is much easier, as you don’t have to handle the registers / arbitration manually</p></li>
<li><p>它会自行管理仲裁器</p></li>
</ul>
<p>API由4个主要部分组成：</p>
<ul class="simple">
<li><p>Node：表示管道中的层</p></li>
<li><p>Link：允许节点相互连接</p></li>
<li><p>Builder：生成整个管道所需的硬件</p></li>
<li><p>Payload：用于获取流水线的节点上的硬件信号</p></li>
</ul>
<p>重要的是，Payload不是硬件数据/信号实例，而是用于检索流水线在节点中数据/信号的关键，并且流水线构建器随后将在节点之间的每次给定Payload出现时自动互连/流水线。</p>
<p>以下是一个用于阐述的例子：</p>
<a class="reference internal image-reference" href="../../../_images/intro_pip.png"><img alt="../../../_images/intro_pip.png" src="../../../_images/intro_pip.png" style="width: 251.99999999999997px; height: 331.79999999999995px;" /></a>
<p>以下是关于此API的视频：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=74h_-FMWWIM">https://www.youtube.com/watch?v=74h_-FMWWIM</a></p></li>
</ul>
<section id="simple-example">
<h2>简单示例<a class="headerlink" href="#simple-example" title="此标题的永久链接"></a></h2>
<p>下面是一个简单的例子，它只使用了基本的API：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">misc</span><span class="p">.</span><span class="nn">pipeline</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define 3 Nodes for our pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes by using simples registers</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s define a few Payload things that can go through the pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">RESULT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind io.up to n0</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n0</span><span class="p">.</span><span class="n">ready</span>
<span class="w">  </span><span class="n">n0</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">valid</span>
<span class="w">  </span><span class="n">n0</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span>

<span class="w">  </span><span class="c1">// Let&#39;s do some processing on n1</span>
<span class="w">  </span><span class="n">n1</span><span class="p">(</span><span class="nc">RESULT</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x1200</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind n2 to io.down</span>
<span class="w">  </span><span class="n">n2</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">ready</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n2</span><span class="p">.</span><span class="n">valid</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n2</span><span class="p">(</span><span class="nc">RESULT</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">s01</span><span class="p">,</span><span class="w"> </span><span class="n">s12</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这将产生以下硬件：</p>
<a class="reference internal image-reference" href="../../../_images/simple_pip.png"><img alt="../../../_images/simple_pip.png" src="../../../_images/simple_pip.png" style="width: 232.39999999999998px; height: 336.0px;" /></a>
<p>下面是一个仿真波形：</p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{signal: [
  {name: 'clk', wave: '0...p........'},
  {name: 'reset', wave: '1..0.........'},
  {name: 'io_up_valid', wave: '0.....10.....'},
  {},
  {name: 'n0_valid', wave: '0.....10.....'},
  {name: 'n0_VALUE', wave: 'x.....2......', data: ['0042']},
  {},
  {name: 'n1_valid', wave: '0......10....'},
  {name: 'n1_VALUE', wave: 'x......2.....', data: ['0042']},
  {name: 'n1_RESULT', wave: 'x......2.....', data: ['1242']},
  {},
  {name: 'n2_valid', wave: '0.......10...'},
  {name: 'n2_RESULT', wave: 'x.......2....', data: ['1242']},
  {},
  {name: 'io_down_valid', wave: '0.......10...'},
]}
</script>
</div>
<p>下面是相同的示例，但使用了更多的API：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">misc</span><span class="p">.</span><span class="nn">pipeline</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w">  </span><span class="c1">// VALUE can also be used as a HardType</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// NodesBuilder will be used to register all the nodes created, connect them via stages and generate the hardware</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">NodesBuilder</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// Let&#39;s define a Node which connect from io.up</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateFrom</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">    </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define a Node which do some processing</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">RESULT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x1200</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//  Let&#39;s define a Node which connect to io.down</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateTo</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">)</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">.</span><span class="nc">RESULT</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes by using registers stages and generate the related hardware</span>
<span class="w">  </span><span class="n">builder</span><span class="p">.</span><span class="n">genStagedPipeline</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="payload">
<h1>Payload<a class="headerlink" href="#payload" title="此标题的永久链接"></a></h1>
<p>Payload objects are used to refer to data which can go through the pipeline. Technically speaking, Payload is a HardType which has a name and is used as a “key” to retrieve the signals in a certain pipeline stage.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PC_PLUS_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>

<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">n1</span><span class="p">(</span><span class="nc">PC_PLUS_4</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span>
</pre></div>
</div>
<p>请注意，我习惯于使用大写对Payload实例命名。这是为了让它非常明确，这不是一个硬件信号，更像是一个“键/类型”访问的东西。</p>
</section>
<section id="node">
<h1>Node<a class="headerlink" href="#node" title="此标题的永久链接"></a></h1>
<p>Node主要托管有效/就绪仲裁信号，以及所有通过它的硬件信号所需的Payload。</p>
<p>您可以通过以下方式访问其仲裁器：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 8%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>访问</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>node.valid</p></td>
<td><p>RW</p></td>
<td><p>指定节点上是否存在事务的信号。它是由上游逻辑驱动的。一旦置为1，则它必须且仅能在valid和ready同时置位或node.cancel为高的周期后解除置位。valid不依赖于ready。</p></td>
</tr>
<tr class="row-odd"><td><p>node.ready</p></td>
<td><p>RW</p></td>
<td><p>Is the signal which specifies if the node’s transaction can proceed downstream. It is driven by the downstream to create backpressure. The signal has no meaning when there is no transaction (node.valid being deasserted)</p></td>
</tr>
<tr class="row-even"><td><p>node.cancel</p></td>
<td><p>RW</p></td>
<td><p>指定节点的事务是否正在从流水线中取消的信号。它由下游驱动。当没有事务时（node.valid被置0），该信号没有意义</p></td>
</tr>
<tr class="row-odd"><td><p>node.isValid</p></td>
<td><p>RO</p></td>
<td><p>node.valid的只读访问器</p></td>
</tr>
<tr class="row-even"><td><p>node.isReady</p></td>
<td><p>RO</p></td>
<td><p>node.ready的只读访问器</p></td>
</tr>
<tr class="row-odd"><td><p>node.isCancel</p></td>
<td><p>RO</p></td>
<td><p>node.cancel的只读访问器</p></td>
</tr>
<tr class="row-even"><td><p>node.isFiring</p></td>
<td><p>RO</p></td>
<td><p>True when the node transaction is successfully moving further (valid &amp;&amp; ready &amp;&amp; !cancel). Useful to commit state changes.</p></td>
</tr>
<tr class="row-odd"><td><p>node.isMoving</p></td>
<td><p>RO</p></td>
<td><p>当节点事务将不再存在于节点上时（从下一周期开始）为True，要么是因为下游准备好接收事务，要么是因为事务已从流水线中取消。（valid &amp;&amp; (ready || cancel)）用于“复位”(reset)状态。</p></td>
</tr>
<tr class="row-even"><td><p>node.isCanceling</p></td>
<td><p>RO</p></td>
<td><p>当节点事务正在被取消时为True。这意味着在将来的周期中它不会出现在流水线中的任何地方。</p></td>
</tr>
</tbody>
</table>
<p>请注意，node.valid/node.ready信号遵循与 <a class="reference internal" href="../stream.html"><span class="doc">Stream</span></a> 中相同的规范。</p>
<p>The Node controls (valid/ready/cancel) and status (isValid, isReady, isCancel, isFiring, …) signals are created on demand.
So for instance you can create pipeline with no backpressure by never referring to the ready signal. That’s why it is important to use status signals when you want to read the status of something and only use control signals when you to drive something.</p>
<p>以下是节点上可能出现的仲裁情况列表。valid/ready/cancel定义了我们所处的状态，而isFiring/isMoving是这些状态的结果：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>valid</p></th>
<th class="head"><p>ready</p></th>
<th class="head"><p>cancel</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>isFiring</p></th>
<th class="head"><p>isMoving</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>无事务</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>正在进行</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>阻塞</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>X</p></td>
<td><p>1</p></td>
<td><p>取消</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>请注意，如果您想要建模诸如CPU级可能的阻塞和刷新的情况，可以查看 CtrlLink，因为它提供了执行此类操作的 API。</p>
<p>您可以通过以下方式访问由Payload引用的信号：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>node(Payload)</p></td>
<td><p>返回对应的硬件信号</p></td>
</tr>
<tr class="row-odd"><td><p>node(Payload, Any)</p></td>
<td><p>与上述相同，但包括一个用作“次要键”的第二个参数。这有助于构建多通道硬件。例如，当您有一个多发射CPU流水线时，您可以使用通道Int id作为次要键</p></td>
</tr>
<tr class="row-even"><td><p>node.insert(Data)</p></td>
<td><p>返回一个新的Payload实例，该实例连接到给定的Data硬件信号</p></td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">,</span><span class="w"> </span><span class="mh">0x666</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0xEE</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">SOMETHING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n0</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">myHardwareSignal</span><span class="p">)</span><span class="w"> </span><span class="c1">// This create a new Payload</span>
<span class="n">when</span><span class="p">(</span><span class="n">n1</span><span class="p">(</span><span class="nc">SOMETHING</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0xFFAA</span><span class="p">){</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>While you can manually drive/read the arbitration/data of the first/last stage of your pipeline, there is a few utilities to connect its boundaries.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>node.arbitrateFrom(Stream[T]])</p></td>
<td><p>由反压流驱动节点仲裁。</p></td>
</tr>
<tr class="row-odd"><td><p>node.arbitrateFrom(Flow[T]])</p></td>
<td><p>由数据流驱动节点仲裁。</p></td>
</tr>
<tr class="row-even"><td><p>node.arbitrateTo(Stream[T]])</p></td>
<td><p>由节点驱动反压流仲裁。</p></td>
</tr>
<tr class="row-odd"><td><p>node.arbitrateTo(Flow[T]])</p></td>
<td><p>由节点驱动数据流仲裁。</p></td>
</tr>
<tr class="row-even"><td><p>node.driveFrom(Stream[T]])((Node, T) =&gt; Unit)</p></td>
<td><p>由反压流驱动节点。提供的lambda函数可以用于连接数据</p></td>
</tr>
<tr class="row-odd"><td><p>node.driveFrom(Flow[T]])((Node, T) =&gt; Unit)</p></td>
<td><p>与上述类似，但适用于Flow</p></td>
</tr>
<tr class="row-even"><td><p>node.driveTo(Stream[T]])((T, Node) =&gt; Unit)</p></td>
<td><p>由节点驱动反压流。提供的lambda函数可以用于连接数据</p></td>
</tr>
<tr class="row-odd"><td><p>node.driveTo(Flow[T]])((T, Node) =&gt; Unit)</p></td>
<td><p>与上述类似，但适用于Flow</p></td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">IN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">OUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="n">n1</span><span class="p">(</span><span class="nc">OUT</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">(</span><span class="nc">IN</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x42</span>

<span class="c1">// Define the input / output stream that will be later connected to the pipeline</span>
<span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="c1">// Note master Stream(OUT) is good as well</span>

<span class="n">n0</span><span class="p">.</span><span class="n">driveFrom</span><span class="p">(</span><span class="n">up</span><span class="p">)((</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">self</span><span class="p">(</span><span class="nc">IN</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span>
<span class="n">n2</span><span class="p">.</span><span class="n">driveTo</span><span class="p">(</span><span class="n">down</span><span class="p">)((</span><span class="n">payload</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">self</span><span class="p">(</span><span class="nc">OUT</span><span class="p">))</span>
</pre></div>
</div>
<p>为了减少冗长，在Payload与其数据表示之间有一组隐式转换，可在Node下使用：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PLUS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// VALUE is implicitly converted into its n1(VALUE) representation</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您还可以通过导入它们来使用这些隐式转换：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="n">n1Stuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="nn">n1</span><span class="p">.</span><span class="n">_</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PLUS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Equivalent to n1.insert(n1(VALUE)) + 1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is also an API which allows you to create new Area which provide the whole API of a given node instance (including implicit conversion) without import :</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="kd">val</span><span class="w"> </span><span class="n">n1Stuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">n1</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PLUS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Equivalent to n1.insert(n1(VALUE)) + 1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当硬件具有可参数化的流水线位置时，这样的功能非常有用（请参阅重定时示例）。</p>
</section>
<section id="links">
<h1>Links<a class="headerlink" href="#links" title="此标题的永久链接"></a></h1>
<p>目前已经实现了一些不同的Links（但您也可以创建自己的自定义Links）。Links的思想是以各种方式将两个节点连接在一起，它们通常有一个 <cite>up</cite> 节点和一个 <cite>down</cite> 节点。</p>
<section id="directlink">
<h2>DirectLink<a class="headerlink" href="#directlink" title="此标题的永久链接"></a></h2>
<p>非常简单，它只使用导线连接两个节点。以下是一个示例：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DirectLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="stagelink">
<h2>StageLink<a class="headerlink" href="#stagelink" title="此标题的永久链接"></a></h2>
<p>这使用data/valid信号上的寄存器和ready信号上的一些仲裁连接了两个节点。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="s2mlink">
<h2>S2mLink<a class="headerlink" href="#s2mlink" title="此标题的永久链接"></a></h2>
<p>This connect two nodes using registers on the ready signal, which can be useful to improve backpressure combinatorial timings.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">S2mLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="ctrllink">
<h2>CtrlLink<a class="headerlink" href="#ctrllink" title="此标题的永久链接"></a></h2>
<p>这是一种特殊的 Link，用于连接两个节点，具有可选的流量控制/旁路逻辑。它的应用程序接口应该足够灵活，可以用它来实现 CPU 流水级。</p>
<p>以下是其流量控制 API（Bool 参数启用了相关功能）：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>haltWhen(Bool)</p></td>
<td><p>允许阻止当前传输事务（清除 up.ready down.valid）</p></td>
</tr>
<tr class="row-odd"><td><p>throwWhen(Bool)</p></td>
<td><p>允许从流水线中取消当前事务（清除 down.valid，使事务驱动逻辑忘记其当前状态）</p></td>
</tr>
<tr class="row-even"><td><p>forgetOneWhen(Bool)</p></td>
<td><p>允许请求上游节点忘记其当前事务（但不会清除 down.valid）</p></td>
</tr>
<tr class="row-odd"><td><p>ignoreReadyWhen(Bool)</p></td>
<td><p>允许忽略下游节点ready（设置 up.ready 为1）</p></td>
</tr>
<tr class="row-even"><td><p>duplicateWhen(Bool)</p></td>
<td><p>允许复制当前传输事务（清零 up.ready）</p></td>
</tr>
<tr class="row-odd"><td><p>terminateWhen(Bool)</p></td>
<td><p>允许下游节点隐藏当前传输事务（清零 down.valid）</p></td>
</tr>
</tbody>
</table>
<p>还要注意的是，如果要在条件作用域（例如在 when 语句中）进行通信流控制，可以调用以下函数 ：</p>
<ul class="simple">
<li><p>haltIt(), duplicateIt(), terminateIt(), forgetOneNow(), ignoreReadyNow(), throwIt()</p></li>
</ul>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>

<span class="n">c01</span><span class="p">.</span><span class="n">haltWhen</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"> </span><span class="c1">// Explicit halt request</span>

<span class="n">when</span><span class="p">(</span><span class="n">somethingElse</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">c01</span><span class="p">.</span><span class="n">haltIt</span><span class="p">()</span><span class="w"> </span><span class="c1">// Conditional scope sensitive halt request, same as c01.haltWhen(somethingElse)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您可以使用 node.up / node.down 查看哪些节点连接到了链接。</p>
<p>CtrlLink 还提供了访问Payload的 API：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>link(Payload)</p></td>
<td><p>与 Link.down(Payload) 相同</p></td>
</tr>
<tr class="row-odd"><td><p>link(Payload, Any)</p></td>
<td><p>与 Link.down(Payload, Any) 相同</p></td>
</tr>
<tr class="row-even"><td><p>link.insert(Data)</p></td>
<td><p>与 Link.down.insert(Data) 相同</p></td>
</tr>
<tr class="row-odd"><td><p>link.bypass(Payload)</p></td>
<td><p>Allows to conditionally override a Payload value between link.up -&gt; link.down. This can be used to fix data hazard in CPU pipelines for instance.</p></td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="n">c01</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">c01</span><span class="p">(</span><span class="nc">PC</span><span class="p">,</span><span class="w"> </span><span class="mh">0x666</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0xEE</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">DATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="c1">// Let&#39;s say Data is inserted in the pipeline before c01</span>
<span class="n">when</span><span class="p">(</span><span class="n">hazard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">c01</span><span class="p">.</span><span class="n">bypass</span><span class="p">(</span><span class="nc">DATA</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fixedValue</span>
<span class="p">}</span>

<span class="c1">// c01(DATA) and below will get the hazard patch</span>
</pre></div>
</div>
<p>请注意，如果创建的 CtrlLink 不带节点参数，它将在内部创建自己的节点。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">decode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="n">d2e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">decode</span><span class="p">.</span><span class="n">down</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="other-links">
<h2>其他链接<a class="headerlink" href="#other-links" title="此标题的永久链接"></a></h2>
<p>此外，还实现了 JoinLink / ForkLink。</p>
</section>
<section id="your-custom-link">
<h2>您的自定义链接<a class="headerlink" href="#your-custom-link" title="此标题的永久链接"></a></h2>
<p>您可以通过实现 Link 基类来实现自定义链接。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">Link</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">ups</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Node</span><span class="p">]</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">downs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Node</span><span class="p">]</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">propagateDown</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">propagateUp</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span>
<span class="p">}</span>
</pre></div>
</div>
<p>不过，由于 API 还很新，后面可能会有一些变化。</p>
</section>
</section>
<section id="builder">
<h1>Builder<a class="headerlink" href="#builder" title="此标题的永久链接"></a></h1>
<p>要生成流水线硬件，您需要提供流水线中使用的所有链接列表。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Let&#39;s define 3 Nodes for our pipeline</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="c1">// Let&#39;s connect those nodes by using simples registers</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="nc">Builder</span><span class="p">(</span><span class="n">s01</span><span class="p">,</span><span class="w"> </span><span class="n">s12</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also a set of “all in one” builders that you can instantiate to help yourself.</p>
<p>例如，有一个 NodesBuilder 类，可用于创建按顺序分级的流水线：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">NodesBuilder</span><span class="p">()</span>

<span class="c1">// Let&#39;s define a few nodes</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span>

<span class="c1">// Let&#39;s connect those nodes by using registers and generate the related hardware</span>
<span class="n">builder</span><span class="p">.</span><span class="n">genStagedPipeline</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="composability">
<h1>组合能力（Composability）<a class="headerlink" href="#composability" title="此标题的永久链接"></a></h1>
<p>该API的一个优点是，它可以轻松地将多个并行事物组成一个流水线。这里的 “组成 “是指有时你设计的流水线需要进行并行处理。</p>
<p>试想一下，如果您需要对 4 对数字进行浮点乘法运算（稍后求和）。并且这 4 对数字是由一个数据流同时提供的，那么就不需要 4 条不同的流水线来进行乘法运算，而需要在同一条流水线上并行处理。</p>
<p>下面的示例展示了一种模式，它将多个通道组成一个流水线，来并行处理它们。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// This area allows to take a input value and do +1 +1 +1 over 3 stages.</span>
<span class="c1">// I know that&#39;s useless, but let&#39;s pretend that instead it does a multiplication between two numbers over 3 stages (for FMax reasons)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Plus3</span><span class="p">(</span><span class="nc">INPUT</span><span class="p">:</span><span class="w"> </span><span class="nc">Payload</span><span class="p">[</span><span class="nc">UInt</span><span class="p">],</span><span class="w"> </span><span class="n">stage1</span><span class="p">:</span><span class="w"> </span><span class="nc">Node</span><span class="p">,</span><span class="w"> </span><span class="n">stage2</span><span class="p">:</span><span class="w"> </span><span class="nc">Node</span><span class="p">,</span><span class="w"> </span><span class="n">stage3</span><span class="p">:</span><span class="w"> </span><span class="nc">Node</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stage1</span><span class="p">(</span><span class="nc">INPUT</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">TWO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stage2</span><span class="p">(</span><span class="nc">ONE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage3</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stage3</span><span class="p">(</span><span class="nc">TWO</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Let&#39;s define a component which takes a stream as input,</span>
<span class="c1">// which carries &#39;lanesCount&#39; values that we want to process in parallel</span>
<span class="c1">// and put the result on an output stream</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">(</span><span class="n">lanesCount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">lanesCount</span><span class="p">)(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">lanesCount</span><span class="p">)(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define 3 Nodes for our pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes by using simples registers</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind io.up to n0</span>
<span class="w">  </span><span class="n">n0</span><span class="p">.</span><span class="n">arbitrateFrom</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">LANES_INPUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">n0</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>

<span class="w">  </span><span class="c1">// Let&#39;s use our &quot;reusable&quot; Plus3 area to generate each processing lane</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">lanes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">lanesCount</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Plus3</span><span class="p">(</span><span class="nc">LANES_INPUT</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind n2 to io.down</span>
<span class="w">  </span><span class="n">n2</span><span class="p">.</span><span class="n">arbitrateTo</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">lanesCount</span><span class="p">)</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n2</span><span class="p">(</span><span class="n">lanes</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="nc">THREE</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">s01</span><span class="p">,</span><span class="w"> </span><span class="n">s12</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will produce the following data path (assuming lanesCount = 2), arbitration not being shown :</p>
<a class="reference internal image-reference" href="../../../_images/composable_lanes.png"><img alt="../../../_images/composable_lanes.png" src="../../../_images/composable_lanes.png" style="width: 406.0px; height: 630.0px;" /></a>
</section>
<section id="retiming-variable-length">
<h1>Retiming / Variable length<a class="headerlink" href="#retiming-variable-length" title="此标题的永久链接"></a></h1>
<p>有时，你想设计一个流水线，但你并不真正知道关键路径在哪里，也不知道各阶段之间如何平衡。而且通常情况下，你无法依赖综合工具做好自动重定时工作。</p>
<p>因此，你需要一种简单的方法来构建流水线逻辑。</p>
<p>下面介绍如何使用此流水线 API：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define a component which will take a input stream of RGB value</span>
<span class="c1">// Process (~(R + G + B)) * 0xEE</span>
<span class="c1">// And provide that result into an output stream</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span><span class="n">addAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span>
<span class="w">                     </span><span class="n">invAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span>
<span class="w">                     </span><span class="n">mulAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span>
<span class="w">                     </span><span class="n">resultAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="n">spinal</span><span class="p">.</span><span class="n">lib</span><span class="p">.</span><span class="n">graphic</span><span class="p">.</span><span class="nc">Rgb</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define the Nodes for our pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Array</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">resultAt</span><span class="o">+</span><span class="mi">1</span><span class="p">)(</span><span class="nc">Node</span><span class="p">())</span>

<span class="w">  </span><span class="c1">// Let&#39;s specify which node will be used for what part of the pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">insertNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">addNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">addAt</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">invNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">invAt</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">mulNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">mulAt</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">resultNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">resultAt</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Define the hardware which will feed the io.up stream into the pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">inserter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">insertNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateFrom</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">RGB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// sum the r g b values of the color</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">addNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">inserter</span><span class="p">.</span><span class="nc">RGB</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inserter</span><span class="p">.</span><span class="nc">RGB</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inserter</span><span class="p">.</span><span class="nc">RGB</span><span class="p">.</span><span class="n">b</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// flip all the bit of the RGB sum</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">inverter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">invNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">INV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="o">~</span><span class="n">adder</span><span class="p">.</span><span class="nc">SUM</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// multiply the inverted bits with 0xEE</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">mulNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">MUL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">inverter</span><span class="p">.</span><span class="nc">INV</span><span class="o">*</span><span class="mh">0xEE</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Connect the end of the pipeline to the io.down stream</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">resulter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">resultNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateTo</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">)</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">multiplier</span><span class="p">.</span><span class="nc">MUL</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes sequentially by using simples registers</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">links</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">resultAt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">nodes</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">  </span><span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果像这样生成该组件：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span>
<span class="w">    </span><span class="n">addAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">invAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">mulAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">resultAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>您将获得由 3 层寄存器（flip flop）分隔的 4 个处理阶段：</p>
<a class="reference internal image-reference" href="../../../_images/rgbToSomething.png"><img alt="../../../_images/rgbToSomething.png" src="../../../_images/rgbToSomething.png" style="width: 114.8px; height: 392.0px;" /></a>
<p>请注意，生成的硬件 verilog 还算干净（至少按我的标准来说是这样 :P）：</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL dev    git head : 1259510dd72697a4f2c388ad22b269d4d2600df7</span>
<span class="c1">// Component : RgbToSomething</span>
<span class="c1">// Git hash  : 63da021a1cd082d22124888dd6c1e5017d4a37b2</span>

<span class="no">`timescale</span><span class="w"> </span><span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ps</span>

<span class="k">module</span><span class="w"> </span><span class="n">RgbToSomething</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_up_valid</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_up_ready</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_up_payload_r</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_up_payload_g</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_up_payload_b</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_down_valid</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_down_ready</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_down_payload</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">clk</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">reset</span>
<span class="p">);</span>

<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_nodes_0_adder_SUM</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">nodes_3_multiplier_MUL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">nodes_2_multiplier_MUL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_2_inverter_INV</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_1_inverter_INV</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_1_adder_SUM</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_adder_SUM</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_inserter_RGB_r</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_inserter_RGB_g</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_inserter_RGB_b</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">nodes_0_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_0_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_1_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_1_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_2_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_2_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_3_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">nodes_3_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StageLink_l56</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StageLink_l56_1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StageLink_l56_2</span><span class="p">;</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_nodes_0_adder_SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">nodes_0_inserter_RGB_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_g</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_valid</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_up_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_0_ready</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_payload_r</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_payload_g</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_payload_b</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_adder_SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_nodes_0_adder_SUM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_b</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_1_inverter_INV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="w"> </span><span class="n">nodes_1_adder_SUM</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_2_multiplier_MUL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">nodes_2_inverter_INV</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;hee</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_down_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_3_valid</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_3_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_down_ready</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_down_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_3_multiplier_MUL</span><span class="p">;</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">nodes_0_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_1_ready</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StageLink_l56</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_0_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StageLink_l56</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">nodes_1_valid</span><span class="p">);</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">nodes_1_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_2_ready</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StageLink_l56_1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_1_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StageLink_l56_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">nodes_2_valid</span><span class="p">);</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">nodes_2_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_3_ready</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StageLink_l56_2</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_2_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StageLink_l56_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">nodes_3_valid</span><span class="p">);</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_1_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">      </span><span class="n">nodes_2_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">      </span><span class="n">nodes_3_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_0_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">nodes_1_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_0_valid</span><span class="p">;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_1_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">nodes_2_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_1_valid</span><span class="p">;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_2_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">nodes_3_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_2_valid</span><span class="p">;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_0_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_1_adder_SUM</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_0_adder_SUM</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_1_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_2_inverter_INV</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_1_inverter_INV</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_2_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_3_multiplier_MUL</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_2_multiplier_MUL</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>


<span class="k">endmodule</span>
</pre></div>
</div>
<p>此外，您还可以轻松调整处理的级数和位置，例如，您可能希望将翻转的硬件逻辑移到与加法器相同级上。具体方法如下：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span>
<span class="w">    </span><span class="n">addAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">invAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">mulAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">resultAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>那么您可能需要移除输出寄存器级：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span>
<span class="w">    </span><span class="n">addAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">invAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">mulAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">resultAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>这个示例的一个特点是，中间值必须是 <cite>addNode</cite>。例如：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">addNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">addAt</span><span class="p">)</span>
<span class="c1">// sum the r g b values of the color</span>
<span class="kd">val</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">addNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unfortunately, scala doesn’t allow to replace <cite>new addNode.Area</cite> with <cite>new nodes(addAt).Area</cite>.
One workaround is to define a class as :</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">NodeArea</span><span class="p">(</span><span class="n">at</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">NodeMirror</span><span class="p">(</span><span class="n">nodes</span><span class="p">(</span><span class="n">at</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">NodeArea</span><span class="p">(</span><span class="n">addAt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>根据您的管道规模，它可以带来一些好处。</p>
</section>
<section id="simple-cpu-example">
<h1>简单的CPU示例<a class="headerlink" href="#simple-cpu-example" title="此标题的永久链接"></a></h1>
<p>下面是一个简单的 8 位 CPU 示例：</p>
<ul class="simple">
<li><p>三级流水线（fetch, decode, execute）</p></li>
<li><p>嵌入的获取存储器</p></li>
<li><p>add / jump / led /delay 指令</p></li>
</ul>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Cpu</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fetch</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">()</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">f2d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">fetch</span><span class="p">.</span><span class="n">down</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">d2e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">decode</span><span class="p">.</span><span class="n">down</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">INSTRUCTION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">led</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fetcher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">fetch</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pcReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">up</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pcReg</span>
<span class="w">    </span><span class="n">up</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">up</span><span class="p">.</span><span class="n">isFiring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">pcReg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">256</span><span class="p">)(</span><span class="nc">INSTRUCTION</span><span class="p">).</span><span class="n">simPublic</span>
<span class="w">    </span><span class="nc">INSTRUCTION</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="p">.</span><span class="n">readAsync</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">decoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">decode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_ADD</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x1</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_JUMP</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x2</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_LED</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x3</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_DELAY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x4</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">alu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">execute</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">stage</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="n">fetch</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">stage</span><span class="p">.</span><span class="n">throwWhen</span><span class="p">(</span><span class="n">flush</span><span class="p">,</span><span class="w"> </span><span class="n">usingReady</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">isValid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_ADD</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">regfile</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">regfile</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_JUMP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">flush</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span>
<span class="w">        </span><span class="n">fetcher</span><span class="p">.</span><span class="n">pcReg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_LED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">led</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="n">regfile</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_DELAY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">delayCounter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">execute</span><span class="p">.</span><span class="n">haltIt</span><span class="p">()</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">fetch</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="p">,</span><span class="w"> </span><span class="n">f2d</span><span class="p">,</span><span class="w"> </span><span class="n">d2e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是一个简单的测试平台，它实现了一个循环，使 led 计数值上升。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withFstWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Cpu</span><span class="p">).</span><span class="n">doSim</span><span class="p">(</span><span class="n">seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">){</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">nop</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">jump</span><span class="p">(</span><span class="n">target</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">led</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">delay</span><span class="p">(</span><span class="n">cycles</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">cycles</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">fetcher</span><span class="p">.</span><span class="n">mem</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">nop</span><span class="p">())</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">nop</span><span class="p">())</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mh">0x1</span><span class="p">))</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">led</span><span class="p">())</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">delay</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">jump</span><span class="p">(</span><span class="mh">0x2</span><span class="p">))</span>

<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="index.html" class="btn btn-neutral float-left" title="Pipeline" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../Misc/index.html" class="btn btn-neutral float-right" title="杂项" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2018 - 2024, SpinalHDL.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
  
     
    <!-- source/_templates/footer.html -->


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>