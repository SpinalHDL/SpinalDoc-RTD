<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>简介 &mdash; SpinalHDL  文档</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/gh-fork-ribbon.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/spinaldoc.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/logo3_32x32.png"/>
    <link rel="canonical" href="https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Libraries/Pipeline/introduction.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/skins/default.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/wavedrom.min.js"></script>
        <script src="../../../_static/dialog.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="杂项" href="../Misc/index.html" />
    <link rel="prev" title="Pipeline" href="index.html" />
     
    <!-- source/_templates/layout.html -->
    
    
    

</head>

<body class="wy-body-for-nav">
     
    
    
    
    <div class="div-svg-github-corner github-corner-abs">
    <a href="https://github.com/SpinalHDL/SpinalDoc-RTD/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst" class="github-corner github-fork-ribbon" aria-label="Edit on GitHub" data-ribbon="Edit on GitHub" title="Edit on GitHub">
      <object id="svg-github-corner" data="../../../_static/github-corner-right.svg" class="svg-github-corner github-corner-abs" width="80" height="80"></object>
    </a>
    </div>
    
    
    

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SpinalHDL
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Foreword/index.html">前言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Foreword/index.html#why-moving-away-from-traditional-hdl">为什么要放弃传统的 HDL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#vhdl-verilog-aren-t-hardware-description-languages">VHDL/Verilog 不是硬件描述语言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#event-driven-paradigm-doesn-t-make-any-sense-for-rtl">事件驱动范式对于 RTL 没有任何意义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#recent-revisions-of-vhdl-and-verilog-aren-t-usable">VHDL 和 Verilog 的最新版本不可用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#vhdl-records-verilog-struct-are-broken-systemverilog-is-good-on-this-if-you-can-use-it">VHDL 结构记录（record），Verilog 结构（struct）已经破碎（SystemVerilog 在这方面很好，如果您可以使用它）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#vhdl-and-verilog-are-so-verbose">VHDL 和 Verilog 太冗长了</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Foreword/index.html#meta-hardware-description-capabilities">元硬件描述能力</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction/index.html">简介</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/SpinalHDL.html">关于 SpinalHDL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#what-is-spinalhdl">什么是SpinalHDL？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#what-spinalhdl-is-not">SpinalHDL 不是什么</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#the-spinal-development-flow">Spinal开发流程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/SpinalHDL.html#advantages-of-using-spinalhdl-over-vhdl-verilog">SpinalHDL 相对于 VHDL / Verilog 的优势</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/A%20simple%20example.html">一个简单的例子</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/A%20simple%20example.html#component">Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/A%20simple%20example.html#ports">端口</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/A%20simple%20example.html#internal-logic">内部逻辑</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html">使用 SpinalHDL 的项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html#repositories">仓库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html#companies">公司</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/Projects%20using%20SpinalHDL.html#universities">大学</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Getting%20in%20touch.html">联系方式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/License.html">许可证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Contributing.html">贡献</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/faq.html">常见问题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#what-is-the-overhead-of-spinalhdl-generated-rtl-compared-to-human-written-vhdl-verilog">与人工编写的 VHDL/Verilog 相比，SpinalHDL 生成的 RTL 的开销是多少？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#what-if-spinalhdl-becomes-unsupported-in-the-future">如果 SpinalHDL 将来没有支持了怎么办？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#does-spinalhdl-keep-comments-in-generated-vhdl-verilog">SpinalHDL 是否在生成的 VHDL/Verilog 中保留注释？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#could-spinalhdl-scale-up-to-big-projects">SpinalHDL 可以扩展到大型项目吗？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#how-spinalhdl-came-to-be">SpinalHDL 是如何诞生的</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#why-develop-a-new-language-when-there-is-vhdl-verilog-systemverilog">既然有了VHDL/Verilog/SystemVerilog，为什么还要开发新的语言呢？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Introduction/faq.html#how-to-use-an-unreleased-version-of-spinalhdl-but-committed-on-git">如何使用 SpinalHDL 的未发布版本（但在 git 上提交）？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Introduction/Other%20learning%20materials.html">其他学习资料</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Getting%20Started/index.html">入门</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html">安装和设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#required-recommended-tools">必需/推荐的工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#linux-installation">Linux安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#mac-os-x-installation">Mac OS X 安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#windows-installation">Windows安装</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#msys2-verilator-for-simulation">用于仿真的 MSYS2 verilator工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#msys2-for-formal-verification">用 MSYS2 实施形式化验证</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#oci-container">OCI容器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#installing-sbt-in-an-internet-free-linux-environment">在无网络的 Linux 环境中安装 SBT</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#create-a-first-spinalhdl-project">创建第一个 SpinalHDL 项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#the-directory-structure-of-a-project">项目的目录结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Install%20and%20setup.html#using-spinal-on-spinalhdl-code">在 SpinalHDL 代码中使用 Spinal</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/SBT.html">在 CLI （命令行）中结合 SBT 使用 Spinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/VSCodium.html">在 VSCodium 中使用 Spinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/IntelliJ.html">从 IntelliJ IDEA 使用 Spinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/index.html">Scala 使用指南</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html">基础内容</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#types">类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#variables">变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#functions">函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#object">对象（Object）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#entry-point-main">入口点（main）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#class">类</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/basics.html#templates-type-parameterization">模板/类型参数化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/coding_conventions.html">编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/coding_conventions.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/coding_conventions.html#class-vs-case-class">类与样例类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html">交互</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#how-spinalhdl-works-behind-the-api">SpinalHDL 在 API 隐藏后的工作原理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#everything-is-a-reference">一切都是引用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#hardware-types">硬件类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#names-of-signals-in-the-generated-rtl">生成的 RTL 中的信号名称</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#scala-is-for-elaboration-spinalhdl-for-hardware-description">Scala 用于实例细化，SpinalHDL 用于硬件描述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/interaction.html#scala-elaboration-capabilities-if-for-functional-programming">Scala 实例细化能力（if、for、函数式编程）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/index.html#id1">Scala 使用指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Scala%20Guide/index.html#introduction">简介</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/index.html">VHDL 用户入门</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html">与VHDL对比</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#process">过程（Process）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#implicit-vs-explicit-definitions">隐式与显式定义对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#clock-domains">时钟域</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#component-s-internal-organization">组件的内部组织方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#safety">安全性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#functions-and-procedures">功能与流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#buses-and-interfaces">总线和接口</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#signal-declaration">信号声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#component-instantiation">组件实例化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#casting">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#resizing">调整位宽</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#parameterization">参数化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_comp.html#meta-hardware-description">元硬件描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html">VHDL 等效语法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#entity-and-architecture">实体和架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#data-types">数据类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#signal">信号</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#assignments">赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#literals">字面量（Literals）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#registers">寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Getting%20Started/Help%20for%20VHDL%20people/vhdl_perspective.html#process-blocks">过程块</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/index.html">快速参考</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/core.html">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/lib.html">Lib</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Getting%20Started/Cheatsheets/symbolic.html">Symbolic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Data%20types/index.html">数据类型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/bool.html">Bool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bool.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bool.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bool.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#logic">逻辑运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#edge-detection">边缘检测</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#misc">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bool.html#maskedboolean">掩码布尔值</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/bits.html">位</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bits.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bits.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#logic">逻辑运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#bit-extraction">位提取</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bits.html#misc">杂项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bits.html#maskedliteral">掩码字面量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Int.html">UInt/SInt</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Int.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Int.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#logic">逻辑运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#arithmetic">算术运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#bit-extraction">位提取</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#misc">杂项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Int.html#fixpoint-operations">定点小数操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#lower-bit-operations">低位运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#high-bit-operations">高位操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Int.html#fixto-function">fixTo 函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/enum.html">SpinalEnum</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/enum.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/enum.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#encoding">编码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/enum.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#types">类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/enum.html#type-cast">类型转换</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/bundle.html">Bundle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#conditional-signals">条件信号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#convert-bits-back-to-bundle">将位转换回线束</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/bundle.html#io-element-direction">IO元件方向</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#in-out">in/out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/bundle.html#master-slave">master/slave</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Vec.html">Vec</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Vec.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Vec.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#examples">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Vec.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#misc">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Vec.html#lib-helper-functions">库辅助函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Fix.html">UFix/SFix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#unsigned-fixed-point">无符号定点小数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#signed-fixed-point">有符号定点小数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#format">格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#examples">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#assignments">赋值</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#valid-assignments">有效赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#from-a-scala-constant">来自 Scala 常量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#raw-value">原始值</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#id2">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Fix.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#arithmetic">算术运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#comparison">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#type-cast">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Fix.html#misc">杂项</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/Floating.html">浮点小数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Floating.html#description">描述</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#ieee-754-floating-format">IEEE-754 浮点小数格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#recoded-floating-format">重新编码的浮动小数格式</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Floating.html#declaration">声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#ieee-754-number">IEEE-754 编码数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#recoded-floating-point-number">重新编码的浮点数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/Floating.html#operators">运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Data%20types/Floating.html#type-cast">类型转换</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Data%20types/AFix.html">AFix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#declaration">声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#mathematical-operations">数学运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#inequality-operations">不等式运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#bitshifting">位移操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#saturation-and-rounding">饱和与舍入</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Data%20types/AFix.html#assignment">赋值</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Structuring/index.html">结构设计</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/components_hierarchy.html">组件和层次结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#input-output-definition">输入/输出定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#pruned-signals">裁剪信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#parametrized-hardware-generic-in-vhdl-parameter-in-verilog">参数化硬件（VHDL 中的“Generic”，Verilog 中的“Parameter”）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/components_hierarchy.html#synthesized-component-names">综合后组件名称</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/area.html">Area</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/function.html">函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/function.html#rgb-to-gray">RGB信号转灰度信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/function.html#valid-ready-payload-bus">Valid Ready Payload 总线</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/clock_domain.html">时钟域</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#instantiation">实例化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#configuration">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#internal-clock">内部时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#external-clock">外部时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#signal-priorities-in-hdl-generation">生成 HDL 时的信号优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#context">语境</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#clock-domain-crossing">跨时钟域设计</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/clock_domain.html#special-clocking-areas">特殊计时逻辑区</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#slow-area">慢时钟逻辑区</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#bootreset">启动复位</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#resetarea">复位时钟域</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/clock_domain.html#clockenablearea">时钟使能逻辑区</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/blackbox.html">实例化 VHDL 和 Verilog IP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#description">描述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#defining-an-blackbox">定义一个黑盒</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#generics">泛型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#instantiating-a-blackbox">实例化黑盒</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#clock-and-reset-mapping">时钟和复位信号的映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#io-prefix">io前缀</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#rename-all-io-of-a-blackbox">重命名黑盒中的所有io</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#add-rtl-source">添加 RTL 源</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/blackbox.html#vhdl-no-numeric-type">VHDL - 无数值类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/naming.html">保留名称的方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#nameable-base-class">Nameable 基类</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#name-extraction-from-scala">从 Scala 中提取名称</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#area-in-a-component">组件中的区域</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#area-in-a-function">函数中的逻辑区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#composite-in-a-function">函数中的复合区（Composite）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#composite-chains">复合区级联链</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#composite-in-a-bundle-s-function">在一个线束（Bundle）的函数中的复合区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/naming.html#unamed-signal-handling">未命名信号处理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#verilog-expression-splitting">Verilog 表达式分割</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#verilog-long-expression-splitting">Verilog 长表达式分割</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#when-statement-condition">When 语句条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Structuring/naming.html#in-last-resort">最后一招</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Structuring/parametrization.html">参数化</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/parametrization.html#elaboration-time-parameters">实例细化时参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Structuring/parametrization.html#optional-hardware">可选硬件</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Semantic/index.html">语义</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Semantic/assignments.html">赋值</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/assignments.html#width-checking">位宽检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/assignments.html#combinatorial-loops">组合逻辑环(Combinatorial loops)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/assignments.html#combinit">CombInit</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Semantic/when_switch.html">When/Switch/Mux</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#when">When</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#switch">Switch</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Semantic/when_switch.html#example">示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Semantic/when_switch.html#additional-options">其他选项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#local-declaration">本地声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#mux">Mux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/when_switch.html#bitwise-selection">按位选择</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Semantic/when_switch.html#id1">示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Semantic/rules.html">规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/rules.html#concurrency">并发</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/rules.html#last-valid-assignment-wins">最后有效赋值生效</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Semantic/rules.html#signal-and-register-interactions-with-scala-oop-reference-functions">信号和寄存器与 Scala 语言的协作（OOP 引用 + 函数）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Sequential%20logic/index.html">时序逻辑</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Sequential%20logic/registers.html">寄存器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#instantiation">实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#reset-value">复位值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#initialization-value-for-simulation-purposes">用于仿真目的的初始化值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#register-vectors">寄存器组</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/registers.html#transforming-a-wire-into-a-register">将线缆/信号转换为寄存器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Sequential%20logic/memory.html">RAM/ROM存储器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#synchronous-enable-quirk">同步使能注意事项</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#read-under-write-policy">写入时读取策略</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#mixed-width-ram">混合位宽存储器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Sequential%20logic/memory.html#automatic-blackboxing">自动黑盒化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Sequential%20logic/memory.html#blackboxing-policy">黑盒策略</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Sequential%20logic/memory.html#standard-memory-blackboxes">标准存储器黑盒</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Design%20errors/index.html">设计错误</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/assignment_overlap.html">赋值覆盖(Assignment overlap)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/assignment_overlap.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/assignment_overlap.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html">跨时钟域违例(Clock crossing violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#example">示例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#crossclockdomain-tag">crossClockDomain标签</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#setsynchronouswith">setSynchronousWith</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/clock_crossing_violation.html#buffercc">BufferCC</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html">组合逻辑环(Combinatorial loop)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/combinatorial_loop.html#false-positives">误报</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/hierarchy_violation.html">层次违例(Hierarchy violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/hierarchy_violation.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/hierarchy_violation.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/iobundle.html">IO线束</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/iobundle.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/iobundle.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/latch_detected.html">锁存器检测(Latch detected)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/latch_detected.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/latch_detected.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/latch_detected.html#due-to-mux">因多路复用器产生的错误</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/no_driver_on.html">无驱动检测(No driver on)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/no_driver_on.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/no_driver_on.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html">空指针异常(NullPointerException)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html#example">示例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Design%20errors/nullpointerexception.html#issue-explanation">问题说明</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html">超出范围的常数(Out of Range Constant)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/out_of_range_constant.html#specifying-exceptions">特殊情况</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/register_defined_as_component_input.html">定义为组件输入的寄存器(Register defined as component input)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/register_defined_as_component_input.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/register_defined_as_component_input.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/scope_violation.html">作用域违例(Scope violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/scope_violation.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/scope_violation.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html">Spinal无法克隆类(Spinal can’t clone class)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html#example-1">例子1</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/spinal_cant_clone.html#example-2">例子2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/unassigned_register.html">未赋值的寄存器(Unassigned register)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unassigned_register.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unassigned_register.html#example">示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unassigned_register.html#register-with-only-init">只有初始化(init)的寄存器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/unreachable_is_statement.html">无法访问的is语句(Unreachable is statement)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unreachable_is_statement.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/unreachable_is_statement.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Design%20errors/width_mismatch.html">位宽不匹配(Width mismatch)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/width_mismatch.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/width_mismatch.html#assignment-example">赋值示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Design%20errors/width_mismatch.html#operator-example">运算操作示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Other%20language%20features/index.html">其他语言功能</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/utils.html">实用工具</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#general">介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/utils.html#cat">Cat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#cloning-hardware-datatypes">克隆硬件数据类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#passing-a-datatype-as-construction-parameter">将数据类型作为构造函数参数传递</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/utils.html#the-old-way">老办法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/utils.html#the-safe-way">安全的方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#frequency-and-time">频率和时间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/utils.html#binary-prefix">二进制前缀</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/stub.html">存根（Stub）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/assertion.html">Assertions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/report.html">Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/scope_property.html">ScopeProperty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html">模拟信号和输入输出</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#analog">模拟信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#inout">输入/出</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#inoutwrapper">输入/出包装器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/analog_inout.html#manually-driving-analog-bundles">手动驱动模拟线束</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html">VHDL 和 Verilog 生成</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#generate-vhdl-and-verilog-from-a-spinalhdl-component">从 SpinalHDL 组件生成 VHDL 和 Verilog</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#parametrization-from-scala">Scala 的参数化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#parametrization-from-shell">来自 shell 的参数化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#generated-vhdl-and-verilog">生成的 VHDL 和 Verilog</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#organization">组织</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#combinational-logic">组合逻辑</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#sequential-logic">时序逻辑</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Other%20language%20features/vhdl_generation.html#vhdl-and-verilog-attributes">VHDL 和 Verilog 属性</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">模块库</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../utils.html">实用工具</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../utils.html#state-less-utilities">免状态工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../utils.html#state-full-utilities">全状态工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../utils.html#counter">计数器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utils.html#timeout">超时</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utils.html#resetctrl">复位控制</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../utils.html#special-utilities">特殊工具</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../stream.html">Stream</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#semantics">语义</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#functions">函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#utils">实用工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamfifo">StreamFifo</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamfifocc">StreamFifoCC</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamccbytoggle">StreamCCByToggle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamwidthadapter">StreamWidthAdapter（反压流位宽适应器）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamarbiter">StreamArbiter（反压流仲裁器）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamjoin">StreamJoin</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamfork">StreamFork</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streammux">StreamMux</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamdemux">StreamDemux</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamdispatchersequencial">StreamDispatcherSequencial</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stream.html#streamtransactionextender">StreamTransactionExtender</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../stream.html#simulation-support">仿真支持</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../flow.html">Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#functions">函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#code-example">代码示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../flow.html#simulation-support">仿真支持</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../fragment.html">Fragment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fragment.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fragment.html#functions">函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../fsm.html">状态机</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fsm.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fsm.html#statemachine">StateMachine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#entry-point">入口点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#transitions">转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#state-encoding">状态编码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../fsm.html#states">状态</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#statedelay">StateDelay（状态延迟）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#statefsm">StateFsm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#stateparallelfsm">StateParallelFsm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../fsm.html#notes-about-the-entry-state">关于入口状态的注释</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../vexriscv.html">VexRiscv（RV32IM CPU）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bus_slave_factory.html">总线从端生成器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bus_slave_factory.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bus_slave_factory.html#functionality">功能</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../fiber.html">纤程框架</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../fiber.html#simple-dummy-example">简单的示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fiber.html#handle-t">Handle[T]</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../fiber.html#soon-handle">soon(handle)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../binarySystem.html">二进制系统</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#string-to-int-long-bigint">String转为Int/Long/BigInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#int-long-bigint-to-string">Int/Long/BigInt转为String</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#int-long-bigint-to-binary-list">Int/Long/BigInt转为二进制列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#binary-list-to-int-long-bigint">二进制列表转为Int/Long/BigInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../binarySystem.html#bigint-enricher">BigInt放大器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../regIf.html">RegIf</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#automatic-allocation">自动分配</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#access-types">28种访问类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#automatic-documentation-generation">自动生成文档</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#special-access-usage">特殊访问用途</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#byte-mask">字节掩码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#typical-example">典型例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#interrupt-factory">中断生成器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#ip-level-interrupt-factory">IP级中断生成器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#sys-level-interrupt-merge">SYS级中断合并</a></li>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#spinal-factory">Spinal的生成器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../regIf.html#example">示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#defaultreadvalue">默认读取值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regIf.html#developers-area">开发者区域</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Bus/index.html">总线</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Bus/amba3/ahblite3.html">AHB-Lite3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/ahblite3.html#configuration-and-instanciation">配置和实例化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/ahblite3.html#variations">变体</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/amba3/apb3.html">Apb3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/apb3.html#configuration-and-instanciation">配置和实例化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba3/apb3.html#functions-and-operators">函数和运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/amba4/axi4.html">Axi4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba4/axi4.html#configuration-and-instanciation">配置和实例化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba4/axi4.html#variations">变体</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/amba4/axi4.html#functions-and-operators">函数和运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/avalon/avalonmm.html">AvalonMM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/avalon/avalonmm.html#configuration-and-instanciation">配置和实例化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/tilelink/tilelink.html">Tilelink</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink.html#configuration-and-instanciation">配置和实例化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html">tilelink.fabric.Node</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-toplevel">顶层示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-gpiofiber">GPIOFiber示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-ramfiber">RamFiber示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-cpufiber">CpuFiber示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Bus/tilelink/tilelink_fabric.html#example-widthadapter">位宽适配器(WidthAdapter)示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Com/index.html">通信接口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Com/spiXdr.html">SPI XDR</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/spiXdr.html#configuration">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/spiXdr.html#software-driver">软件驱动</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Com/uart.html">串口</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/uart.html#bus-definition">总线定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/uart.html#uartctrl">UartCtrl</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Com/usb_device.html">USB设备</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#architecture">架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#registers">寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#descriptors">描述符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_device.html#usage">用法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Com/usb_ohci.html">USB OHCI</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Com/usb_ohci.html#usage">用法</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../IO/index.html">IO口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../IO/readableOpenDrain.html">可读开漏IO(ReadableOpenDrain)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../IO/tristate.html">三态</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../IO/tristate.html#id1">三态</a></li>
<li class="toctree-l4"><a class="reference internal" href="../IO/tristate.html#tristatearray">三态阵列</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Graphics/index.html">图形</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Graphics/colors.html">颜色</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/colors.html#rgb">RGB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Graphics/vga.html">VGA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/vga.html#vga-bus">VGA总线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/vga.html#vga-timings">VGA时序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Graphics/vga.html#vga-controller">VGA控制器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../EDA/index.html">自动设计工具(EDA)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../EDA/altera/qsysify.html">QSysify</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/qsysify.html#example">示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/qsysify.html#tags">标签</a></li>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/qsysify.html#adding-new-interface-support">添加新的接口支持</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../EDA/altera/quartus_flow.html">QuartusFlow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/quartus_flow.html#for-a-single-rtl-file">对于单个rtl文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../EDA/altera/quartus_flow.html#for-an-existing-project">对于一个现有项目</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Pipeline</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">简介</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-example">简单示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#payload">Payload</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node">Node</a></li>
<li class="toctree-l3"><a class="reference internal" href="#links">Links</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#directlink">DirectLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stagelink">StageLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#s2mlink">S2mLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ctrllink">CtrlLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-links">其他链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="#your-custom-link">您的自定义链接</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#builder">Builder</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composability">组合能力（Composability）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retiming-variable-lenth">重定时/可变长度</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-cpu-example">简单的CPU示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Misc/index.html">杂项</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html">Plic映射器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html#plicmapper-apply"><code class="docutils literal notranslate"><span class="pre">PlicMapper.apply</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html#plicmapping-sifive"><code class="docutils literal notranslate"><span class="pre">PlicMapping.sifive</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/PLIC/plic_mapper.html#plicmapping-light"><code class="docutils literal notranslate"><span class="pre">PlicMapping.light</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Misc/service_plugin.html">插件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#execution-order">执行顺序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#simple-example">简单示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../Misc/service_plugin.html#interlocking-ordering">联锁/排序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Simulation/index.html">仿真</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/install/index.html">用于仿真的 SBT 设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/install/index.html#backend-dependent-installation-instructions">后台依赖的安装说明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/GHDL.html">GHDL 的设置和安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/Icarus%20Verilog.html">Icarus Verilog 的设置和安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/VCS.html">VCS 仿真配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Simulation/install/Verilator.html">Verilator 的设置和安装</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/bootstraps.html">启动仿真器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#configuration">配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#running-multiple-tests-on-the-same-hardware">在同一硬件上运行多个测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#throw-success-or-failure-of-the-simulation-from-a-thread">从线程中抛出仿真成功或失败结果</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/bootstraps.html#capturing-wave-for-a-given-window-before-failure">在失败之前捕获给定时间窗内的波形</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/signal.html">仿真过程中访问信号</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/signal.html#read-and-write-signals">读写信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/signal.html#accessing-signals-inside-the-component-s-hierarchy">访问组件层次结构内部的信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/signal.html#load-and-store-of-memory-in-simulation">仿真中内存的加载和存储</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/clock.html">时钟域</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#stimulus-api">激励函数API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#wait-api">等待相关API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#callback-api">回调函数API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#default-clockdomain">默认时钟域</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/clock.html#new-clockdomain">新时钟域</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/threadFull.html">全线程API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/threadFull.html#fork-and-join-simulation-threads">分裂和合并仿真线程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/threadFull.html#sleep-and-waituntil">休眠和等待</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/threadLess.html">无线程API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/sensitive.html">敏感API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/simulator_specifics.html">仿真器的具体细节</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-verilator-backend">SpinalHDL 如何使用 Verilator 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-ghdl-icarus-verilog-backend">SpinalHDL 如何使用 GHDL/Icarus Verilog 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-synopsys-vcs-backend">SpinalHDL 如何使用 Synopsys VCS 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#how-spinalhdl-simulates-the-hardware-with-xilinx-xsim-backend">SpinalHDL 如何使用 Xilinx XSim 后端进行硬件仿真</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/simulator_specifics.html#performance">性能</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/engine.html">仿真引擎</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Simulation/examples/index.html">示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/asynchronous.html">异步加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/dual_clock_fifo.html">双时钟域FIFO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/single_clock_fifo.html">单时钟域FIFO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/synchronous.html">同步加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/uart_decoder.html">串口解码器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Simulation/examples/uart_encoder.html">串口编码器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Formal%20verification/index.html">形式化验证</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#general">介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#formal-backend">形式化验证后端</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#installing-requirements">安装要求</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#example">示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#external-assertions">外部断言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#internal-assertions">内部断言</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#external-stimulus">外部激励</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#more-assertions-past">更多关于断言/past（以前某个时钟内的状态）的例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#assuming-memory-content">假设内存中的内容</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#utilities-and-primitives">实用工具和原语</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#assertions-clock-reset">断言/时钟/复位</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#specifying-the-initial-value-of-a-signal">指定信号的初始值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#specifying-a-initial-assumption">指定初始假设</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#memory-content-mem">内存内容（Mem）检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#specifying-assertion-in-the-reset-scope">在复位的时候进行断言检查，可以这样做</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#formal-primitives">形式化验证的原语</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#limitations">局限性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Formal%20verification/index.html#naming-polices">命名策略</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#for-component">对于组件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Formal%20verification/index.html#for-interfaces-implement-imasterslave">对于实现 IMasterSlave的接口</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Examples/index.html">示例</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/Simple%20ones/index.html">简单示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html">APB3定义</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#implementation">实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/apb3.html#usage">用法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/carry_adder.html">进位加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/color_summing.html">颜色求和</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/counter_with_clear.html">带清零的计数器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/pll_resetctrl.html">锁相环黑盒和复位控制器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/pll_resetctrl.html#the-pll-blackbox-definition">PLL BlackBox定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Simple%20ones/pll_resetctrl.html#toplevel-definition">TopLevel定义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/rgb_to_gray.html">RGB信号转灰度信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Simple%20ones/sinus_rom.html">正弦rom</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/Intermediates%20ones/index.html">中级示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html">分形计算器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#elaboration-parameters-generics">细化参数（泛型）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#bundle-definition">Bundle定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/fractal.html#component-implementation">组件实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html">串口</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#data-structures">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#implementation">实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#simple-usage">简单应用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#example-with-test-bench">带TestBench的例子</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/uart.html#bonus-having-fun-with-stream">额外奖励：享受 Stream 带来的乐趣</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html">VGA</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html#data-structures">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Intermediates%20ones/vga.html#vga-controller">VGA控制器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/Advanced%20ones/index.html">高级示例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html">JTAG TAP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#jtag-bus">JTAG总线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#jtag-state-machine">JTAG状态机</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#id1">JTAG TAP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#jtag-instructions">Jtag指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#user-friendly-wrapper">用户友好型包装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/jtag.html#usage-demonstration">使用演示</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html">内存映射UART</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html#specification">规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/memory_mapped_uart.html#implementation">实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/pinesec.html">Pinesec</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/slots.html">插槽(Slots)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/slots.html#introduction">简介</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html">计时器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html#id2">计时器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Examples/Advanced%20ones/timer.html#bridging-function">桥接函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Examples/index.html#getting-started">入门</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Legacy/index.html">历史遗留</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Legacy/riscv.html">RiscV</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#features">特性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#base-fpga-project">基础FPGA项目</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#how-to-generate-the-cpu-vhdl">如何生成CPU VHDL</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#how-to-debug">如何调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/riscv.html#todo">Todo</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Legacy/pinsec/index.html">pinsec</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/introduction.html">简介</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/introduction.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/introduction.html#board-support">板级支持</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/hardware.html">硬件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#riscv">RISCV</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#axi4">AXI4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#apb3">APB3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware.html#generate-the-rtl">生成RTL</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html">SoC顶层(Pinsec)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#introduction">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#defining-all-io">定义所有IO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#clock-and-resets">时钟和复位</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#main-components">主要组件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#peripherals">外设</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#bus-interconnects">总线互连</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/hardware_toplevel.html#misc">杂项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Legacy/pinsec/software.html">软件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/software.html#riscv-tool-chain">RISCV工具链</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Legacy/pinsec/software.html#openocd-gdb-eclipse-configuration">OpenOCD/GDB/Eclipse配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../miscelenea/index.html">杂项</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/frequent_errors.html">常见错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/frequent_errors.html#exception-in-thread-main-java-lang-nullpointerexception">“main”线程中异常 java.lang.NullPointerException</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/frequent_errors.html#hierarchy-violation">层次违例(Hierarchy violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/frequent_errors.html#signal-x-can-t-be-assigned-by-y">Signal X can’t be assigned by Y</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/frequent_errors.html#input-signal-x-can-t-be-assigned-by-y">Input signal X can’t be assigned by Y</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/frequent_errors.html#output-signal-x-can-t-be-assigned-by-y">Output signal X can’t be assigned by Y</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/core/core_components.html"><code class="docutils literal notranslate"><span class="pre">spinal.core</span></code> 组件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#clock-domains-definitions">时钟域定义</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#clock-domain-syntax">时钟域语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#clock-configuration">时钟配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#external-clock">外部时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#cross-clock-domain">跨时钟域设计</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#assignments">赋值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#when-switch">When / Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#component-hierarchy">组件/层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#area">Area</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#function">函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#rgb-to-gray">RGB信号转灰度信号</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../miscelenea/core/core_components.html#valid-ready-payload-bus">Valid Ready Payload 总线</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#vhdl-generation">VHDL生成</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#instantiate-vhdl-and-verilog-ip">实例化 VHDL 和 Verilog IP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../miscelenea/core/core_components.html#utils">实用工具</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/core/elements.html">Element</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscelenea/core/elements.html#range">范围</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Developers%20area/index.html">开发者专区</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html">总线从端（Factory）实现</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#specification">规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#implementation">实现</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#busslavefactory">BusSlaveFactory</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#busslavefactorydelayed">BusSlaveFactoryDelayed</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#avalonmmslavefactory">AvalonMMSlaveFactory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/bus_slave_factory_impl.html#conclusion">结论</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/howtodocument.html">如何修改本文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howtodocument.html#title-convention">标题约定</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howtodocument.html#wavedrom-integration">Wavedrom 的集成</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/howtodocument.html#new-section">新章节</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/howtodocument.html#example">示例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/mill%20support.html">通过Mill构建（输出）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#compile-the-library">编译SpinalHDL库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#run-all-test-suites">运行所有测试套件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#run-a-specified-test-suite">运行指定的测试套件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#run-a-specified-app">运行指定程序（App）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/mill%20support.html#publish-locally">本地发布</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html">SpinalHDL 内部数据模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#general-structure">总体结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#exploring-the-datamodel">探索数据模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#compilation-phases">编译环节</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#modifying-a-netlist-as-a-user-without-plugins">在不使用插件的情况下，以用户身份修改网表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#user-space-netlist-analysis">用户空间网表分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/spinalhdl_datamodel.html#enumerating-every-clockdomain-in-use">遍历、枚举正在使用的每个时钟域</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../Developers%20area/types.html">类型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#introduction">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bool">Bool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#declaration">声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#operators">运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#the-bitvector-family-bits-uint-sint">BitVector 系列 - (<code class="docutils literal notranslate"><span class="pre">Bits</span></code>, <code class="docutils literal notranslate"><span class="pre">UInt</span></code>, <code class="docutils literal notranslate"><span class="pre">SInt</span></code>)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#declaration-syntax">声明语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#id1">运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#masked-comparison">掩码过滤结果比较</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bits">位</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#uint-sint">UInt、SInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bool-bits-uint-sint">Bool, Bits, UInt, SInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#vec">Vec</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#bundle">Bundle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#simple-example-rgb-vga">简单示例（RGB/VGA）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Developers%20area/types.html#interface-example-apb">接口示例（APB）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#enum">Enum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#data-bool-bits-uint-sint-enum-bundle-vec">Data (Bool, Bits, UInt, SInt, Enum, Bundle, Vec)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#literals-as-signal-declaration">使用字面量声明信号</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../Developers%20area/types.html#continuous-assignment-literals-as-signal-declaration">用连续赋值字面量作来声明信号</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpinalHDL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">模块库</a></li>
          <li class="breadcrumb-item"><a href="index.html">Pipeline</a></li>
      <li class="breadcrumb-item active">简介</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/SpinalHDL/SpinalDoc-RTD/blob/master/source/SpinalHDL/Libraries/Pipeline/introduction.rst" class="fa fa-github"> 在 GitHub 上编辑</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             


  <section id="introduction">
<h1>简介<a class="headerlink" href="#introduction" title="此标题的永久链接"></a></h1>
<p>spinal.lib.misc.pipeline提供了一套流水线API。相对于手动流水线它的主要优点是：</p>
<ul class="simple">
<li><p>您不必预先准备好整个流水系统中所需的所有信号元素。您可以根据设计需要，以更特别的方式创建和使用可分级的信号，而无需重构所有中间阶段来处理信号</p></li>
<li><p>流水线的信号可以利用SpinalHDL的强大参数化能力，并且如果设计构建中不需要特定的参数化特征，则可以进行优化/移除，而不需要以显著的方式修改流水系统设计或项目代码库。</p></li>
<li><p>手动时序调整要容易得多，因为您不必手动处理寄存器/仲裁器</p></li>
<li><p>它会自行管理仲裁器</p></li>
</ul>
<p>API由4个主要部分组成：</p>
<ul class="simple">
<li><p>Node：表示管道中的层</p></li>
<li><p>Link：允许节点相互连接</p></li>
<li><p>Builder：生成整个管道所需的硬件</p></li>
<li><p>Payload：用于获取流水线的节点上的硬件信号</p></li>
</ul>
<p>重要的是，Payload不是硬件数据/信号实例，而是用于检索流水线在节点中数据/信号的关键，并且流水线构建器随后将在节点之间的每次给定Payload出现时自动互连/流水线。</p>
<p>以下是一个用于阐述的例子：</p>
<a class="reference internal image-reference" href="../../../_images/intro_pip.png"><img alt="../../../_images/intro_pip.png" src="../../../_images/intro_pip.png" style="width: 251.99999999999997px; height: 331.79999999999995px;" /></a>
<p>以下是关于此API的视频：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=74h_-FMWWIM">https://www.youtube.com/watch?v=74h_-FMWWIM</a></p></li>
</ul>
<section id="simple-example">
<h2>简单示例<a class="headerlink" href="#simple-example" title="此标题的永久链接"></a></h2>
<p>下面是一个简单的例子，它只使用了基本的API：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">misc</span><span class="p">.</span><span class="nn">pipeline</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define 3 Nodes for our pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes by using simples registers</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s define a few Payload things that can go through the pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">RESULT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind io.up to n0</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n0</span><span class="p">.</span><span class="n">ready</span>
<span class="w">  </span><span class="n">n0</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">valid</span>
<span class="w">  </span><span class="n">n0</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span>

<span class="w">  </span><span class="c1">// Let&#39;s do some processing on n1</span>
<span class="w">  </span><span class="n">n1</span><span class="p">(</span><span class="nc">RESULT</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x1200</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind n2 to io.down</span>
<span class="w">  </span><span class="n">n2</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">ready</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n2</span><span class="p">.</span><span class="n">valid</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n2</span><span class="p">(</span><span class="nc">RESULT</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">s01</span><span class="p">,</span><span class="w"> </span><span class="n">s12</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这将产生以下硬件：</p>
<a class="reference internal image-reference" href="../../../_images/simple_pip.png"><img alt="../../../_images/simple_pip.png" src="../../../_images/simple_pip.png" style="width: 232.39999999999998px; height: 336.0px;" /></a>
<p>下面是一个仿真波形：</p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{signal: [
  {name: 'clk', wave: '0...p........'},
  {name: 'reset', wave: '1..0.........'},
  {name: 'io_up_valid', wave: '0.....10.....'},
  {},
  {name: 'n0_valid', wave: '0.....10.....'},
  {name: 'n0_VALUE', wave: 'x.....2......', data: ['0042']},
  {},
  {name: 'n1_valid', wave: '0......10....'},
  {name: 'n1_VALUE', wave: 'x......2.....', data: ['0042']},
  {name: 'n1_RESULT', wave: 'x......2.....', data: ['1242']},
  {},
  {name: 'n2_valid', wave: '0.......10...'},
  {name: 'n2_RESULT', wave: 'x.......2....', data: ['1242']},
  {},
  {name: 'io_down_valid', wave: '0.......10...'},
]}
</script>
</div>
<p>下面是相同的示例，但使用了更多的API：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">misc</span><span class="p">.</span><span class="nn">pipeline</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w">  </span><span class="c1">//VALUE can also be used as a HardType</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// NodesBuilder will be used to register all the nodes created, connect them via stages and generate the hardware</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">NodesBuilder</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// Let&#39;s define a Node which connect from io.up</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateFrom</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">    </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define a Node which do some processing</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">RESULT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x1200</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//  Let&#39;s define a Node which connect to io.down</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateTo</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">)</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">.</span><span class="nc">RESULT</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes by using registers stages and generate the related hardware</span>
<span class="w">  </span><span class="n">builder</span><span class="p">.</span><span class="n">genStagedPipeline</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="payload">
<h1>Payload<a class="headerlink" href="#payload" title="此标题的永久链接"></a></h1>
<p>Payload对象用于引用可以通过流水线的数据。从技术上讲，Payload是一个HardType，它有一个名字，并被用作在流水线某个级中检索信号的“键”。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PC_PLUS_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>

<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">n1</span><span class="p">(</span><span class="nc">PC_PLUS_4</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span>
</pre></div>
</div>
<p>请注意，我习惯于使用大写对Payload实例命名。这是为了让它非常明确，这不是一个硬件信号，更像是一个“键/类型”访问的东西。</p>
</section>
<section id="node">
<h1>Node<a class="headerlink" href="#node" title="此标题的永久链接"></a></h1>
<p>Node主要托管有效/就绪仲裁信号，以及所有通过它的硬件信号所需的Payload。</p>
<p>您可以通过以下方式访问其仲裁器：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 8%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>访问</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>node.valid</p></td>
<td><p>RW</p></td>
<td><p>指定节点上是否存在事务的信号。它是由上游逻辑驱动的。一旦置为1，则它必须且仅能在valid和ready同时置位或node.cancel为高的周期后解除置位。valid不依赖于ready。</p></td>
</tr>
<tr class="row-odd"><td><p>node.ready</p></td>
<td><p>RW</p></td>
<td><p>指定节点的事务是否可以向下游进行的信号。它是由下游驱动以创建反压。当没有事务（node.valid被置0）时，该信号无意义</p></td>
</tr>
<tr class="row-even"><td><p>node.cancel</p></td>
<td><p>RW</p></td>
<td><p>指定节点的事务是否正在从流水线中取消的信号。它由下游驱动。当没有事务时（node.valid被置0），该信号没有意义</p></td>
</tr>
<tr class="row-odd"><td><p>node.isValid</p></td>
<td><p>RO</p></td>
<td><p>node.valid的只读访问器</p></td>
</tr>
<tr class="row-even"><td><p>node.isReady</p></td>
<td><p>RO</p></td>
<td><p>node.ready的只读访问器</p></td>
</tr>
<tr class="row-odd"><td><p>node.isCancel</p></td>
<td><p>RO</p></td>
<td><p>node.cancel的只读访问器</p></td>
</tr>
<tr class="row-even"><td><p>node.isFiring</p></td>
<td><p>RO</p></td>
<td><p>当节点事务成功继续进行时为True（valid &amp;&amp; ready &amp;&amp; !cancel）。用于提交状态更改。</p></td>
</tr>
<tr class="row-odd"><td><p>node.isMoving</p></td>
<td><p>RO</p></td>
<td><p>当节点事务将不再存在于节点上时（从下一周期开始）为True，要么是因为下游准备好接收事务，要么是因为事务已从流水线中取消。（valid &amp;&amp; (ready || cancel)）用于“复位”(reset)状态。</p></td>
</tr>
<tr class="row-even"><td><p>node.isCanceling</p></td>
<td><p>RO</p></td>
<td><p>当节点事务正在被取消时为True。这意味着在将来的周期中它不会出现在流水线中的任何地方。</p></td>
</tr>
</tbody>
</table>
<p>请注意，node.valid/node.ready信号遵循与 <a class="reference internal" href="../stream.html"><span class="doc">Stream</span></a> 中相同的规范。</p>
<p>Node的控制信号（valid/ready/cancel）和状态信号（isValid、isReady、isCancel、isFiring等）是按需创建的。因此，例如，您可以通过永远不引用ready信号来创建没有反压的流水线。这就是在想要读取某物的状态时使用状态信号，仅在想要驱动某物时使用控制信号的重要性所在。</p>
<p>以下是节点上可能出现的仲裁情况列表。valid/ready/cancel定义了我们所处的状态，而isFiring/isMoving是这些状态的结果：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>valid</p></th>
<th class="head"><p>ready</p></th>
<th class="head"><p>cancel</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>isFiring</p></th>
<th class="head"><p>isMoving</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>无事务</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>正在进行</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>阻塞</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>X</p></td>
<td><p>1</p></td>
<td><p>取消</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>请注意，如果您想要建模诸如CPU级可能的阻塞和刷新的情况，可以查看 CtrlLink，因为它提供了执行此类操作的 API。</p>
<p>您可以通过以下方式访问由Payload引用的信号：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>node(Payload)</p></td>
<td><p>返回对应的硬件信号</p></td>
</tr>
<tr class="row-odd"><td><p>node(Payload, Any)</p></td>
<td><p>与上述相同，但包括一个用作“次要键”的第二个参数。这有助于构建多通道硬件。例如，当您有一个多发射CPU流水线时，您可以使用通道Int id作为次要键</p></td>
</tr>
<tr class="row-even"><td><p>node.insert(Data)</p></td>
<td><p>返回一个新的Payload实例，该实例连接到给定的Data硬件信号</p></td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">n0</span><span class="p">(</span><span class="nc">PC</span><span class="p">,</span><span class="w"> </span><span class="mh">0x666</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0xEE</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">SOMETHING</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n0</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">myHardwareSignal</span><span class="p">)</span><span class="w"> </span><span class="c1">//This create a new Payload</span>
<span class="n">when</span><span class="p">(</span><span class="n">n1</span><span class="p">(</span><span class="nc">SOMETHING</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0xFFAA</span><span class="p">){</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>虽然您可以手动驱动/读取流水线的第一个/最后一级的仲裁/数据，但有一些实用工具可以连接其边界。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>node.arbitrateFrom(Stream[T]])</p></td>
<td><p>由反压流驱动节点仲裁。</p></td>
</tr>
<tr class="row-odd"><td><p>node.arbitrateFrom(Flow[T]])</p></td>
<td><p>由数据流驱动节点仲裁。</p></td>
</tr>
<tr class="row-even"><td><p>node.arbitrateTo(Stream[T]])</p></td>
<td><p>由节点驱动反压流仲裁。</p></td>
</tr>
<tr class="row-odd"><td><p>node.arbitrateTo(Flow[T]])</p></td>
<td><p>由节点驱动数据流仲裁。</p></td>
</tr>
<tr class="row-even"><td><p>node.driveFrom(Stream[T]])((Node, T) =&gt; Unit)</p></td>
<td><p>由反压流驱动节点。提供的lambda函数可以用于连接数据</p></td>
</tr>
<tr class="row-odd"><td><p>node.driveFrom(Flow[T]])((Node, T) =&gt; Unit)</p></td>
<td><p>与上述类似，但适用于Flow</p></td>
</tr>
<tr class="row-even"><td><p>node.driveTo(Stream[T]])((T, Node) =&gt; Unit)</p></td>
<td><p>由节点驱动反压流。提供的lambda函数可以用于连接数据</p></td>
</tr>
<tr class="row-odd"><td><p>node.driveTo(Flow[T]])((T, Node) =&gt; Unit)</p></td>
<td><p>与上述类似，但适用于Flow</p></td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">IN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">OUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="n">n1</span><span class="p">(</span><span class="nc">OUT</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n1</span><span class="p">(</span><span class="nc">IN</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x42</span>

<span class="c1">// Define the input / output stream that will be later connected to the pipeline</span>
<span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="c1">//Note master Stream(OUT) is good aswell</span>

<span class="n">n0</span><span class="p">.</span><span class="n">driveFrom</span><span class="p">(</span><span class="n">up</span><span class="p">)((</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">self</span><span class="p">(</span><span class="nc">IN</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span>
<span class="n">n2</span><span class="p">.</span><span class="n">driveTo</span><span class="p">(</span><span class="n">down</span><span class="p">)((</span><span class="n">payload</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">self</span><span class="p">(</span><span class="nc">OUT</span><span class="p">))</span>
</pre></div>
</div>
<p>为了减少冗长，在Payload与其数据表示之间有一组隐式转换，可在Node下使用：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Node</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PLUS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// VALUE is implicitly converted into its n1(VALUE) representation</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您还可以通过导入它们来使用这些隐式转换：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="n">n1Stuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="nn">n1</span><span class="p">.</span><span class="n">_</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PLUS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Equivalent to n1.insert(n1(VALUE)) + 1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>还有一个API，它允许你创建新的Area，这个Area提供了给定节点实例的全部API（包括隐式转换），而无需导入：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="kd">val</span><span class="w"> </span><span class="n">n1Stuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">n1</span><span class="p">.</span><span class="nc">Area</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PLUS_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="nc">VALUE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// Equivalent to n1.insert(n1(VALUE)) + 1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当硬件具有可参数化的流水线位置时，这样的功能非常有用（请参阅重定时示例）。</p>
</section>
<section id="links">
<h1>Links<a class="headerlink" href="#links" title="此标题的永久链接"></a></h1>
<p>目前已经实现了一些不同的Links（但您也可以创建自己的自定义Links）。Links的思想是以各种方式将两个节点连接在一起，它们通常有一个 <cite>up</cite> 节点和一个 <cite>down</cite> 节点。</p>
<section id="directlink">
<h2>DirectLink<a class="headerlink" href="#directlink" title="此标题的永久链接"></a></h2>
<p>非常简单，它只使用导线连接两个节点。以下是一个示例：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">DirectLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="stagelink">
<h2>StageLink<a class="headerlink" href="#stagelink" title="此标题的永久链接"></a></h2>
<p>这使用data/valid信号上的寄存器和ready信号上的一些仲裁连接了两个节点。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="s2mlink">
<h2>S2mLink<a class="headerlink" href="#s2mlink" title="此标题的永久链接"></a></h2>
<p>这使用ready信号上的寄存器连接两个节点，这对于改进反压组合时序非常有用。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">S2mLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="ctrllink">
<h2>CtrlLink<a class="headerlink" href="#ctrllink" title="此标题的永久链接"></a></h2>
<p>这是一种特殊的 Link，用于连接两个节点，具有可选的流量控制/旁路逻辑。它的应用程序接口应该足够灵活，可以用它来实现 CPU 流水级。</p>
<p>以下是其流量控制 API（Bool 参数启用了相关功能）：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>haltWhen(Bool)</p></td>
<td><p>允许阻止当前传输事务（清除 up.ready down.valid）</p></td>
</tr>
<tr class="row-odd"><td><p>throwWhen(Bool)</p></td>
<td><p>允许从流水线中取消当前事务（清除 down.valid，使事务驱动逻辑忘记其当前状态）</p></td>
</tr>
<tr class="row-even"><td><p>forgetOneWhen(Bool)</p></td>
<td><p>允许请求上游节点忘记其当前事务（但不会清除 down.valid）</p></td>
</tr>
<tr class="row-odd"><td><p>ignoreReadyWhen(Bool)</p></td>
<td><p>允许忽略下游节点ready（设置 up.ready 为1）</p></td>
</tr>
<tr class="row-even"><td><p>duplicateWhen(Bool)</p></td>
<td><p>允许复制当前传输事务（清零 up.ready）</p></td>
</tr>
<tr class="row-odd"><td><p>terminateWhen(Bool)</p></td>
<td><p>允许下游节点隐藏当前传输事务（清零 down.valid）</p></td>
</tr>
</tbody>
</table>
<p>还要注意的是，如果要在条件作用域（例如在 when 语句中）进行通信流控制，可以调用以下函数 ：</p>
<ul class="simple">
<li><p>haltIt(), duplicateIt(), terminateIt(), forgetOneNow(), ignoreReadyNow(), throwIt()</p></li>
</ul>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>

<span class="n">c01</span><span class="p">.</span><span class="n">haltWhen</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"> </span><span class="c1">// Explicit halt request</span>

<span class="n">when</span><span class="p">(</span><span class="n">somethingElse</span><span class="p">){</span>
<span class="w">    </span><span class="n">c01</span><span class="p">.</span><span class="n">haltIt</span><span class="p">()</span><span class="w"> </span><span class="c1">// Conditional scope sensitive halt request, same as c01.haltWhen(somethingElse)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>您可以使用 node.up / node.down 查看哪些节点连接到了链接。</p>
<p>CtrlLink 还提供了访问Payload的 API：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>link(Payload)</p></td>
<td><p>与 Link.down(Payload) 相同</p></td>
</tr>
<tr class="row-odd"><td><p>link(Payload, Any)</p></td>
<td><p>与 Link.down(Payload, Any) 相同</p></td>
</tr>
<tr class="row-even"><td><p>link.insert(Data)</p></td>
<td><p>与 Link.down.insert(Data) 相同</p></td>
</tr>
<tr class="row-odd"><td><p>link.bypass(Payload)</p></td>
<td><p>允许在 link.up -&gt; link.down 之间有条件地覆盖 Payload 值。例如，这可用于修复 CPU 流水线中的数据冲突。</p></td>
</tr>
</tbody>
</table>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">c01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="n">c01</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x42</span>
<span class="n">c01</span><span class="p">(</span><span class="nc">PC</span><span class="p">,</span><span class="w"> </span><span class="mh">0x666</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0xEE</span>

<span class="kd">val</span><span class="w"> </span><span class="nc">DATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="c1">// Let&#39;s say Data is inserted in the pipeline before c01</span>
<span class="n">when</span><span class="p">(</span><span class="n">hazard</span><span class="p">){</span>
<span class="w">    </span><span class="n">c01</span><span class="p">.</span><span class="n">bypass</span><span class="p">(</span><span class="nc">DATA</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fixedValue</span>
<span class="p">}</span>

<span class="c1">// c01(DATA) and below will get the hazard patch</span>
</pre></div>
</div>
<p>请注意，如果创建的 CtrlLink 不带节点参数，它将在内部创建自己的节点。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">decode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">()</span>
<span class="kd">val</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">()</span>

<span class="kd">val</span><span class="w"> </span><span class="n">d2e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">decode</span><span class="p">.</span><span class="n">down</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="other-links">
<h2>其他链接<a class="headerlink" href="#other-links" title="此标题的永久链接"></a></h2>
<p>此外，还实现了 JoinLink / ForkLink。</p>
</section>
<section id="your-custom-link">
<h2>您的自定义链接<a class="headerlink" href="#your-custom-link" title="此标题的永久链接"></a></h2>
<p>您可以通过实现 Link 基类来实现自定义链接。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">Link</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="p">{</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">ups</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Node</span><span class="p">]</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">downs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Seq</span><span class="p">[</span><span class="nc">Node</span><span class="p">]</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">propagateDown</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">propagateUp</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span>
<span class="p">}</span>
</pre></div>
</div>
<p>不过，由于 API 还很新，后面可能会有一些变化。</p>
</section>
</section>
<section id="builder">
<h1>Builder<a class="headerlink" href="#builder" title="此标题的永久链接"></a></h1>
<p>要生成流水线硬件，您需要提供流水线中使用的所有链接列表。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Let&#39;s define 3 Nodes for our pipeline</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="c1">// Let&#39;s connect those nodes by using simples registers</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">s12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="nc">Builder</span><span class="p">(</span><span class="n">s01</span><span class="p">,</span><span class="w"> </span><span class="n">s12</span><span class="p">)</span>
</pre></div>
</div>
<p>此外，还有一套 “一体化 “的构建工具，您可以利用它来帮助你自己。</p>
<p>例如，有一个 NodesBuilder 类，可用于创建按顺序分级的流水线：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">NodesBuilder</span><span class="p">()</span>

<span class="c1">// Let&#39;s define a few nodes</span>
<span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="nc">Node</span>

<span class="c1">// Let&#39;s connect those nodes by using registers and generate the related hardware</span>
<span class="n">builder</span><span class="p">.</span><span class="n">genStagedPipeline</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="composability">
<h1>组合能力（Composability）<a class="headerlink" href="#composability" title="此标题的永久链接"></a></h1>
<p>该API的一个优点是，它可以轻松地将多个并行事物组成一个流水线。这里的 “组成 “是指有时你设计的流水线需要进行并行处理。</p>
<p>试想一下，如果您需要对 4 对数字进行浮点乘法运算（稍后求和）。并且这 4 对数字是由一个数据流同时提供的，那么就不需要 4 条不同的流水线来进行乘法运算，而需要在同一条流水线上并行处理。</p>
<p>下面的示例展示了一种模式，它将多个通道组成一个流水线，来并行处理它们。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// This area allows to take a input value and do +1 +1 +1 over 3 stages.</span>
<span class="c1">// I know that&#39;s useless, but let&#39;s pretend that instead it does a multiplication between two numbers over 3 stages (for FMax reasons)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Plus3</span><span class="p">(</span><span class="nc">INPUT</span><span class="p">:</span><span class="w"> </span><span class="nc">Payload</span><span class="p">[</span><span class="nc">UInt</span><span class="p">],</span><span class="w"> </span><span class="n">stage1</span><span class="p">:</span><span class="w"> </span><span class="nc">Node</span><span class="p">,</span><span class="w"> </span><span class="n">stage2</span><span class="p">:</span><span class="w"> </span><span class="nc">Node</span><span class="p">,</span><span class="w"> </span><span class="n">stage3</span><span class="p">:</span><span class="w"> </span><span class="nc">Node</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stage1</span><span class="p">(</span><span class="nc">INPUT</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">TWO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stage2</span><span class="p">(</span><span class="nc">ONE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">THREE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage3</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stage3</span><span class="p">(</span><span class="nc">TWO</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Let&#39;s define a component which takes a stream as input,</span>
<span class="c1">// which carries &#39;lanesCount&#39; values that we want to process in parallel</span>
<span class="c1">// and put the result on an output stream</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">(</span><span class="n">lanesCount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">lanesCount</span><span class="p">)(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">lanesCount</span><span class="p">)(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define 3 Nodes for our pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Node</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes by using simples registers</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">s12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind io.up to n0</span>
<span class="w">  </span><span class="n">n0</span><span class="p">.</span><span class="n">arbitrateFrom</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">LANES_INPUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">n0</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>

<span class="w">  </span><span class="c1">// Let&#39;s use our &quot;reusable&quot; Plus3 area to generate each processing lane</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">lanes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">lanesCount</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Plus3</span><span class="p">(</span><span class="nc">LANES_INPUT</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">n0</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s bind n2 to io.down</span>
<span class="w">  </span><span class="n">n2</span><span class="p">.</span><span class="n">arbitrateTo</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">lanesCount</span><span class="p">)</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">n2</span><span class="p">(</span><span class="n">lanes</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="nc">THREE</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">s01</span><span class="p">,</span><span class="w"> </span><span class="n">s12</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这将产生以下数据路径（假设 lanesCount = 2），仲裁器没有显示：</p>
<a class="reference internal image-reference" href="../../../_images/composable_lanes.png"><img alt="../../../_images/composable_lanes.png" src="../../../_images/composable_lanes.png" style="width: 406.0px; height: 630.0px;" /></a>
</section>
<section id="retiming-variable-lenth">
<h1>重定时/可变长度<a class="headerlink" href="#retiming-variable-lenth" title="此标题的永久链接"></a></h1>
<p>有时，你想设计一个流水线，但你并不真正知道关键路径在哪里，也不知道各阶段之间如何平衡。而且通常情况下，你无法依赖综合工具做好自动重定时工作。</p>
<p>因此，你需要一种简单的方法来构建流水线逻辑。</p>
<p>下面介绍如何使用此流水线 API：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define a component which will take a input stream of RGB value</span>
<span class="c1">// Process (~(R + G + B)) * 0xEE</span>
<span class="c1">// And provide that result into an output stream</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span><span class="n">addAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span>
<span class="w">                     </span><span class="n">invAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span>
<span class="w">                     </span><span class="n">mulAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span>
<span class="w">                     </span><span class="n">resultAt</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="n">spinal</span><span class="p">.</span><span class="n">lib</span><span class="p">.</span><span class="n">graphic</span><span class="p">.</span><span class="nc">Rgb</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s define the Nodes for our pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Array</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">resultAt</span><span class="o">+</span><span class="mi">1</span><span class="p">)(</span><span class="nc">Node</span><span class="p">())</span>

<span class="w">  </span><span class="c1">// Let&#39;s specify which node will be used for what part of the pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">insertNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">addNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">addAt</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">invNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">invAt</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">mulNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">mulAt</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">resultNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">resultAt</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Define the hardware which will feed the io.up stream into the pipeline</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">inserter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">insertNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateFrom</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">RGB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">payload</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// sum the r g b values of the color</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">addNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">inserter</span><span class="p">.</span><span class="nc">RGB</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inserter</span><span class="p">.</span><span class="nc">RGB</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inserter</span><span class="p">.</span><span class="nc">RGB</span><span class="p">.</span><span class="n">b</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// flip all the bit of the RGB sum</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">inverter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">invNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">INV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="o">~</span><span class="n">adder</span><span class="p">.</span><span class="nc">SUM</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// multiply the inverted bits with 0xEE</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">mulNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">MUL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">inverter</span><span class="p">.</span><span class="nc">INV</span><span class="o">*</span><span class="mh">0xEE</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Connect the end of the pipeline to the io.down stream</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">resulter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">resultNode</span><span class="p">.</span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arbitrateTo</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">)</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">multiplier</span><span class="p">.</span><span class="nc">MUL</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Let&#39;s connect those nodes sequencialy by using simples registers</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">links</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">resultAt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">nodes</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">  </span><span class="c1">// Let&#39;s ask the builder to generate all the required hardware</span>
<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果像这样生成该组件：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span>
<span class="w">    </span><span class="n">addAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">invAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">mulAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">resultAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>您将获得由 3 层寄存器（flip flop）分隔的 4 个处理阶段：</p>
<a class="reference internal image-reference" href="../../../_images/rgbToSomething.png"><img alt="../../../_images/rgbToSomething.png" src="../../../_images/rgbToSomething.png" style="width: 114.8px; height: 392.0px;" /></a>
<p>请注意，生成的硬件 verilog 还算干净（至少按我的标准来说是这样 :P）：</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL dev    git head : 1259510dd72697a4f2c388ad22b269d4d2600df7</span>
<span class="c1">// Component : RgbToSomething</span>
<span class="c1">// Git hash  : 63da021a1cd082d22124888dd6c1e5017d4a37b2</span>

<span class="no">`timescale</span><span class="w"> </span><span class="mh">1</span><span class="n">ns</span><span class="o">/</span><span class="mh">1</span><span class="n">ps</span>

<span class="k">module</span><span class="w"> </span><span class="n">RgbToSomething</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_up_valid</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_up_ready</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_up_payload_r</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_up_payload_g</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_up_payload_b</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_down_valid</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">io_down_ready</span><span class="p">,</span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_down_payload</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">clk</span><span class="p">,</span>
<span class="w">  </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">          </span><span class="n">reset</span>
<span class="p">);</span>

<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_nodes_0_adder_SUM</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">nodes_3_multiplier_MUL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">nodes_2_multiplier_MUL</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_2_inverter_INV</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_1_inverter_INV</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_1_adder_SUM</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_adder_SUM</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_inserter_RGB_r</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_inserter_RGB_g</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">nodes_0_inserter_RGB_b</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">nodes_0_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_0_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_1_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_1_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_2_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_2_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">nodes_3_valid</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">nodes_3_ready</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StageLink_l56</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StageLink_l56_1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StageLink_l56_2</span><span class="p">;</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_nodes_0_adder_SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">nodes_0_inserter_RGB_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_g</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_valid</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_up_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_0_ready</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_payload_r</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_payload_g</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_up_payload_b</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_0_adder_SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_nodes_0_adder_SUM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nodes_0_inserter_RGB_b</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_1_inverter_INV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="w"> </span><span class="n">nodes_1_adder_SUM</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_2_multiplier_MUL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">nodes_2_inverter_INV</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;hee</span><span class="p">);</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_down_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_3_valid</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">nodes_3_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_down_ready</span><span class="p">;</span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_down_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_3_multiplier_MUL</span><span class="p">;</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">nodes_0_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_1_ready</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StageLink_l56</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_0_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StageLink_l56</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">nodes_1_valid</span><span class="p">);</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">nodes_1_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_2_ready</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StageLink_l56_1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_1_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StageLink_l56_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">nodes_2_valid</span><span class="p">);</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">nodes_2_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes_3_ready</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StageLink_l56_2</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_2_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StageLink_l56_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">nodes_3_valid</span><span class="p">);</span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_1_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">      </span><span class="n">nodes_2_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">      </span><span class="n">nodes_3_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_0_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">nodes_1_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_0_valid</span><span class="p">;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_1_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">nodes_2_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_1_valid</span><span class="p">;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_2_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">nodes_3_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_2_valid</span><span class="p">;</span>
<span class="w">      </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_0_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_1_adder_SUM</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_0_adder_SUM</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_1_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_2_inverter_INV</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_1_inverter_INV</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nodes_2_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">      </span><span class="n">nodes_3_multiplier_MUL</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nodes_2_multiplier_MUL</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>


<span class="k">endmodule</span>
</pre></div>
</div>
<p>此外，您还可以轻松调整处理的级数和位置，例如，您可能希望将翻转的硬件逻辑移到与加法器相同级上。具体方法如下：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span>
<span class="w">    </span><span class="n">addAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">invAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">mulAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">resultAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>那么您可能需要移除输出寄存器级：</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nc">RgbToSomething</span><span class="p">(</span>
<span class="w">    </span><span class="n">addAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">invAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">mulAt</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">resultAt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="simple-cpu-example">
<h1>简单的CPU示例<a class="headerlink" href="#simple-cpu-example" title="此标题的永久链接"></a></h1>
<p>下面是一个简单的 8 位 CPU 示例：</p>
<ul class="simple">
<li><p>三级流水线（fetch, decode, execute）</p></li>
<li><p>嵌入的获取存储器</p></li>
<li><p>add / jump / led /delay 指令</p></li>
</ul>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Cpu</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fetch</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CtrlLink</span><span class="p">()</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">f2d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">fetch</span><span class="p">.</span><span class="n">down</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">d2e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StageLink</span><span class="p">(</span><span class="n">decode</span><span class="p">.</span><span class="n">down</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">INSTRUCTION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Payload</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">led</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fetcher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">fetch</span><span class="p">.</span><span class="nc">Area</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pcReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">up</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pcReg</span>
<span class="w">    </span><span class="n">up</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">up</span><span class="p">.</span><span class="n">isFiring</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">pcReg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">PC</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">256</span><span class="p">)(</span><span class="nc">INSTRUCTION</span><span class="p">).</span><span class="n">simPublic</span>
<span class="w">    </span><span class="nc">INSTRUCTION</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="p">.</span><span class="n">readAsync</span><span class="p">(</span><span class="nc">PC</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">decoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">decode</span><span class="p">.</span><span class="nc">Area</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_ADD</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x1</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_JUMP</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x2</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_LED</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x3</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IS_DELAY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">opcode</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mh">0x4</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">alu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">execute</span><span class="p">.</span><span class="nc">Area</span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">stage</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="n">fetch</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">stage</span><span class="p">.</span><span class="n">throwWhen</span><span class="p">(</span><span class="n">flush</span><span class="p">,</span><span class="w"> </span><span class="n">usingReady</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">isValid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_ADD</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">regfile</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">regfile</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_JUMP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">flush</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span>
<span class="w">        </span><span class="n">fetcher</span><span class="p">.</span><span class="n">pcReg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_LED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">led</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="n">regfile</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">decoder</span><span class="p">.</span><span class="nc">IS_DELAY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">delayCounter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="nc">INSTRUCTION</span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">delayCounter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">execute</span><span class="p">.</span><span class="n">haltIt</span><span class="p">()</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nc">Builder</span><span class="p">(</span><span class="n">fetch</span><span class="p">,</span><span class="w"> </span><span class="n">decode</span><span class="p">,</span><span class="w"> </span><span class="n">execute</span><span class="p">,</span><span class="w"> </span><span class="n">f2d</span><span class="p">,</span><span class="w"> </span><span class="n">d2e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是一个简单的测试平台，它实现了一个循环，使 led 计数值上升。</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withFstWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Cpu</span><span class="p">).</span><span class="n">doSim</span><span class="p">(</span><span class="n">seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">){</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">nop</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">jump</span><span class="p">(</span><span class="n">target</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">led</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">delay</span><span class="p">(</span><span class="n">cycles</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">cycles</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">fetcher</span><span class="p">.</span><span class="n">mem</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">nop</span><span class="p">())</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">nop</span><span class="p">())</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mh">0x1</span><span class="p">))</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">led</span><span class="p">())</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">delay</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">setBigInt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">jump</span><span class="p">(</span><span class="mh">0x2</span><span class="p">))</span>

<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="index.html" class="btn btn-neutral float-left" title="Pipeline" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../Misc/index.html" class="btn btn-neutral float-right" title="杂项" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2018 - 2024, SpinalHDL.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
  
     
    <!-- source/_templates/footer.html -->


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>