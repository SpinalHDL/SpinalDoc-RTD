==========
Simulation
==========

.. toctree::
   :hidden:
   :glob:
   
   install/index
   bootstraps
   signal
   clock
   threadFull
   threadLess
   engine
   examples/index

.. role:: raw-html-m2r(raw)
   :format: html


Introduction
------------

As always, you can use your standard simulation tools to simulate the VHDL/Verilog generated by SpinalHDL. However, since SpinalHDL 1.0.0, the language integrates an API to write testbenches and test your hardware directly in Scala. This API provides the capabilities to read and write the DUT signals, fork and join simulation processes, sleep and wait until a given condition is reached. Therefore, using SpinalHDL's simulation API, it is easy to integrate testbenches with the most common Scala unit-test frameworks.

To be able to simulate user-defined components, SpinalHDL uses external HDL simulators as backend. Currently, three simulators are supported:

- `Verilator <https://www.veripool.org/wiki/verilator>`_
- `GHDL <http://ghdl.free.fr/>`_ **(experimental, since SpinalHDL 1.4.1)**
- `Icarus Verilog <http://iverilog.icarus.com/>`_ **(experimental, since SpinalHDL 1.4.1)**

With external HDL simulators it is possible to directly test the generated HDL sources without increasing the SpinalHDL codebase complexity. 

How SpinalHDL simulates the hardware with Verilator backend
-----------------------------------------------------------

1. Behind the scenes, SpinalHDL generates a Verilog equivalent hardware model of the DUT and then uses Verilator to convert it to a C++ cycle-accurate model. 
2. The C++ model is compiled into a shared object (.so), which is bound to Scala via JNR-FFI. 
3. The native Verilator API is abstracted by providing a simulation multi-threaded API.

**Advantages:**

* Since the Verilator backend uses a compiled C++ simulation model, the simulation speed is fast compared to most of the other commercial and free simulators.

**Limitations:**

* Verilator accepts only synthesizable Verilog/System Verilog code. Therefore special care has to be taken when simulating Verilog blackbox components that may have non-synthesizable statements.
* VHDL blackboxes cannot be simulated.
* The simulation boot process is slow due to the necessity to compile and link the generated C++ model

How SpinalHDL simulates the hardware with GHDL/Icarus Verilog backend
---------------------------------------------------------------------

1. Depending on the chosen simulator, SpinalHDL generates a Verilog or VHDL hardware model of the DUT. 
2. The HDL model is loaded in the simulator. 
3. The communication between the simulation and the JVM is established through shared memory. The commands are issued to the simulator using `VPI <https://en.wikipedia.org/wiki/Verilog_Procedural_Interface>`_.

**Advantages:**

* Both GHDL and Icarus Verilog can accept non-synthesizable HDL code.
* The simulation boot process is quite faster compared to Verilator.

**Limitations:**

* GHDL accepts VHDL code only. Therefore only VHDL blackboxes can be used with this simulator.
* Icarus Verilog accepts Verilog code only. Therefore only Verilog blackboxes can be used with this simulator.
* The simulation speed is around one order of magnitude slower compared to Verilator.



Performance
-----------

When a high-performance simulation is required, Verilator should be used as a backend. On a little SoC like `Murax <https://github.com/SpinalHDL/VexRiscv>`_, an Intel® Core™ i7-4720HQ is capable of simulating 1.2 million clock cycles per second. However, when the DUT is simple and a maximum of few thousands clock cycles have to be simulated, using GHDL or Icarus Verilog could yield a better result, due to their lower simulation loading overhead.

