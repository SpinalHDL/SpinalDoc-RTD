
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-02 00:23+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=UTF-8"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../SpinalHDL/Simulation/simulator_specifics.rst:3
msgid "Simulator specific details"
msgstr "模拟器具体细节"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:6
msgid "How SpinalHDL simulates the hardware with Verilator backend"
msgstr "SpinalHDL 如何使用 Verilator 后端模拟硬件"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:8
msgid ""
"Behind the scenes, SpinalHDL generates a Verilog equivalent hardware model "
"of the DUT and then uses Verilator to convert it to a C++ cycle-accurate "
"model."
msgstr "SpinalHDL 在后台生成 DUT 的 Verilog 等效硬件模型，然后使用 Verilator 将其转换为 C++ 周期精确模型。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:9
msgid ""
"The C++ model is compiled into a shared object (.so), which is bound to "
"Scala via JNI-FFI."
msgstr "C++ 模型被编译为共享对象 (.so)，该对象通过 JNI-FFI 绑定到 Scala。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:10
msgid ""
"The native Verilator API is abstracted by providing a simulation multi-"
"threaded API."
msgstr "通过提供模拟多线程API来抽象本机Verilator API。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:12
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:29
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:49
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:69
msgid "**Advantages:**"
msgstr "**优点：**"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:14
msgid ""
"Since the Verilator backend uses a compiled C++ simulation model, the "
"simulation speed is fast compared to most of the other commercial and free "
"simulators."
msgstr "由于Verilator后端使用编译的C++仿真模型，因此与大多数其他商业和免费模拟器相比，仿真速度很快。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:16
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:34
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:56
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:73
msgid "**Limitations:**"
msgstr "**限制：**"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:18
msgid ""
"Verilator accepts only synthesizable Verilog/System Verilog code. Therefore "
"special care has to be taken when simulating Verilog blackbox components "
"that may have non-synthesizable statements."
msgstr ""
"Verilator 仅接受可综合的 Verilog/System Verilog 代码。因此，在模拟可能具有不可综合语句的 Verilog "
"黑盒组件时必须特别小心。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:19
msgid "VHDL blackboxes cannot be simulated."
msgstr "VHDL 黑盒无法模拟。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:20
msgid ""
"The simulation boot process is slow due to the necessity to compile and link"
" the generated C++ model.  Some support to incrementally compile and link "
"exists which can provide speedups for subsequent simulations after building "
"the first."
msgstr "由于需要编译和链接生成的 C++ 模型，模拟启动过程很慢。存在对增量编译和链接的一些支持，这可以在构建第一个模拟后为后续模拟提供加速。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:23
msgid "How SpinalHDL simulates the hardware with GHDL/Icarus Verilog backend"
msgstr "SpinalHDL 如何使用 GHDL/Icarus Verilog 后端模拟硬件"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:25
msgid ""
"Depending on the chosen simulator, SpinalHDL generates a Verilog or VHDL "
"hardware model of the DUT."
msgstr "根据所选模拟器，SpinalHDL 生成 DUT 的 Verilog 或 VHDL 硬件模型。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:26
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:46
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:66
msgid "The HDL model is loaded in the simulator."
msgstr "HDL 模型已加载到模拟器中。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:27
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:47
msgid ""
"The communication between the simulation and the JVM is established through "
"shared memory. The commands are issued to the simulator using `VPI "
"<https://en.wikipedia.org/wiki/Verilog_Procedural_Interface>`_."
msgstr ""
"模拟和JVM之间的通信是通过共享内存建立的。使用“VPI "
"<https://en.wikipedia.org/wiki/Verilog_Procedural_Interface>”向模拟器发出命令。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:31
msgid "Both GHDL and Icarus Verilog can accept non-synthesizable HDL code."
msgstr "GHDL 和 Icarus Verilog 都可以接受不可综合的 HDL 代码。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:32
msgid "The simulation boot process is quite faster compared to Verilator."
msgstr "与 Verilator 相比，模拟启动过程要快得多。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:36
msgid ""
"GHDL accepts VHDL code only. Therefore only VHDL blackboxes can be used with"
" this simulator."
msgstr "GHDL 仅接受 VHDL 代码。因此，该模拟器只能使用 VHDL 黑盒。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:37
msgid ""
"Icarus Verilog accepts Verilog code only. Therefore only Verilog blackboxes "
"can be used with this simulator."
msgstr "Icarus Verilog 仅接受 Verilog 代码。因此，该模拟器只能使用 Verilog 黑盒。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:38
msgid ""
"The simulation speed is around one order of magnitude slower compared to "
"Verilator."
msgstr "与 Verilator 相比，仿真速度大约慢一个数量级。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:40
msgid ""
"Finally, as the native Verilator API is rather crude, SpinalHDL abstracts "
"over it by providing both single and multi-threaded simulation APIs to help "
"the user construct testbench implementations."
msgstr ""
"最后，由于原生 Verilator API 相当粗糙，SpinalHDL 通过提供单线程和多线程模拟 API 对其进行抽象，以帮助用户构建测试平台实现。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:43
msgid "How SpinalHDL simulates the hardware with Synopsys VCS backend"
msgstr "SpinalHDL 如何使用 Synopsys VCS 后端模拟硬件"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:45
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:65
msgid ""
"SpinalHDL generates a Verilog/VHDL (depended on your choice) hardware model "
"of the DUT."
msgstr "SpinalHDL 生成 DUT 的 Verilog/VHDL（取决于您的选择）硬件模型。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:51
msgid "Support all language features of SystemVerilog/Verilog/VHDL."
msgstr "支持SystemVerilog/Verilog/VHDL的所有语言特性。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:52
msgid "Support encrypted IP."
msgstr "支持加密IP。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:53
msgid "Support FSDB wave format dump."
msgstr "支持 FSDB 波形格式转储。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:54
msgid "High Performance of both compilation and simulation."
msgstr "编译和模拟的高性能。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:58
msgid ""
"Synopsys VCS is a **commercial** simulation tool. It is close source and not"
" free. You have to own the licenses to **legally** use it."
msgstr "Synopsys VCS 是一款**商业**仿真工具。它是闭源的并且不是免费的。您必须拥有许可证才能**合法**使用它。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:60
msgid ""
"Before using VCS as the simulation backend, make sure that you have checked "
"your system environment as :ref:`VCS environment<vcs_env>`."
msgstr "在使用 VCS 作为模拟后端之前，请确保您已将系统环境检查为:ref:`VCS 环境<vcs_env>`。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:63
msgid "How SpinalHDL simulates the hardware with Xilinx XSim backend"
msgstr "SpinalHDL 如何使用 Xilinx XSim 后端模拟硬件"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:67
msgid ""
"The communication between the simulation and the JVM is established through "
"shared memory. The commands are issued to the simulator using XSI."
msgstr "模拟和JVM之间的通信是通过共享内存建立的。命令使用 XSI 发送到模拟器。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:71
msgid "Support Xilinx built-in primitives and cores."
msgstr "支持 Xilinx 内置原语和内核。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:75
msgid ""
"Xilinx XSim is a **commercial** tool installed with Vivado. It is closed "
"source and subject to licensing terms to use. You have to own the licenses "
"to **legally** use it."
msgstr ""
"Xilinx XSim 是与 Vivado 一起安装的**商业**工具。它是闭源的，并受许可条款的使用。您必须拥有许可证才能**合法**使用它。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:76
msgid "Vivado versions prior to 2019.1 do not work properly."
msgstr "2019.1 之前的 Vivado 版本无法正常工作。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:78
msgid ""
"Before using XSim as the simulation backend, make sure that you have done "
"following steps. 1. Define VIVADO_HOME environment variable to specify where"
" your vivado located. ex `export VIVADO_HOME=/d/Xilinx/Vivado/2022.1` (under"
" MSYS2). 2. Make sure two vivado path is inside the PATH. For Windows MSYS2 "
"user, run shell command like `export "
"PATH=$PATH:$VIVADO_HOME/bin:$VIVADO_HOME/lib/win64.o`. For Linux user just "
"source the Vivado's settings64.sh file located at `VIVADO_HOME`."
msgstr ""
"在使用 XSim 作为模拟后端之前，请确保您已完成以下步骤。 1. 定义 VIVADO_HOME 环境变量以指定 vivado 所在的位置。 ex "
"`export VIVADO_HOME=/d/Xilinx/Vivado/2022.1`（在 MSYS2 下）。 "
"2.确保两个vivado路径在PATH内。对于 Windows MSYS2 用户，运行 shell 命令，如“export "
"PATH=$PATH:$VIVADO_HOME/bin:$VIVADO_HOME/lib/win64.o”。对于 Linux "
"用户，只需获取位于“VIVADO_HOME”的 Vivado 的 settings64.sh 文件。"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:83
msgid "Performance"
msgstr "表现"
#: ../../SpinalHDL/Simulation/simulator_specifics.rst:85
msgid ""
"When a high-performance simulation is required, Verilator should be used as "
"a backend. On a little SoC like `Murax "
"<https://github.com/SpinalHDL/VexRiscv>`_, an Intel® Core™ i7-4720HQ is "
"capable of simulating 1.2 million clock cycles per second. However, when the"
" DUT is simple and a maximum of few thousands clock cycles have to be "
"simulated, using GHDL or Icarus Verilog could yield a better result, due to "
"their lower simulation loading overhead."
msgstr ""
"当需要高性能仿真时，应使用Verilator作为后端。在像“Murax "
"<https://github.com/SpinalHDL/VexRiscv>”这样的小型 SoC 上，英特尔® 酷睿™ i7-4720HQ "
"能够每秒模拟 120 万个时钟周期。然而，当 DUT 很简单并且需要仿真最多几千个时钟周期时，使用 GHDL 或 Icarus Verilog "
"可以产生更好的结果，因为它们的仿真负载开销较低。"
