
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDL"
"Report-Msgid-Bugs-To:"
"POT-Creation-Date:2023-12-01 11:48+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language:zh_CN"
"Language-Team:zh_CN <LL@li.org>"
"Plural-Forms:nplurals=1; plural=0;"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../source/SpinalHDL/Sequential logic/memory.rst:5
msgid "RAM/ROM"
msgstr "内存/只读存储器"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:8 logic/memory.rst:19
#: logic/memory.rst:43 logic/memory.rst:164
msgid "Syntax"
msgstr "句法"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:10
msgid ""
"To create a memory in SpinalHDL, the ``Mem`` class should be used. It allows"
" you to define a memory and add read and write ports to it."
msgstr "要在 SpinalHDL 中创建内存，应使用“Mem”类。它允许您定义内存并向其添加读写端口。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:13
msgid "The following table shows how to instantiate a memory:"
msgstr "下表显示了如何实例化内存："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:20 logic/memory.rst:44
#: logic/memory.rst:143 logic/memory.rst:165 logic/memory.rst:230
msgid "Description"
msgstr "描述"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:21
msgid "``Mem(type : Data, size : Int)``"
msgstr "``Mem（类型：数据，大小：Int）``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:22
msgid "Create a RAM"
msgstr "创建内存"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:23
msgid "``Mem(type : Data, initialContent : Array[Data])``"
msgstr "``Mem（类型：数据，初始内容：数组[数据]）``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:24
msgid ""
"Create a ROM. If your target is an FPGA, because the memory can be inferred "
"as a block ram, you can still create write ports on it."
msgstr "创建一个 ROM。如果您的目标是 FPGA，因为内存可以推断为块 RAM，您仍然可以在其上创建写入端口。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:28
msgid ""
"If you want to define a ROM, elements of the ``initialContent`` array should"
" only be literal values (no operator, no resize functions). There is an "
"example :ref:`here <sinus_rom>`."
msgstr ""
"如果你想定义一个 ROM，``initialContent`` "
"数组的元素应该只是文字值（没有运算符，没有调整大小函数）。这里有一个例子:ref:`<sinus_rom>`。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:31
msgid "To give a RAM initial values, you can also use the ``init`` function."
msgstr "要给 RAM 初始值，您还可以使用“init”函数。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:34
msgid ""
"Write mask width is flexible, and subdivide the memory word in as many "
"slices of equal width as the width of the mask. For instance if you have a "
"32 bits memory word and provide a 4 bits mask then it will be a byte mask. "
"If you provide a as many mask bits than you have word bits, then it is a bit"
" mask."
msgstr ""
"写入掩码宽度是灵活的，并将存储器字细分为与掩码宽度相同宽度的多个片。例如，如果您有一个 32 位内存字并提供 4 "
"位掩码，那么它将是字节掩码。如果您提供的掩码位与字位一样多，则它是位掩码。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:37
msgid "The following table show how to add access ports on a memory :"
msgstr "下表显示了如何在内存上添加访问端口："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:45
msgid "Return"
msgstr "返回"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:46
msgid "mem(address) := data"
msgstr "mem(地址) := 数据"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:47
msgid "Synchronous write"
msgstr "同步写入"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:49
msgid "mem(x)"
msgstr "内存（x）"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:50
msgid "Asynchronous read"
msgstr "异步读取"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:51 logic/memory.rst:66
#: logic/memory.rst:74 logic/memory.rst:87
msgid "T"
msgstr "时间"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.write("
msgstr "内存.write("
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "address"
msgstr "地址"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "data"
msgstr "数据"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "[enable]"
msgstr "[使能够]"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "[mask]"
msgstr "[面具]"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid ")"
msgstr "）"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:58
msgid ""
"Synchronous write with an optional mask. If no enable is specified, it's "
"automatically inferred from the conditional scope where this function is "
"called"
msgstr "使用可选掩码进行同步写入。如果未指定启用，则会自动从调用此函数的条件范围中推断出"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.readAsync("
msgstr "mem.readAsync("
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "[readUnderWrite]"
msgstr "[读下写]"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:65
msgid "Asynchronous read with an optional read-under-write policy"
msgstr "具有可选的读下写策略的异步读取"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.readSync("
msgstr "内存.readSync("
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "[clockCrossing]"
msgstr "[时钟穿越]"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:73
msgid ""
"Synchronous read with an optional enable, read-under-write policy, and "
"``clockCrossing`` mode"
msgstr "具有可选启用、读下写策略和“clockCrossing”模式的同步读取"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.readWriteSync("
msgstr "mem.readWriteSync("
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "enable"
msgstr "使能够"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "write"
msgstr "写"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "Infer a read/write port."
msgstr "推断读/写端口。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "``data`` is written when ``enable && write``."
msgstr "当“enable && write”时写入“data”。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "Return the read data, the read occurs when ``enable`` is true"
msgstr "返回读取的数据，当``enable``为true时发生读取"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:91
msgid ""
"If for some reason you need a specific memory port which is not implemented "
"in Spinal, you can always abstract over your memory by specifying a BlackBox"
" for it."
msgstr "如果由于某种原因您需要一个未在 Spinal 中实现的特定内存端口，您始终可以通过为其指定 BlackBox 来抽象您的内存。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:94
msgid ""
"Memory ports in SpinalHDL are not inferred, but are explicitly defined. You "
"should not use coding templates like in VHDL/Verilog to help the synthesis "
"tool to infer memory."
msgstr "SpinalHDL 中的内存端口不是推断的，而是明确定义的。您不应使用 VHDL/Verilog 等编码模板来帮助综合工具推断内存。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:96
msgid "Here is a example which infers a simple dual port ram (32 bits * 256):"
msgstr "下面是一个推断简单双端口 RAM（32 位 * 256）的示例："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:114
msgid "Synchronous enable quirk"
msgstr "同步启用怪癖"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:116
msgid ""
"When enable signals are used in a block guarded by a conditional block like "
"`when`, only the enable signal will be generated as the access condition: "
"the `when` condition is ignored."
msgstr "当使能信号用于由“when”等条件块保护的块中时，只会生成使能信号作为访问条件：“when”条件将被忽略。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:126
msgid ""
"In the example above the condition `cond` will not be elaborated. Prefer to "
"include the condition `cond` in the enable signal directly as below."
msgstr "上面的例子中条件`cond`就不详细说明了。最好直接在使能信号中包含条件“cond”，如下所示。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:134
msgid "Read-under-write policy"
msgstr "读写策略"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:136
msgid ""
"This policy specifies how a read is affected when a write occurs in the same"
" cycle to the same address."
msgstr "此策略指定在同一周期内对同一地址发生写入时，读取将受到怎样的影响。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:142 logic/memory.rst:229
msgid "Kinds"
msgstr "种类"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:144
msgid "``dontCare``"
msgstr "``不在乎``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:145
msgid "Don't care about the read value when the case occurs"
msgstr "发生这种情况时不用关心读取的值"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:146
msgid "``readFirst``"
msgstr "``首先阅读``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:147
msgid "The read will get the old value (before the write)"
msgstr "读取将得到旧值（写入之前）"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:148
msgid "``writeFirst``"
msgstr "``先写``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:149
msgid "The read will get the new value (provided by the write)"
msgstr "读取将得到新值（由写入提供）"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:153
msgid ""
"The generated VHDL/Verilog is always in the ``readFirst`` mode, which is "
"compatible with ``dontCare`` but not with ``writeFirst``. To generate a "
"design that contains this kind of feature, you need to enable "
":ref:`automatic memory blackboxing <automatic_memory_blackboxing>`."
msgstr ""
"生成的 VHDL/Verilog "
"始终处于“readFirst”模式，该模式与“dontCare”兼容，但与“writeFirst”不兼容。要生成包含此类功能的设计，您需要启用:ref:`自动内存黑盒"
" <automatic_memory_blackboxing>`。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:156
msgid "Mixed-width ram"
msgstr "混合宽度内存"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:158
msgid ""
"You can specify ports that access the memory with a width that is a power of"
" two fraction of the memory width using these functions:"
msgstr "您可以使用以下函数指定访问内存的端口，其宽度为内存宽度的二分之一次方："
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.writeMixedWidth("
msgstr "mem.writeMixedWidth("
#: ../../source/SpinalHDL/Sequential logic/memory.rst:171
msgid "Similar to ``mem.write``"
msgstr "类似于“mem.write”"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.readAsyncMixedWidth("
msgstr "mem.readAsyncMixedWidth("
#: ../../source/SpinalHDL/Sequential logic/memory.rst:177
msgid ""
"Similar to ``mem.readAsync``, but in place of returning the read value, it "
"drives the signal/object given as the ``data`` argument"
msgstr "与“mem.readAsync”类似，但它不是返回读取值，而是驱动作为“data”参数给出的信号/对象"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.readSyncMixedWidth("
msgstr "mem.readSyncMixedWidth("
#: ../../source/SpinalHDL/Sequential logic/memory.rst:185
msgid ""
"Similar to ``mem.readSync``, but in place of returning the read value, it "
"drives the signal/object given as the ``data`` argument"
msgstr "与“mem.readSync”类似，但它不是返回读取值，而是驱动作为“data”参数给出的信号/对象"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "mem.readWriteSyncMixedWidth("
msgstr "mem.readWriteSyncMixedWidth("
#: ../../source/SpinalHDL/Sequential logic/memory.rst:195
msgid "Equivalent to ``mem.readWriteSync``"
msgstr "相当于“mem.readWriteSync”"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:199
msgid ""
"As for read-under-write policy, to use this feature you need to enable "
":ref:`automatic memory blackboxing <automatic_memory_blackboxing>`, because "
"there is no universal VHDL/Verilog language template to infer mixed-width "
"ram."
msgstr ""
"至于读下写策略，要使用此功能，您需要启用自动内存黑盒 <automatic_memory_blackboxing>`，因为没有通用的 "
"VHDL/Verilog 语言模板来推断混合宽度 ram。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:204
msgid "Automatic blackboxing"
msgstr "自动黑盒"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:206
msgid ""
"Because it's impossible to infer all ram kinds by using regular "
"VHDL/Verilog, SpinalHDL integrates an optional automatic blackboxing system."
" This system looks at all memories present in your RTL netlist and replaces "
"them with blackboxes. Then the generated code will rely on third party IP to"
" provide the memory features, such as the read-during-write policy and "
"mixed-width ports."
msgstr ""
"由于使用常规 VHDL/Verilog 不可能推断所有 ram 类型，因此 SpinalHDL 集成了可选的自动黑盒系统。该系统会查看 RTL "
"网表中存在的所有内存，并用黑盒替换它们。然后生成的代码将依赖第三方IP来提供内存功能，例如read-during-write策略和混合宽度端口。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:208
msgid ""
"Here is an example of how to enable blackboxing of memories by default:"
msgstr "以下是如何默认启用内存黑盒的示例："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:218
msgid ""
"If the standard blackboxing tools don't do enough for your design, do not "
"hesitate to create a `Github issue "
"<https://github.com/SpinalHDL/SpinalHDL/issues>`_. There is also a way to "
"create your own blackboxing tool."
msgstr ""
"如果标准黑盒工具不足以满足您的设计需求，请毫不犹豫地创建“Github 问题 "
"<https://github.com/SpinalHDL/SpinalHDL/issues>”_。还有一种方法可以创建您自己的黑盒工具。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:221
msgid "Blackboxing policy"
msgstr "黑盒政策"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:223
msgid ""
"There are multiple policies that you can use to select which memory you want"
" to blackbox and also what to do when the blackboxing is not feasible:"
msgstr "您可以使用多种策略来选择要黑盒的内存以及黑盒不可行时要执行的操作："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:231
msgid "``blackboxAll``"
msgstr "``黑盒全部``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "Blackbox all memory."
msgstr "黑匣子所有内存。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "Throw an error on unblackboxable memory"
msgstr "对不可黑盒内存抛出错误"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:234
msgid "``blackboxAllWhatsYouCan``"
msgstr "``blackboxAllWhatsYouCan``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:235
msgid "Blackbox all memory that is blackboxable"
msgstr "黑盒所有可黑盒的内存"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:236
msgid "``blackboxRequestedAndUninferable``"
msgstr "``blackboxRequestedAndUninferable``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid ""
"Blackbox memory specified by the user and memory that is known to be "
"uninferable (mixed-width, ...)."
msgstr "用户指定的黑盒内存和已知不可推断的内存（混合宽度，...）。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:239
msgid "``blackboxOnlyIfRequested``"
msgstr "``blackboxOnlyIfRequested``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst
msgid "Blackbox memory specified by the user"
msgstr "用户指定的黑盒内存"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:244
msgid ""
"To explicitly set a memory to be blackboxed, you can use its "
"``generateAsBlackBox`` function."
msgstr "要显式地将内存设置为黑盒，您可以使用其“generateAsBlackBox”函数。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:251
msgid ""
"You can also define your own blackboxing policy by extending the "
"``MemBlackboxingPolicy`` class."
msgstr "您还可以通过扩展“MemBlackboxingPolicy”类来定义自己的黑盒策略。"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:254
msgid "Standard memory blackboxes"
msgstr "标准内存黑匣子"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:256
msgid ""
"Shown below are the VHDL definitions of the standard blackboxes used in "
"SpinalHDL:"
msgstr "下面显示的是 SpinalHDL 中使用的标准黑盒的 VHDL 定义："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:368
msgid ""
"As you can see, blackboxes have a technology parameter. To set it, you can "
"use the ``setTechnology`` function on the corresponding memory. There are "
"currently 4 kinds of technologies possible:"
msgstr "正如你所看到的，黑匣子有一个技术参数。要设置它，您可以在相应的内存上使用“setTechnology”函数。目前有4种可能的技术："
#: ../../source/SpinalHDL/Sequential logic/memory.rst:371
msgid "``auto``"
msgstr "``自动``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:372
msgid "``ramBlock``"
msgstr "``内存块``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:373
msgid "``distributedLut``"
msgstr "``分布式Lut``"
#: ../../source/SpinalHDL/Sequential logic/memory.rst:374
msgid "``registerFile``"
msgstr "``注册文件``"
