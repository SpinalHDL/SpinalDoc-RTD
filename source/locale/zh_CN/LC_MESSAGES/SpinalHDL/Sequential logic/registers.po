
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDLReport-Msgid-Bugs-To:POT-Creation-"
"Date:2023-12-01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-"
"Translator:FULL NAME <EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN "
"<LL@li.org>Plural-Forms:nplurals=1; plural=0;MIME-Version:1.0Content-"
"Type:text/plain; charset=UTF-8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2023-12-02 00:23+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../SpinalHDL/Sequential logic/registers.rst:4
msgid "Registers"
msgstr "寄存器"

#: ../../SpinalHDL/Sequential logic/registers.rst:6
msgid "Creating registers in SpinalHDL is very different than in VHDL or Verilog."
msgstr "在 SpinalHDL 中创建寄存器与在 VHDL 或 Verilog 中创建寄存器有很大不同。"

#: ../../SpinalHDL/Sequential logic/registers.rst:8
msgid ""
"In Spinal, there are no process/always blocks. Registers are explicitly "
"defined at declaration. This difference from traditional event-driven HDL"
" has a big impact:"
msgstr "在 Spinal 中，没有 process/always 块。寄存器在声明时明确定义。这种与传统的事件驱动 HDL 的区别具有很大的影响："

#: ../../SpinalHDL/Sequential logic/registers.rst:11
msgid ""
"You can assign registers and wires in the same scope, meaning the code "
"doesn't need to be split between process/always blocks"
msgstr "您可以在同一范围内分配寄存器和连线，这意味着代码不需要在 process/always 块之间拆分"

#: ../../SpinalHDL/Sequential logic/registers.rst:12
msgid "It make things much more flexible (see :ref:`Functions <function>`)"
msgstr "它使事情变得更加灵活（参见:ref:`Functions <function>`）"

#: ../../SpinalHDL/Sequential logic/registers.rst:14
msgid ""
"Clocks and resets are handled separately, see the :ref:`Clock domain "
"<clock_domain>` chapter for details."
msgstr "时钟和复位是分开处理的，有关详细信息，请参阅时钟域 <clock_domain>` 章节。"

#: ../../SpinalHDL/Sequential logic/registers.rst:17
msgid "Instantiation"
msgstr "实例化"

#: ../../SpinalHDL/Sequential logic/registers.rst:19
msgid "There are 4 ways to instantiate a register:"
msgstr "实例化寄存器有4种方法："

#: ../../SpinalHDL/Sequential logic/registers.rst:25
msgid "Syntax"
msgstr "句法"

#: ../../SpinalHDL/Sequential logic/registers.rst:26
msgid "Description"
msgstr "描述"

#: ../../SpinalHDL/Sequential logic/registers.rst:27
msgid "``Reg(type : Data)``"
msgstr "``Reg（类型：数据）``"

#: ../../SpinalHDL/Sequential logic/registers.rst:28
msgid "Register of the given type"
msgstr "给定类型的寄存器"

#: ../../SpinalHDL/Sequential logic/registers.rst:29
msgid "``RegInit(resetValue : Data)``"
msgstr "``RegInit（重置值：数据）``"

#: ../../SpinalHDL/Sequential logic/registers.rst:30
msgid "Register loaded with the given ``resetValue`` when a reset occurs"
msgstr "当发生重置时，寄存器加载给定的“resetValue”"

#: ../../SpinalHDL/Sequential logic/registers.rst:31
msgid "``RegNext(nextValue : Data)``"
msgstr "``RegNext（下一个值：数据）``"

#: ../../SpinalHDL/Sequential logic/registers.rst:32
msgid "Register that samples the given ``nextValue`` each cycle"
msgstr "每个周期对给定的“nextValue”进行采样的寄存器"

#: ../../SpinalHDL/Sequential logic/registers.rst:33
msgid "``RegNextWhen(nextValue : Data, cond : Bool)``"
msgstr "``RegNextWhen(nextValue：数据，cond：Bool)``"

#: ../../SpinalHDL/Sequential logic/registers.rst:34
msgid "Register that samples the given ``nextValue`` when a condition occurs"
msgstr "当条件发生时对给定的“nextValue”进行采样的寄存器"

#: ../../SpinalHDL/Sequential logic/registers.rst:36
msgid "Here is an example declaring some registers:"
msgstr "这是声明一些寄存器的示例："

#: ../../SpinalHDL/Sequential logic/registers.rst:56
msgid "The code above will infer the following logic:"
msgstr "上面的代码将推断出以下逻辑："

#: ../../SpinalHDL/Sequential logic/registers.rst:62
#, fuzzy
msgid ""
"The ``reg3`` example above shows how you can assign the value of a "
"``RegInit`` register. It's possible to use the same syntax to assign to "
"the other register types as well (``Reg``, ``RegNext``, ``RegNextWhen``)."
" Just like in combinational assignments, the rule is 'Last assignment "
"wins', but if no assignment is done, the register keeps its value. If the"
" Reg is declared in a design and does not have suitable assignment and "
"consumption it is likely to be pruned (removed from design) at some point"
" by EDA flows after being deemed unnecessary."
msgstr "上面的“reg3”示例显示了如何分配“RegInit”寄存器的值。也可以使用相同的语法分配给其他寄存器类型（“Reg”、“RegNext”、“RegNextWhen”）。就像组合赋值一样，规则是“最后一个赋值获胜”，但如果没有完成赋值，寄存器将保留其值。"

#: ../../SpinalHDL/Sequential logic/registers.rst:70
msgid ""
"Also, ``RegNext`` is an abstraction which is built over the ``Reg`` "
"syntax. The two following sequences of code are strictly equivalent:"
msgstr "另外，“RegNext”是一个基于“Reg”语法构建的抽象。以下两个代码序列严格等效："

#: ../../SpinalHDL/Sequential logic/registers.rst:84
msgid ""
"It is possible to have multiple options at the same time in other ways "
"and so slightly more advanced compositions built on top of the basic "
"understand of the above:"
msgstr ""

#: ../../SpinalHDL/Sequential logic/registers.rst:125
msgid "Reset value"
msgstr "复位值"

#: ../../SpinalHDL/Sequential logic/registers.rst:127
msgid ""
"In addition to the ``RegInit(value : Data)`` syntax which directly "
"creates the register with a reset value, you can also set the reset value"
" by calling the ``init(value : Data)`` function on the register."
msgstr ""
"除了直接创建具有重置值的寄存器的“RegInit(value : Data)”语法之外，您还可以通过在寄存器上调用“init(value : "
"Data)”函数来设置重置值。"

#: ../../SpinalHDL/Sequential logic/registers.rst:135
msgid ""
"If you have a register containing a Bundle, you can use the ``init`` "
"function on each element of the Bundle."
msgstr "如果您有一个包含 Bundle 的寄存器，则可以对 Bundle 的每个元素使用“init”函数。"

#: ../../SpinalHDL/Sequential logic/registers.rst:148
msgid "Initialization value for simulation purposes"
msgstr "用于模拟目的的初始化值"

#: ../../SpinalHDL/Sequential logic/registers.rst:150
msgid ""
"For registers that don't need a reset value in RTL, but need an "
"initialization value for simulation (to avoid x-propagation), you can ask"
" for a random initialization value by calling the ``randBoot()`` "
"function."
msgstr "对于在 RTL 中不需要复位值，但需要模拟初始化值（以避免 x 传播）的寄存器，您可以通过调用“randBoot()”函数来请求随机初始化值。"

#: ../../SpinalHDL/Sequential logic/registers.rst:158
msgid "Register vectors"
msgstr "注册向量"

#: ../../SpinalHDL/Sequential logic/registers.rst:160
msgid "As for wires, it is possible to define a vector of registers with ``Vec``."
msgstr "至于连线，可以使用“Vec”定义寄存器向量。"

#: ../../SpinalHDL/Sequential logic/registers.rst:167
msgid ""
"Initialization can be done with the ``init`` method as usual, which can "
"be combined with the ``foreach`` iteration on the registers."
msgstr "初始化可以像往常一样使用“init”方法完成，它可以与寄存器上的“foreach”迭代相结合。"

#: ../../SpinalHDL/Sequential logic/registers.rst:175
msgid ""
"In case where the initialization must be deferred since the init value is"
" not known, use a function as in the example below."
msgstr "如果由于初始化值未知而必须推迟初始化，请使用如下例所示的函数。"

#: ../../SpinalHDL/Sequential logic/registers.rst:208
msgid "Transforming a wire into a register"
msgstr "将电线转换为寄存器"

#: ../../SpinalHDL/Sequential logic/registers.rst:210
msgid ""
"Sometimes it is useful to transform an existing wire into a register. For"
" instance, when you are using a Bundle, if you want some outputs of the "
"bundle to be registers, you might prefer to write ``io.myBundle.PORT := "
"newValue`` without declaring registers with ``val PORT = Reg(...)`` and "
"connecting their output to the port with ``io.myBundle.PORT := PORT``. To"
" do this, you just need to use ``.setAsReg()`` on the ports you want to "
"control as registers:"
msgstr ""
"有时将现有的连线转换为寄存器很有用。例如，当您使用 Bundle 时，如果您希望 Bundle 的某些输出成为寄存器，您可能更愿意编写 "
"``io.myBundle.PORT := newValue`` 而不用 ``val PORT = Reg( ...)`` "
"并将其输出连接到带有``io.myBundle.PORT := PORT`` "
"的端口。为此，您只需在要控制为寄存器的端口上使用``.setAsReg()``："

#: ../../SpinalHDL/Sequential logic/registers.rst:230
msgid ""
"Notice in the code above that you can also specify an initialization "
"value."
msgstr "请注意，在上面的代码中，您还可以指定初始化值。"

#: ../../SpinalHDL/Sequential logic/registers.rst:234
msgid ""
"The register is created in the clock domain of the wire, and does not "
"depend on the place where ``.setAsReg()`` is used."
msgstr "该寄存器是在线路的时钟域中创建的，并且不依赖于使用``.setAsReg()``的位置。"

#: ../../SpinalHDL/Sequential logic/registers.rst:237
msgid ""
"In the example above, the wire is defined in the ``io`` Bundle, in the "
"same clock domain as the component. Even if ``io.apb.PADDR.setAsReg()`` "
"was written in a ``ClockingArea`` with a different clock domain, the "
"register would use the clock domain of the component and not the one of "
"the ``ClockingArea``."
msgstr "在上面的示例中，线路在“io”捆绑包中定义，与组件位于同一时钟域中。即使“io.apb.PADDR.setAsReg()”写入具有不同时钟域的“ClockingArea”中，寄存器也将使用组件的时钟域，而不是“ClockingArea”的时钟域`。"

#~ msgid "Introduction"
#~ msgstr "介绍"

