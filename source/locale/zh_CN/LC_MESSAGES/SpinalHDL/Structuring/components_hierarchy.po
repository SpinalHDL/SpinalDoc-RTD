
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDLReport-Msgid-Bugs-To:POT-Creation-"
"Date:2023-12-01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-"
"Translator:FULL NAME <EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN "
"<LL@li.org>Plural-Forms:nplurals=1; plural=0;MIME-Version:1.0Content-"
"Type:text/plain; charset=UTF-8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESSPOT-Creation-Date:2023-12-02 00:23"
"+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME "
"<EMAIL@ADDRESS>Language-Team:LANGUAGE <LL@li.org>MIME-Version:1.0Content-"
"Type:text/plain; charset=UTF-8\n"
"POT-Creation-Date: 2025-02-12 09:08+0000\n"
"PO-Revision-Date: 2023-12-24 15:38+0000\n"
"Last-Translator: Readon <xydarcher@qq.com>\n"
"Language: zh_CN\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects"
"/spinaldoc-rtd/spinalhdlstructuringcomponents_hierarchy/zh_Hans/>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:4
msgid "Components and hierarchy"
msgstr "组件和层次结构"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:6
msgid ""
"Like in VHDL and Verilog, you can define components that can be used to "
"build a design hierarchy. However, in SpinalHDL, you don't need to bind "
"their ports at instantiation:"
msgstr "像在VHDL和Verilog中一样，可以使用组件构建设计层次结构。然而，在SpinalHDL中，不需要在实例化时绑定它们的端口："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
#, fuzzy, python-brace-format
msgid "``val io = new Bundle { ... }``"
msgstr "``val io = new Bundle { ... }``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid ""
"Declaring external ports in a ``Bundle`` called ``io`` is recommended. If"
" you name your bundle ``io``, SpinalHDL will check that all of its "
"elements are defined as inputs or outputs."
msgstr ""
"建议在名为 ``io`` 的 ``Bundle`` 中声明外部端口。如果您将线束命名为 ``io``，SpinalHDL "
"将检查其所有元素是否定义为输入或输出。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:41
msgid ""
"If it is better to your taste, you can use the ``Module`` syntax instead "
"of ``Component`` (they are the same thing)"
msgstr "如果更符合您的风格，您也可以使用 ``Module`` 语法而不是 ``Component`` （它们是相同的东西）"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:47
msgid "Input / output definition"
msgstr "输入/输出定义"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:49
msgid "The syntax to define inputs and outputs is as follows:"
msgstr "定义输入和输出的语法如下："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:55
msgid "Syntax"
msgstr "语法"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:56
msgid "Description"
msgstr "描述"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:57
msgid "Return"
msgstr "返回类型"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``in port Bool()``"
msgstr "``in port Bool()``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``out port Bool()``"
msgstr "``out port Bool()``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:60
msgid "Create an input Bool/output Bool"
msgstr "创建输入 Bool/输出 Bool"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:61
msgid "Bool"
msgstr "Bool"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``in Bits/UInt/SInt[(x bits)]``"
msgstr "``in Bits/UInt/SInt[(x bits)]``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``out Bits/UInt/SInt[(x bits)]``"
msgstr "``out Bits/UInt/SInt[(x bits)]``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``in Bits(3 bits)``"
msgstr "``in Bits(3 bits)``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:65
msgid "Create an input/output of the corresponding type"
msgstr "创建相应类型的输入/输出端口"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:66
msgid "Bits/UInt/SInt"
msgstr "Bits/UInt/SInt"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``in(T)``"
msgstr "``in(T)``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``out(T)``"
msgstr "``out(T)``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:69
msgid ""
"For all other data types, you may have to add some brackets around it. "
"Sorry, this is a Scala limitation."
msgstr "对于所有其他数据类型，您可能需要在其周围添加一些括号。这是 Scala 的限制。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:70
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:76
msgid "T"
msgstr "T"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``master(T)``"
msgstr "``master(T)``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``slave(T)``"
msgstr "``slave(T)``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``master(Bool())``"
msgstr "``master(Bool())``"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:74
msgid ""
"This syntax is provided by the ``spinal.lib`` library (If you annotate "
"your object with the ``slave`` syntax, then import ``spinal.lib.slave`` "
"instead). T must extend ``IMasterSlave``. Some documentation is available"
" :ref:`here <interface_example_apb>`. You may not actually need the "
"brackets, so ``master T`` is fine as well."
msgstr ""
"此语法由 ``spinal.lib`` 库提供（如果您使用 ``slave`` 语法标注对象，则应导入 "
"``spinal.lib.slave``）。 T 必须继承自 ``IMasterSlave``。一些参考文档在 :ref:`这里 "
"<interface_example_apb>` 。您实际上可能不需要括号，因此写成 ``master T`` 也可以。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:79
msgid "There are some rules to follow with component interconnection:"
msgstr "组件之间的互连需要遵循一些规则："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:82
msgid "Components can only **read** output and input signals of child components."
msgstr "组件只能 **读取** 子组件的输出和输入信号。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:83
msgid "Components can read their own output port values (unlike in VHDL)."
msgstr "组件可以读取自己的输出端口值（与 VHDL 不同）。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:86
msgid ""
"If for some reason you need to read signals from far away in the "
"hierarchy (such as for debugging or temporal patches), you can do it by "
"using the value returned by ``some.where.else.theSignal.pull()``"
msgstr ""
"如果由于某种原因您需要从层次结构中较深的位置读取信号（例如用于调试或临时补丁），您可以使用 "
"``some.where.else.theSignal.pull()`` 函数返回的信号来完成此操作"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:90
msgid "Pruned signals"
msgstr "裁剪信号"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:92
#, fuzzy
msgid ""
"SpinalHDL will generate all the named signals and their dependencies, "
"while all the useless anonymous / zero width ones are removed from the "
"RTL generation."
msgstr "SpinalHDL 将生成所有命名信号及其依赖性，而所有无用的匿名/零位宽信号将从 RTL 生成中删除。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:95
msgid ""
"You can collect the list of all the removed ans useless signals via the "
"``printPruned`` and the ``printPrunedIo`` functions on the generated "
"``SpinalReport`` object:"
msgstr ""
"您可以通过生成的 ``SpinalReport`` 对象上的 ``printPruned`` 和 ``printPrunedIo`` "
"函数收集所有已删除的无用信号列表："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:125
msgid "Parametrized Hardware (\"Generic\" in VHDL, \"Parameter\" in Verilog)"
msgstr "参数化硬件（VHDL 中的“Generic”，Verilog 中的“Parameter”）"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:127
msgid ""
"If you want to parameterize your component, you can give parameters to "
"the constructor of the component as follows:"
msgstr "如果你想参数化你的组件，你可以将参数传递给组件的构造函数，如下所示："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:145
msgid ""
"If you have several parameters, it is a good practice to give a specific "
"configuration class as follows:"
msgstr "如果您有多个参数，最好给出一个专用的配置类，如下所示："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:158
msgid ""
"You can add functions inside the config, along with requirements on the "
"config attributes:"
msgstr "您可以在配置中添加功能以及对配置属性的要求："

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:172
msgid ""
"This parametrization occurs entirely within the SpinalHDL code-generation"
" during elaboration.  This generates non-generic HDL code. The methods "
"described here do not use VHDL generics or Verilog parameters."
msgstr ""
"这种参数化完全发生在 SpinalHDL 代码生成的实例细化过程中。生成的 HDL 代码不包含使用HDL语言泛化特性的内容。此处描述的方法不会使用"
" VHDL 泛型或 Verilog 参数。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:176
msgid ""
"See also :ref:`Blackbox <blackbox>` for more information around support "
"for that mechanism."
msgstr "另请参阅 :ref:`Blackbox <blackbox>` 了解有关该机制支持的更多信息。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:181
msgid "Synthesized component names"
msgstr "综合后组件名称"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:183
msgid ""
"Within a module, each component has a name, called a \"partial name\". "
"The \"full\" name is built by joining every component's parent name with "
"\"_\", for example: ``io_clockDomain_reset``. You can use ``setName`` to "
"replace this convention with a custom name. This is especially useful "
"when interfacing with external components. The other methods are called "
"``getName``, ``setPartialName``, and ``getPartialName`` respectively."
msgstr ""
"在模块内，每个组件都有一个名称，称为“部分名称”。 "
"“完整”名称是通过将每个组件的父名称与“_”连接起来构建的，例如：``io_clockDomain_reset``。您可以使用 "
"``setName`` 将按此约定生成的名称替换为自定义的。这在与外部组件连接时特别有用。其他方法分别称为 "
"``getName``、``setPartialName`` 和 ``getPartialName``。"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:189
msgid ""
"When synthesized, each module gets the name of the Scala class defining "
"it. You can override this as well with ``setDefinitionName``."
msgstr "综合时，每个模块都会获得定义它的 Scala 类的名称。您也可以调用 ``setDefinitionName`` 函数来覆盖它。"

#~ msgid "Introduction"
#~ msgstr "介绍"

#~ msgid "``out UInt(7 bits)``"
#~ msgstr "``out UInt(7 bits)``"

