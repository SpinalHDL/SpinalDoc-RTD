
msgid ""
msgstr ""
"Project-Id-Version:SpinalHDLReport-Msgid-Bugs-To:POT-Creation-Date:2023-12-01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME <EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN <LL@li.org>Plural-Forms:nplurals=1; plural=0;MIME-Version:1.0Content-Type:text/plain; charset=UTF-8\n"
"Report-Msgid-Bugs-To:EMAIL@ADDRESS"
"POT-Creation-Date:2023-12-02 00:23+0800"
"PO-Revision-Date:YEAR-MO-DA HO:MI+ZONE"
"Last-Translator:FULL NAME <EMAIL@ADDRESS>"
"Language-Team:LANGUAGE <LL@li.org>"
"MIME-Version:1.0"
"Content-Type:text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding:8bit"
"Generated-By:Babel 2.13.1"

#: ../../SpinalHDL/Structuring/components_hierarchy.rst:4
#, fuzzy
msgid "Components and hierarchy"
msgstr "组件和层次结构"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:6
msgid ""
"Like in VHDL and Verilog, you can define components that can be used to "
"build a design hierarchy. However, in SpinalHDL, you don't need to bind "
"their ports at instantiation:"
msgstr ""
"与 VHDL 和 Verilog 一样，您可以定义可用于构建设计层次结构的组件。但是，在 SpinalHDL 中，您不需要在实例化时绑定它们的端口："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``val io = new Bundle { ... }``"
msgstr "``val io = new Bundle { ... }``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid ""
"Declaring external ports in a ``Bundle`` called ``io`` is recommended. If "
"you name your bundle ``io``, SpinalHDL will check that all of its elements "
"are defined as inputs or outputs."
msgstr "建议在名为“io”的“Bundle”中声明外部端口。如果您将包命名为“io”，SpinalHDL 将检查其所有元素是否定义为输入或输出。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:41
msgid ""
"If it is better to your taste, you can use the ``Module`` syntax instead of "
"``Component`` (they are the same thing)"
msgstr "如果更适合您的口味，您可以使用“Module”语法而不是“Component”（它们是相同的东西）"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:47
msgid "Input / output definition"
msgstr "输入/输出定义"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:49
msgid "The syntax to define inputs and outputs is as follows:"
msgstr "定义输入和输出的语法如下："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:55
msgid "Syntax"
msgstr "句法"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:56
msgid "Description"
msgstr "描述"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:57
msgid "Return"
msgstr "返回"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
#, fuzzy
msgid "``in port Bool()``"
msgstr "``在端口 Bool()``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``out port Bool()``"
msgstr "``输出端口 Bool()``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:60
msgid "Create an input Bool/output Bool"
msgstr "创建输入 Bool/输出 Bool"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:61
msgid "Bool"
msgstr "布尔"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
#, fuzzy
msgid "``in Bits/UInt/SInt[(x bits)]``"
msgstr "``以位/UInt/SInt[(x 位)]``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
#, fuzzy
msgid "``out Bits/UInt/SInt[(x bits)]``"
msgstr "``输出位/UInt/SInt[(x 位)]``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``in Bits(3 bits)``"
msgstr "``以位为单位（3 位）``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:65
msgid "Create an input/output of the corresponding type"
msgstr "创建相应类型的输入/输出"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:66
msgid "Bits/UInt/SInt"
msgstr "位/UInt/SInt"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``in(T)``"
msgstr "``在（T）``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
#, fuzzy
msgid "``out(T)``"
msgstr "``输出（T）``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``out UInt(7 bits)``"
msgstr "``输出单元（7 位）``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:70
msgid ""
"For all other data types, you may have to add some brackets around it. "
"Sorry, this is a Scala limitation."
msgstr "对于所有其他数据类型，您可能需要在其周围添加一些括号。抱歉，这是 Scala 的限制。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:71
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:77
msgid "T"
msgstr "时间"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
#, fuzzy
msgid "``master(T)``"
msgstr "``主人（T）``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``slave(T)``"
msgstr "``奴隶（T）``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst
msgid "``master(Bool())``"
msgstr "``主控（布尔（））``"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:75
#, fuzzy
msgid ""
"This syntax is provided by the ``spinal.lib`` library (If you annotate your "
"object with the ``slave`` syntax, then import ``spinal.lib.slave`` instead)."
" T must extend ``IMasterSlave``. Some documentation is available :ref:`here "
"<interface_example_apb>`. You may not actually need the brackets, so "
"``master T`` is fine as well."
msgstr ""
"此语法由``spinal.lib`` 库提供（如果您使用``slave`` 语法注释对象，则改为导入``spinal.lib.slave``）。 T "
"必须扩展``IMasterSlave``。一些文档可用：参考：`此处 "
"<interface_example_apb>`。您实际上可能不需要括号，因此“master T”也可以。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:80
msgid "There are some rules to follow with component interconnection:"
msgstr "组件互连需要遵循一些规则："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:83
msgid ""
"Components can only **read** output and input signals of child components."
msgstr "组件只能**读取**子组件的输出和输入信号。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:84
msgid "Components can read their own output port values (unlike in VHDL)."
msgstr "组件可以读取自己的输出端口值（与 VHDL 不同）。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:87
msgid ""
"If for some reason you need to read signals from far away in the hierarchy "
"(such as for debugging or temporal patches), you can do it by using the "
"value returned by ``some.where.else.theSignal.pull()``"
msgstr ""
"如果由于某种原因您需要从层次结构中较远的位置读取信号（例如用于调试或临时补丁），您可以使用“some.where.else.theSignal.pull()”返回的值来完成此操作"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:91
msgid "Pruned signals"
msgstr "修剪信号"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:93
msgid ""
"SpinalHDL will generate all the named signals and their depedencies, while "
"all the useless anonymous / zero width ones are removed from the RTL "
"generation."
msgstr "SpinalHDL 将生成所有命名信号及其依赖性，而所有无用的匿名/零宽度信号将从 RTL 生成中删除。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:96
msgid ""
"You can collect the list of all the removed ans useless signals via the "
"``printPruned`` and the ``printPrunedIo`` functions on the generated "
"``SpinalReport`` object:"
msgstr ""
"您可以通过生成的“SpinalReport”对象上的“printPruned”和“printPrunedIo”函数收集所有已删除的无用信号的列表："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:126
msgid "Parametrized Hardware (\"Generic\" in VHDL, \"Parameter\" in Verilog)"
msgstr "参数化硬件（VHDL 中的“通用”，Verilog 中的“参数”）"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:128
msgid ""
"If you want to parameterize your component, you can give parameters to the "
"constructor of the component as follows:"
msgstr "如果你想参数化你的组件，你可以将参数传递给组件的构造函数，如下所示："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:146
msgid ""
"If you have several parameters, it is a good practice to give a specific "
"configuration class as follows:"
msgstr "如果您有多个参数，最好给出一个特定的配置类，如下所示："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:159
msgid ""
"You can add functions inside the config, along with requirements on the "
"config attributes:"
msgstr "您可以在配置中添加功能以及对配置属性的要求："
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:173
msgid ""
"This parametrization occurs entirely within the SpinalHDL code-generation "
"during elaboration.  This generates non-generic HDL code. The methods "
"described here do not use VHDL generics or Verilog parameters."
msgstr ""
"这种参数化完全发生在细化过程中的 SpinalHDL 代码生成中。这会生成非通用 HDL 代码。此处描述的方法不使用 VHDL 泛型或 Verilog "
"参数。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:177
msgid ""
"See also :ref:`Blackbox <blackbox>` for more information around support for "
"that mechanism."
msgstr "另请参阅 Blackbox <blackbox> 了解有关该机制支持的更多信息。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:182
msgid "Synthesized component names"
msgstr "合成的组件名称"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:184
msgid ""
"Within a module, each component has a name, called a \"partial name\". The "
"\"full\" name is built by joining every component's parent name with \"_\", "
"for example: ``io_clockDomain_reset``. You can use ``setName`` to replace "
"this convention with a custom name. This is especially useful when "
"interfacing with external components. The other methods are called "
"``getName``, ``setPartialName``, and ``getPartialName`` respectively."
msgstr ""
"在模块内，每个组件都有一个名称，称为“部分名称”。 "
"“完整”名称是通过将每个组件的父名称与“_”连接起来构建的，例如：``io_clockDomain_reset``。您可以使用“setName”将此约定替换为自定义名称。这在与外部组件连接时特别有用。其他方法分别称为“getName”、“setPartialName”和“getPartialName”。"
#: ../../SpinalHDL/Structuring/components_hierarchy.rst:190
msgid ""
"When synthesized, each module gets the name of the Scala class defining it. "
"You can override this as well with ``setDefinitionName``."
msgstr "综合时，每个模块都会获得定义它的 Scala 类的名称。您也可以使用“setDefinitionName”覆盖它。"
#~ msgid "Introduction"
#~ msgstr "介绍"
