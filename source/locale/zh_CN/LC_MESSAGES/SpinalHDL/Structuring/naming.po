
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDLReport-Msgid-Bugs-To:POT-Creation-"
"Date:2023-12-01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-"
"Translator:FULL NAME <EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN "
"<LL@li.org>Plural-Forms:nplurals=1; plural=0;MIME-Version:1.0Content-"
"Type:text/plain; charset=UTF-8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2023-12-02 00:23+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../SpinalHDL/Structuring/naming.rst:2
msgid "Preserving names"
msgstr "保留名字"

#: ../../SpinalHDL/Structuring/naming.rst:4
msgid ""
"This page will describe how SpinalHDL propagate names from the scala code"
" to the generated hardware. Knowing them should enable you to preserve "
"those names as much as possible to generate understandable netlists."
msgstr "本页将描述 SpinalHDL 如何将名称从 scala 代码传播到生成的硬件。了解它们应该使您能够尽可能保留这些名称，以生成可理解的网表。"

#: ../../SpinalHDL/Structuring/naming.rst:7
msgid "Nameable base class"
msgstr "可命名基类"

#: ../../SpinalHDL/Structuring/naming.rst:9
msgid ""
"All the things which can be named in SpinalHDL extends the Nameable base "
"class which."
msgstr "所有可以在 SpinalHDL 中命名的事物都扩展了 Nameable 基类。"

#: ../../SpinalHDL/Structuring/naming.rst:11
msgid "So in practice, the following classes extends Nameable :"
msgstr "因此在实践中，以下类扩展了 Nameable ："

#: ../../SpinalHDL/Structuring/naming.rst:13
msgid "Component"
msgstr "成分"

#: ../../SpinalHDL/Structuring/naming.rst:14
msgid "Area"
msgstr "区域"

#: ../../SpinalHDL/Structuring/naming.rst:15
msgid "Data (UInt, SInt, Bundle, ...)"
msgstr "数据（UInt、SInt、捆绑包……）"

#: ../../SpinalHDL/Structuring/naming.rst:18
msgid "There is a few example of that Nameable API"
msgstr "有一些可命名 API 的示例"

#: ../../SpinalHDL/Structuring/naming.rst:29
msgid "Will generation :"
msgstr "遗嘱代："

#: ../../SpinalHDL/Structuring/naming.rst:41
msgid ""
"In general, you don't realy need to access that API, unless you want to "
"do tricky stuff for debug reasons or for elaboration purposes."
msgstr "一般来说，您实际上并不需要访问该 API，除非您出于调试原因或出于详细说明的目的想要执行一些棘手的操作。"

#: ../../SpinalHDL/Structuring/naming.rst:44
msgid "Name extraction from Scala"
msgstr "从 Scala 中提取名称"

#: ../../SpinalHDL/Structuring/naming.rst:46
msgid ""
"First, since version 1.4.0, SpinalHDL use a scala compiler plugin which "
"can provide a call back each time a new val is defined during the "
"construction of an class."
msgstr "首先，从 1.4.0 版本开始，SpinalHDL 使用 scala 编译器插件，该插件可以在类构造期间每次定义新 val 时提供回调。"

#: ../../SpinalHDL/Structuring/naming.rst:48
msgid ""
"There is a example showing more or less how SpinalHDL itself is "
"implemented :"
msgstr "有一个示例或多或少地展示了 SpinalHDL 本身是如何实现的："

#: ../../SpinalHDL/Structuring/naming.rst:78
#, fuzzy
msgid ""
"Using that ValCallback \"introspection\" feature, SpinalHDL's Component "
"classes are able to be aware of their content and the content's name."
msgstr "使用 ValCallback“内省”功能，SpinalHDL 的组件类能够了解其内容及其名称。"

#: ../../SpinalHDL/Structuring/naming.rst:80
msgid ""
"But this also mean that if you want something to get a name, and you only"
" rely on this automatic naming feature, the reference to your Data (UInt,"
" SInt, ...) instances should be stored somewhere in a Component val."
msgstr ""
"但这也意味着，如果您希望某些东西获得名称，并且仅依赖于此自动命名功能，则对 Data (UInt、SInt、...) 实例的引用应存储在 "
"Component val 中的某个位置。"

#: ../../SpinalHDL/Structuring/naming.rst:82
msgid "For instance :"
msgstr "例如 ："

#: ../../SpinalHDL/Structuring/naming.rst:99
#: ../../SpinalHDL/Structuring/naming.rst:197
#: ../../SpinalHDL/Structuring/naming.rst:234
msgid "Will generate :"
msgstr "将生成："

#: ../../SpinalHDL/Structuring/naming.rst:115
msgid "Area in a Component"
msgstr "组件中的区域"

#: ../../SpinalHDL/Structuring/naming.rst:117
msgid ""
"One important aspect in the naming system is that you can define new "
"namespaces inside components and manipulate"
msgstr "命名系统的一个重要方面是您可以在组件内定义新的名称空间并进行操作"

#: ../../SpinalHDL/Structuring/naming.rst:119
msgid "For instance via Area :"
msgstr "例如通过 Area ："

#: ../../SpinalHDL/Structuring/naming.rst:130
#: ../../SpinalHDL/Structuring/naming.rst:298
#: ../../SpinalHDL/Structuring/naming.rst:383
#: ../../SpinalHDL/Structuring/naming.rst:418
#: ../../SpinalHDL/Structuring/naming.rst:467
#: ../../SpinalHDL/Structuring/naming.rst:521
msgid "Will generate"
msgstr "会生成"

#: ../../SpinalHDL/Structuring/naming.rst:145
msgid "Area in a function"
msgstr "函数中的面积"

#: ../../SpinalHDL/Structuring/naming.rst:147
msgid ""
"You can also define function which will create new Area which will "
"provide a namespace for all its content :"
msgstr "您还可以定义将创建新区域的函数，该区域将为其所有内容提供命名空间："

#: ../../SpinalHDL/Structuring/naming.rst:163
msgid "Which will generate :"
msgstr "这将生成："

#: ../../SpinalHDL/Structuring/naming.rst:179
msgid "Composite in a function"
msgstr "复合在一个函数中"

#: ../../SpinalHDL/Structuring/naming.rst:181
msgid ""
"Added in SpinalHDL 1.5.0, Composite which allow you to create a scope "
"which will use as prefix another Nameable:"
msgstr "SpinalHDL 1.5.0 中添加了 Composite，它允许您创建一个范围，该范围将用作另一个 Nameable 的前缀："

#: ../../SpinalHDL/Structuring/naming.rst:213
msgid "Composite chains"
msgstr "复合链条"

#: ../../SpinalHDL/Structuring/naming.rst:215
msgid "You can also chain composites :"
msgstr "您还可以链接复合材料："

#: ../../SpinalHDL/Structuring/naming.rst:252
msgid "Composite in a Bundle's function"
msgstr "复合在一个Bundle的函数中"

#: ../../SpinalHDL/Structuring/naming.rst:255
#, fuzzy
msgid ""
"This behaviour can be very useful when implementing Bundle utilities. For"
" instance in the spinal.lib.Stream class is defined the following :"
msgstr "在实现 Bundles 实用程序时，此行为非常有用。例如，在 spin.lib.Stream 类中定义如下："

#: ../../SpinalHDL/Structuring/naming.rst:288
msgid "Which allow nested calls while preserving the names :"
msgstr "允许嵌套调用，同时保留名称："

#: ../../SpinalHDL/Structuring/naming.rst:363
msgid "Unamed signal handling"
msgstr "未命名信号处理"

#: ../../SpinalHDL/Structuring/naming.rst:365
msgid ""
"Since 1.5.0, for signal which end up without name, SpinalHDL will find a "
"signal which is driven by that unamed signal and propagate its name. This"
" can produce useful results as long you don't have too large island of "
"unamed stuff."
msgstr ""
"从 1.5.0 开始，对于最终没有名称的信号，SpinalHDL "
"将找到由该未命名信号驱动的信号并传播其名称。只要您没有太多未命名的东西，这就可以产生有用的结果。"

#: ../../SpinalHDL/Structuring/naming.rst:367
msgid ""
"The name attributed to such unamed signal is : _zz_ + "
"drivenSignal.getName()"
msgstr "这种未命名信号的名称是：_zz_ +drivenSignal.getName()"

#: ../../SpinalHDL/Structuring/naming.rst:369
msgid ""
"Note that this naming pattern is also used by the generation backend when"
" they need to breakup some specific expressions or long chain of "
"expression into multiple signals."
msgstr "请注意，当生成后端需要将某些特定表达式或长表达式链分解为多个信号时，也会使用此命名模式。"

#: ../../SpinalHDL/Structuring/naming.rst:372
msgid "Verilog expression splitting"
msgstr "Verilog 表达式分割"

#: ../../SpinalHDL/Structuring/naming.rst:374
msgid ""
"There is an instance of expressions (ex : the + operator) that SpinalHDL "
"need to express in dedicated signals to match the behaviour with the "
"Scala API :"
msgstr "SpinalHDL 需要在专用信号中表达一个表达式实例（例如：+ 运算符），以将行为与 Scala API 相匹配："

#: ../../SpinalHDL/Structuring/naming.rst:404
msgid "Verilog long expression splitting"
msgstr "Verilog 长表达式分割"

#: ../../SpinalHDL/Structuring/naming.rst:406
msgid ""
"There is a instance of how a very long expression chain will be splited "
"up by SpinalHDL :"
msgstr "有一个例子说明 SpinalHDL 如何分割很长的表达链："

#: ../../SpinalHDL/Structuring/naming.rst:448
msgid "When statement condition"
msgstr "When 语句条件"

#: ../../SpinalHDL/Structuring/naming.rst:450
msgid ""
"The `when(cond) { }` statements condition are generated into separated "
"signals named `when_` + fileName + line. A similar thing will also be "
"done for switch statements."
msgstr ""
"`when(cond) { }` 语句条件生成为名为 `when_` + fileName + line 的单独信号。 switch "
"语句也会做类似的事情。"

#: ../../SpinalHDL/Structuring/naming.rst:500
msgid "In last resort"
msgstr "最后一招"

#: ../../SpinalHDL/Structuring/naming.rst:502
msgid ""
"In last resort, if a signal has no name (anonymous signal), SpinalHDL "
"will seek for a named signal which is driven by the anonymous signal, and"
" use it as a name postfix :"
msgstr "最后，如果信号没有名称（匿名信号），SpinalHDL 将寻找由匿名信号驱动的命名信号，并将其用作名称后缀："

#: ../../SpinalHDL/Structuring/naming.rst:542
msgid "This last resort naming skim isn't ideal in all cases, but can help out."
msgstr "最后的命名略读方法并不适合所有情况，但可以提供帮助。"

#: ../../SpinalHDL/Structuring/naming.rst:544
msgid ""
"Note that signal starting with a underscore aren't stored in the "
"Verilator waves (on purpose)"
msgstr "请注意，以下划线开头的信号不会存储在 Verilator 波形中（故意）"

#~ msgid "Introduction"
#~ msgstr "介绍"

