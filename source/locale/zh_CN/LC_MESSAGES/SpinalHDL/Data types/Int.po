msgid ""
msgstr ""
"Project-Id-Version: SpinalHDLReport-Msgid-Bugs-To:POT-Creation-Date:2023-12-"
"01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME "
"<EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN <LL@li.org>Plural-"
"Forms:nplurals=1; plural=0;MIME-Version:1.0Content-Type:text/plain; "
"charset=UTF-8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESSPOT-Creation-Date:2023-12-02 00:23+0800PO-"
"Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME <EMAIL@ADDRESS"
">Language-Team:LANGUAGE <LL@li.org>MIME-Version:1.0Content-Type:text/plain; "
"charset=UTF-8\n"
"PO-Revision-Date: 2024-01-13 05:06+0000\n"
"Last-Translator: tsy0123 <675526215@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"spinaldoc-rtd/spinalhdldata-typesint/zh_Hans/>\n"
"Language: zh_CN\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bitGenerated-By:Babel 2.13.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.4-dev\n"

#: ../../SpinalHDL/Data types/Int.rst:4 types/Int.rst:620
msgid "UInt/SInt"
msgstr "UInt/SInt"

#: ../../SpinalHDL/Data types/Int.rst:6
msgid ""
"The ``UInt``/``SInt`` types are vectors of bits interpreted as two's "
"complement unsigned/signed integers. They can do what ``Bits`` can do, with "
"the addition of unsigned/signed integer arithmetic and comparisons."
msgstr ""
"``UInt``/``SInt`` 类型用于表达二进制补码无符号/有符号整数的位向量。"
"他们可以做 ``Bits`` 相同的事情，但具有无符号/有符号整数算术和比较。"

#: ../../SpinalHDL/Data types/Int.rst:10
msgid "Declaration"
msgstr "声明"

#: ../../SpinalHDL/Data types/Int.rst:12
msgid ""
"The syntax to declare an integer is as follows:  (everything between [] is "
"optional)"
msgstr "以下是声明一个整数的语法：（[] 中的内容是可选的）"

#: ../../SpinalHDL/Data types/Int.rst:18
msgid "Syntax"
msgstr "语法"

#: ../../SpinalHDL/Data types/Int.rst:19 types/Int.rst:78 types/Int.rst:179
#: types/Int.rst:243 types/Int.rst:292 types/Int.rst:378 types/Int.rst:480
#: types/Int.rst:674
msgid "Description"
msgstr "描述"

#: ../../SpinalHDL/Data types/Int.rst
msgid "UInt[()]"
msgstr "UInt[()]"

#: ../../SpinalHDL/Data types/Int.rst
msgid "SInt[()]"
msgstr "SInt[()]"

#: ../../SpinalHDL/Data types/Int.rst:22
msgid "Create an unsigned/signed integer, bits count is inferred"
msgstr "创建一个无符号/有符号整数，自动推断位数"

#: ../../SpinalHDL/Data types/Int.rst
msgid "UInt(x bits)"
msgstr "UInt(x bits)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "SInt(x bits)"
msgstr "SInt(x bits)"

#: ../../SpinalHDL/Data types/Int.rst:25
msgid "Create an unsigned/signed integer with x bits"
msgstr "创建一个 x 位的无符号/有符号整数"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U(value: Int[,x bits])"
msgstr "U(value: Int[,x bits])"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U(value: BigInt[,x bits])"
msgstr "U(value: BigInt[,x bits])"

#: ../../SpinalHDL/Data types/Int.rst
msgid "S(value: Int[,x bits])"
msgstr "S(value: Int[,x bits])"

#: ../../SpinalHDL/Data types/Int.rst
msgid "S(value: BigInt[,x bits])"
msgstr "S(value: BigInt[,x bits])"

#: ../../SpinalHDL/Data types/Int.rst types/Int.rst:30
msgid "Create an unsigned/signed integer assigned with 'value'"
msgstr "创建一个无符号/有符号整数，并将其分配给 'value'"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U\"[[size']base]value\""
msgstr "U\"[[size']base]value\""

#: ../../SpinalHDL/Data types/Int.rst
msgid "S\"[[size']base]value\""
msgstr "S\"[[size']base]value\""

#: ../../SpinalHDL/Data types/Int.rst
msgid "(base: 'h', 'd', 'o', 'b')"
msgstr "(base: 'h', 'd', 'o', 'b')"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U([x bits,] elements: Element*)"
msgstr "U([x bits,] elements: Element*)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "S([x bits,] elements: Element*)"
msgstr "S([x bits,] elements: Element*)"

#: ../../SpinalHDL/Data types/Int.rst:37
msgid ""
"Create an unsigned integer assigned with the value specified by "
":ref:`elements <element>`"
msgstr "创建一个无符号整数，并为其赋值一个由 :ref:`elements <element>` 指定的值"

#: ../../SpinalHDL/Data types/Int.rst:66
msgid "Operators"
msgstr "运算符"

#: ../../SpinalHDL/Data types/Int.rst:68
msgid ""
"The following operators are available for the ``UInt`` and ``SInt`` types:"
msgstr "以下运算符可用于 ``UInt`` 和 ``SInt`` 类型："

#: ../../SpinalHDL/Data types/Int.rst:71
msgid "Logic"
msgstr "逻辑运算"

#: ../../SpinalHDL/Data types/Int.rst:77 types/Int.rst:178 types/Int.rst:242
#: types/Int.rst:291 types/Int.rst:377 types/Int.rst:479
msgid "Operator"
msgstr "运算符"

#: ../../SpinalHDL/Data types/Int.rst:79 types/Int.rst:244
msgid "Return type"
msgstr "返回类型"

#: ../../SpinalHDL/Data types/Int.rst:80 types/Int.rst:208
msgid "~x"
msgstr "~x"

#: ../../SpinalHDL/Data types/Int.rst:81
msgid "Bitwise NOT"
msgstr "按位非"

#: ../../SpinalHDL/Data types/Int.rst:82 types/Int.rst:106 types/Int.rst:115
#: types/Int.rst:118 types/Int.rst:122 types/Int.rst:126 types/Int.rst:204
#: types/Int.rst:210 types/Int.rst:516
msgid "T(w(x) bits)"
msgstr "T(w(x) bits)"

#: ../../SpinalHDL/Data types/Int.rst:83
msgid "x & y"
msgstr "x & y"

#: ../../SpinalHDL/Data types/Int.rst:84
msgid "Bitwise AND"
msgstr "按位与"

#: ../../SpinalHDL/Data types/Int.rst:85 types/Int.rst:88 types/Int.rst:91
#: types/Int.rst:183 types/Int.rst:189 types/Int.rst:192 types/Int.rst:198
msgid "T(max(w(x), w(y)) bits)"
msgstr "T(max(w(x), w(y)) bits)"

#: ../../SpinalHDL/Data types/Int.rst:86
msgid "x | y"
msgstr "x | y"

#: ../../SpinalHDL/Data types/Int.rst:87
msgid "Bitwise OR"
msgstr "按位或"

#: ../../SpinalHDL/Data types/Int.rst:89
msgid "x ^ y"
msgstr "x ^ y"

#: ../../SpinalHDL/Data types/Int.rst:90
msgid "Bitwise XOR"
msgstr "按位异或"

#: ../../SpinalHDL/Data types/Int.rst:92
msgid "x.xorR"
msgstr "x.xorR"

#: ../../SpinalHDL/Data types/Int.rst:93
msgid "XOR all bits of x (reduction operator)"
msgstr "对 x 的所有位进行异或（缩减运算符）"

#: ../../SpinalHDL/Data types/Int.rst:94 types/Int.rst:97 types/Int.rst:100
#: types/Int.rst:247 types/Int.rst:250 types/Int.rst:253 types/Int.rst:256
#: types/Int.rst:259 types/Int.rst:262 types/Int.rst:382 types/Int.rst:385
#: types/Int.rst:403 types/Int.rst:406 types/Int.rst:409
msgid "Bool"
msgstr "Bool"

#: ../../SpinalHDL/Data types/Int.rst:95
msgid "x.orR"
msgstr "x.orR"

#: ../../SpinalHDL/Data types/Int.rst:96
msgid "OR all bits of x (reduction operator)"
msgstr "对x 的所有位进行或操作（缩减运算符）"

#: ../../SpinalHDL/Data types/Int.rst:98
msgid "x.andR"
msgstr "x.andR"

#: ../../SpinalHDL/Data types/Int.rst:99
msgid "AND all bits of x (reduction operator)"
msgstr "对 x 的所有位进行与操作（缩减运算符）"

#: ../../SpinalHDL/Data types/Int.rst:101 types/Int.rst:104
msgid "x \\>\\> y"
msgstr "x \\>\\> y"

#: ../../SpinalHDL/Data types/Int.rst:102
msgid "Arithmetic shift right, y : Int"
msgstr "算术右移，y : Int"

#: ../../SpinalHDL/Data types/Int.rst:103
msgid "T(w(x) - y bits)"
msgstr "T(w(x) - y bits)"

#: ../../SpinalHDL/Data types/Int.rst:105
msgid "Arithmetic shift right, y : UInt"
msgstr "算术右移，y : UInt"

#: ../../SpinalHDL/Data types/Int.rst:107 types/Int.rst:110
msgid "x \\<\\< y"
msgstr "x \\<\\< y"

#: ../../SpinalHDL/Data types/Int.rst:108
msgid "Arithmetic shift left, y : Int"
msgstr "算术左移，y : Int"

#: ../../SpinalHDL/Data types/Int.rst:109
msgid "T(w(x) + y bits)"
msgstr "T(w(x) + y bits)"

#: ../../SpinalHDL/Data types/Int.rst:111
msgid "Arithmetic shift left, y : UInt"
msgstr "算术左移，y : UInt"

#: ../../SpinalHDL/Data types/Int.rst:112
msgid "T(w(x) + max(y) bits)"
msgstr "T(w(x) + max(y) bits)"

#: ../../SpinalHDL/Data types/Int.rst:113
msgid "x \\|\\>\\> y"
msgstr "x \\|\\>\\> y"

#: ../../SpinalHDL/Data types/Int.rst:114
msgid "Logical shift right, y : Int/UInt"
msgstr "逻辑右移，y : Int/UInt"

#: ../../SpinalHDL/Data types/Int.rst:116
msgid "x \\|\\<\\< y"
msgstr "x \\|\\<\\< y"

#: ../../SpinalHDL/Data types/Int.rst:117
msgid "Logical shift left, y : Int/UInt"
msgstr "逻辑左移，y : Int/UInt"

#: ../../SpinalHDL/Data types/Int.rst:119
msgid "x.rotateLeft(y)"
msgstr "x.rotateLeft(y)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Logical left rotation, y : UInt/Int"
msgstr "逻辑循环左移，y : UInt/Int"

#: ../../SpinalHDL/Data types/Int.rst
msgid "The width of y is constrained to the width of log2Up(x) or less"
msgstr "y 的宽度被限制为 log2Up(x) 的宽度或更小"

#: ../../SpinalHDL/Data types/Int.rst:123
msgid "x.rotateRight(y)"
msgstr "x.rotateRight(y)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Logical right rotation, y : UInt/Int"
msgstr "逻辑循环右移，y : UInt/Int"

#: ../../SpinalHDL/Data types/Int.rst:127
msgid "x.clearAll[()]"
msgstr "x.clearAll[()]"

#: ../../SpinalHDL/Data types/Int.rst:128
msgid "Clear all bits"
msgstr "清零所有位"

#: ../../SpinalHDL/Data types/Int.rst:129 types/Int.rst:132 types/Int.rst:135
#: types/Int.rst:138
msgid "*modifies x*"
msgstr "*修改x*"

#: ../../SpinalHDL/Data types/Int.rst:130
msgid "x.setAll[()]"
msgstr "x.setAll[()]"

#: ../../SpinalHDL/Data types/Int.rst:131
msgid "Set all bits"
msgstr "将所有的位设置为1"

#: ../../SpinalHDL/Data types/Int.rst:133
msgid "x.setAllTo(value : Boolean)"
msgstr "x.setAllTo(value : Boolean)"

#: ../../SpinalHDL/Data types/Int.rst:134
msgid "Set all bits to the given Boolean value"
msgstr "将所有位设置为给定的布尔值（Scala Boolean）"

#: ../../SpinalHDL/Data types/Int.rst:136
msgid "x.setAllTo(value : Bool)"
msgstr "x.setAllTo(value : Bool)"

#: ../../SpinalHDL/Data types/Int.rst:137
msgid "Set all bits to the given Bool value"
msgstr "将所有位设置为给定的布尔值（Spinal Bool）"

#: ../../SpinalHDL/Data types/Int.rst:142
msgid ""
"Notice the difference in behaviour between ``x >> 2`` (result 2 bit narrower"
" than x) and ``x >> U(2)`` (keeping width) due to the Scala type of "
":code:`y`."
msgstr ""
"请注意由于 :code:`y` 的 Scala 类型原因， ``x >> 2`` （结果比 x 窄 2 位）和 ``"
"x >> U(2)``（保持宽度）之间的行为有差异。"

#: ../../SpinalHDL/Data types/Int.rst:145
msgid ""
"In the first case \"2\" is an ``Int`` (which can be seen as an \"elaboration"
" integer constant\"), and in the second case it is a hardware signal (type "
"``UInt``) that may or may not be a constant."
msgstr ""
"在第一种情况下，“2”是一个 ``Int`` "
"的值（可以看作是“实例细化整数常量”），在第二种情况下，它是一个硬件信号（ "
"``UInt`` 类型）这也可能不是一个常数。"

#: ../../SpinalHDL/Data types/Int.rst:173
msgid "Arithmetic"
msgstr "算术运算"

#: ../../SpinalHDL/Data types/Int.rst:180 types/Int.rst:293 types/Int.rst:379
#: types/Int.rst:481 types/Int.rst:674
msgid "Return"
msgstr "返回类型"

#: ../../SpinalHDL/Data types/Int.rst:181
msgid "x + y"
msgstr "x + y"

#: ../../SpinalHDL/Data types/Int.rst:182
msgid "Addition"
msgstr "加法"

#: ../../SpinalHDL/Data types/Int.rst:184
msgid "x +^ y"
msgstr "x +^ y"

#: ../../SpinalHDL/Data types/Int.rst:185
msgid "Addition with carry"
msgstr "带进位的加法"

#: ../../SpinalHDL/Data types/Int.rst:186 types/Int.rst:195
msgid "T(max(w(x), w(y)) + 1 bits)"
msgstr "T(max(w(x), w(y)) + 1 bits)"

#: ../../SpinalHDL/Data types/Int.rst:187
msgid "x +| y"
msgstr "x +| y"

#: ../../SpinalHDL/Data types/Int.rst:188
msgid ""
"Addition of addend with `saturation`_ (see also `T.maxValue` and "
"`T.minValue`)"
msgstr "添加带有饱和（ `saturation`_）的加数（另请参见 `T.maxValue` 和 `T.minValue`）"

#: ../../SpinalHDL/Data types/Int.rst:190
msgid "x - y"
msgstr "x - y"

#: ../../SpinalHDL/Data types/Int.rst:191
msgid "Subtraction"
msgstr "减法"

#: ../../SpinalHDL/Data types/Int.rst:193
msgid "x -^ y"
msgstr "x -^ y"

#: ../../SpinalHDL/Data types/Int.rst:194
msgid "Subtraction with carry"
msgstr "带进位的减法"

#: ../../SpinalHDL/Data types/Int.rst:196
msgid "x -| y"
msgstr "x -| y"

#: ../../SpinalHDL/Data types/Int.rst:197
msgid ""
"Subtraction of subtrahend with `saturation`_ (see also `T.minValue` and "
"`T.maxValue`)"
msgstr "带饱和（ `saturation`_）的减法（另请参见 `T.minValue` 和 `T.maxValue`）"

#: ../../SpinalHDL/Data types/Int.rst:199
msgid "x * y"
msgstr "x * y"

#: ../../SpinalHDL/Data types/Int.rst:200
msgid "Multiplication"
msgstr "乘法"

#: ../../SpinalHDL/Data types/Int.rst:201
msgid "T(w(x) + w(y)) bits)"
msgstr "T(w(x) + w(y)) bits)"

#: ../../SpinalHDL/Data types/Int.rst:202
msgid "x / y"
msgstr "x / y"

#: ../../SpinalHDL/Data types/Int.rst:203
msgid "Division"
msgstr "除法"

#: ../../SpinalHDL/Data types/Int.rst:205
msgid "x % y"
msgstr "x % y"

#: ../../SpinalHDL/Data types/Int.rst:206
msgid "Modulo"
msgstr "求模运算"

#: ../../SpinalHDL/Data types/Int.rst:207
msgid "T(min(w(x), w(y)) bits)"
msgstr "T(min(w(x), w(y)) bits)"

#: ../../SpinalHDL/Data types/Int.rst:209
msgid "Unary One's compliment, Bitwise NOT"
msgstr "一元补码运算，按位非（NOT）"

#: ../../SpinalHDL/Data types/Int.rst:211
msgid "-x"
msgstr "-x"

#: ../../SpinalHDL/Data types/Int.rst:212
msgid "Unary Two's compliment of SInt type.  Not available for UInt."
msgstr "SInt 类型的一元二进制补码。不适用于 UInt。"

#: ../../SpinalHDL/Data types/Int.rst:213 types/Int.rst:302 types/Int.rst:311
msgid "SInt(w(x) bits)"
msgstr "SInt(w(x) bits)"

#: ../../SpinalHDL/Data types/Int.rst:233
msgid ""
"Notice how simulation assertions are made here (with ``===``), as opposed to"
" elaboration assertions in the previous example (with ``==``)."
msgstr "请注意此处如何进行仿真时判断（使用 ``===``），而不是前面示例中的细化时判断（"
"使用 ``==``）。"

#: ../../SpinalHDL/Data types/Int.rst:237
msgid "Comparison"
msgstr "比较运算"

#: ../../SpinalHDL/Data types/Int.rst:245
msgid "x === y"
msgstr "x === y"

#: ../../SpinalHDL/Data types/Int.rst:246
msgid "Equality"
msgstr "等价性判断"

#: ../../SpinalHDL/Data types/Int.rst:248
msgid "x =/= y"
msgstr "x =/= y"

#: ../../SpinalHDL/Data types/Int.rst:249
msgid "Inequality"
msgstr "不等价判断运算"

#: ../../SpinalHDL/Data types/Int.rst:251
msgid "x > y"
msgstr "x > y"

#: ../../SpinalHDL/Data types/Int.rst:252
msgid "Greater than"
msgstr "大于"

#: ../../SpinalHDL/Data types/Int.rst:254
msgid "x >= y"
msgstr "x >= y"

#: ../../SpinalHDL/Data types/Int.rst:255
msgid "Greater than or equal"
msgstr "大于或等于"

#: ../../SpinalHDL/Data types/Int.rst:257
msgid "x < y"
msgstr "x < y"

#: ../../SpinalHDL/Data types/Int.rst:258
msgid "Less than"
msgstr "小于"

#: ../../SpinalHDL/Data types/Int.rst:260
msgid "x <= y"
msgstr "x <= y"

#: ../../SpinalHDL/Data types/Int.rst:261
msgid "Less than or equal"
msgstr "小于或等于"

#: ../../SpinalHDL/Data types/Int.rst:282
msgid ""
"When comparing ``UInt`` values in a way that allows for \"wraparound\" "
"behavior, meaning that the values will \"wrap around\" to the minimum value "
"when they exceed the maximum value. The ``wrap`` method of ``UInt`` can be "
"used as ``x.wrap < y`` for ``UInt`` variables ``x, y``, the result will be "
"true if ``x`` is less than ``y`` in the wraparound sense."
msgstr ""
"当比较 ``UInt`` 值时，允许 \"环绕\" 行为，即当值超过最大值时，它们将\"环绕\" "
"到最小值。在这种情况下，可以使用 ``UInt`` 的 wrap 方法。对于 ``UInt`` 变量 "
"x、y，如果 x.wrap < y，则如果 x 在环绕意义上小于 y，结果为真。"

#: ../../SpinalHDL/Data types/Int.rst:286
msgid "Type cast"
msgstr "类型转换"

#: ../../SpinalHDL/Data types/Int.rst:294
msgid "x.asBits"
msgstr "x.asBits"

#: ../../SpinalHDL/Data types/Int.rst:295
msgid "Binary cast to Bits"
msgstr "二进制转换为 Bits"

#: ../../SpinalHDL/Data types/Int.rst:296
msgid "Bits(w(x) bits)"
msgstr "Bits(w(x) bits)"

#: ../../SpinalHDL/Data types/Int.rst:297
msgid "x.asUInt"
msgstr "x.asUInt"

#: ../../SpinalHDL/Data types/Int.rst:298
msgid "Binary cast to UInt"
msgstr "二进制转换为 UInt"

#: ../../SpinalHDL/Data types/Int.rst:299 types/Int.rst:314
msgid "UInt(w(x) bits)"
msgstr "UInt(w(x) bits)"

#: ../../SpinalHDL/Data types/Int.rst:300
msgid "x.asSInt"
msgstr "x.asSInt"

#: ../../SpinalHDL/Data types/Int.rst:301
msgid "Binary cast to SInt"
msgstr "二进制转换为SInt"

#: ../../SpinalHDL/Data types/Int.rst:303
msgid "x.asBools"
msgstr "x.asBools"

#: ../../SpinalHDL/Data types/Int.rst:304
msgid "Cast into a array of Bool"
msgstr "转换为 Bool 数组"

#: ../../SpinalHDL/Data types/Int.rst:305
msgid "Vec(Bool(), w(x))"
msgstr "Vec(Bool(), w(x))"

#: ../../SpinalHDL/Data types/Int.rst:306
msgid "x.asBool"
msgstr "x.asBool"

#: ../../SpinalHDL/Data types/Int.rst:307
msgid "Extract LSB of :code:`x`"
msgstr "提取 :code:`x` 的 LSB"

#: ../../SpinalHDL/Data types/Int.rst:308
msgid "Bool(x.lsb)"
msgstr "Bool(x.lsb)"

#: ../../SpinalHDL/Data types/Int.rst:309
msgid "S(x: T)"
msgstr "S(x: T)"

#: ../../SpinalHDL/Data types/Int.rst:310
msgid "Cast a Data into a SInt"
msgstr "将数据转换为 SInt"

#: ../../SpinalHDL/Data types/Int.rst:312
msgid "U(x: T)"
msgstr "U(x: T)"

#: ../../SpinalHDL/Data types/Int.rst:313
msgid "Cast a Data into an UInt"
msgstr "将数据转换为 UInt"

#: ../../SpinalHDL/Data types/Int.rst:315
msgid "x.intoSInt"
msgstr "x.intoSInt"

#: ../../SpinalHDL/Data types/Int.rst:316
msgid "Convert to SInt expanding sign bit"
msgstr "转换为 SInt，扩展符号位"

#: ../../SpinalHDL/Data types/Int.rst:317
msgid "SInt(w(x) + 1 bits)"
msgstr "SInt(w(x) + 1 bits)"

#: ../../SpinalHDL/Data types/Int.rst:318
msgid "myUInt.twoComplement(en: Bool)"
msgstr "myUInt.twoComplement(en: Bool)"

#: ../../SpinalHDL/Data types/Int.rst:319
msgid ""
"Generate two's complement of number if ``en`` is ``True``, unchanged "
"otherwise. (``en`` makes result negative)"
msgstr "如果 ``en`` 为真，则生成二进制补码的数值，否则不变。（``en`` 使结果为负数）"

#: ../../SpinalHDL/Data types/Int.rst:320
msgid "SInt(w(myUInt) + 1, bits)"
msgstr "SInt(w(myUInt) + 1, bits)"

#: ../../SpinalHDL/Data types/Int.rst:321
msgid "mySInt.abs"
msgstr "mySInt.abs"

#: ../../SpinalHDL/Data types/Int.rst:322
msgid "Return the absolute value as a UInt value"
msgstr "以 UInt 值形式返回绝对值"

#: ../../SpinalHDL/Data types/Int.rst:323 types/Int.rst:326
msgid "UInt(w(mySInt) bits)"
msgstr "UInt(w(mySInt) bits)"

#: ../../SpinalHDL/Data types/Int.rst:324
msgid "mySInt.abs(en: Bool)"
msgstr "mySInt.abs(en: Bool)"

#: ../../SpinalHDL/Data types/Int.rst:325
msgid ""
"Return the absolute value as a UInt value when ``en`` is ``True``, otherwise"
" just reinterpret bits as unsigned"
msgstr "当 ``en`` 为真时，返回UInt类型的绝对值，否则，只需将位解释为无符号数。"

#: ../../SpinalHDL/Data types/Int.rst:327
msgid "mySInt.absWithSym"
msgstr "mySInt.absWithSym"

#: ../../SpinalHDL/Data types/Int.rst:328
msgid ""
"Return the absolute value of the UInt value with symmetric, shrink 1 bit"
msgstr "返回对称的 UInt 值的绝对值，缩小 1 位"

#: ../../SpinalHDL/Data types/Int.rst:329
msgid "UInt(w(mySInt) - 1 bits)"
msgstr "UInt(w(mySInt) - 1 bits)"

#: ../../SpinalHDL/Data types/Int.rst:332
msgid ""
"To cast a ``Bool``, a ``Bits``, or an ``SInt`` into a ``UInt``, you can use "
"``U(something)``. To cast things into an ``SInt``, you can use "
"``S(something)``."
msgstr ""
"要将一个 ``Bool``、一个 ``Bits`` 或一个 ``SInt`` 转换为一个 ``UInt``，"
"可以使用 ``U(something)``。要将东西转换为一个 ``SInt``，可以使用 "
"``S(something)``。"

#: ../../SpinalHDL/Data types/Int.rst:368
msgid "Bit extraction"
msgstr "位提取"

#: ../../SpinalHDL/Data types/Int.rst:370
msgid ""
"All of the bit extraction operations can be used to read a bit / group of "
"bits. Like in other HDLs the extraction operators can also be used to assign"
" a part of a ``UInt`` / ``SInt`` ."
msgstr "所有位提取操作均可用于读取一个位/一组位。与其他 HDL 一样，提取运算符也对 "
"``UInt`` / ``SInt`` 的一部分赋值。"

#: ../../SpinalHDL/Data types/Int.rst:380
msgid "x(y: Int)"
msgstr "x(y: Int)"

#: ../../SpinalHDL/Data types/Int.rst:381
msgid "Static bit access of y-th bit"
msgstr "静态访问第 y 位"

#: ../../SpinalHDL/Data types/Int.rst:383
msgid "x(x: UInt)"
msgstr "x(x: UInt)"

#: ../../SpinalHDL/Data types/Int.rst:384
msgid "Variable bit access of y-th bit"
msgstr "访问第 y 位，这里y为可变的信号"

#: ../../SpinalHDL/Data types/Int.rst:386
msgid "x(offset: Int, width bits)"
msgstr "x(offset: Int, width bits)"

#: ../../SpinalHDL/Data types/Int.rst:387
msgid "Fixed part select of fixed width, offset is LSB index"
msgstr "固定地选择偏移量和宽度，``offset`` 为选择信号中LSB的索引"

#: ../../SpinalHDL/Data types/Int.rst:388 types/Int.rst:391
msgid "Bits(width bits)"
msgstr "Bits(width bits)"

#: ../../SpinalHDL/Data types/Int.rst:389
msgid "x(offset: UInt, width bits)"
msgstr "x(offset: UInt, width bits)"

#: ../../SpinalHDL/Data types/Int.rst:390
msgid "Variable part-select of fixed width, offset is LSB index"
msgstr "选择偏移量可变和宽度固定的信号，``offset`` 为选择信号中LSB的索引 "
"（可为另一信号）"

#: ../../SpinalHDL/Data types/Int.rst:392
msgid "x(range: Range)"
msgstr "x(range: Range)"

#: ../../SpinalHDL/Data types/Int.rst:393
msgid "Access a :ref:`range <range>` of bits. Ex : myBits(4 downto 2)"
msgstr "访问Bits的 :ref:`范围 <range>` 。例如：myBits(4 downto 2)"

#: ../../SpinalHDL/Data types/Int.rst:394
msgid "Bits(range.size bits)"
msgstr "Bits(range.size bits)"

#: ../../SpinalHDL/Data types/Int.rst:395
msgid "x.subdivideIn(y slices, [strict: Boolean])"
msgstr "x.subdivideIn(y slices, [strict: Boolean])"

#: ../../SpinalHDL/Data types/Int.rst:396
msgid "Subdivide x into y slices, y: Int"
msgstr "将x分割为y片，y: Int"

#: ../../SpinalHDL/Data types/Int.rst:397
msgid "Vec(Bits(...), y)"
msgstr "Vec(Bits(...), y)"

#: ../../SpinalHDL/Data types/Int.rst:398
msgid "x.subdivideIn(y bits, [strict: Boolean])"
msgstr "x.subdivideIn(y bits, [strict: Boolean])"

#: ../../SpinalHDL/Data types/Int.rst:399
msgid "Subdivide x in multiple slices of y bits, y: Int"
msgstr "将 x 分割为 y 位的多个切片，y: Int"

#: ../../SpinalHDL/Data types/Int.rst:400
msgid "Vec(Bits(y bit), ...)"
msgstr "Vec(Bits(y bit), ...)"

#: ../../SpinalHDL/Data types/Int.rst:401
msgid "x.msb"
msgstr "x.msb"

#: ../../SpinalHDL/Data types/Int.rst:402
msgid "Access most significant bit of x (highest index, sign bit for SInt)"
msgstr "访问 x 的最高有效位（最高索引，SInt 的符号位）"

#: ../../SpinalHDL/Data types/Int.rst:404
msgid "x.lsb"
msgstr "x.lsb"

#: ../../SpinalHDL/Data types/Int.rst:405
msgid "Access lowest significant bit of x (index 0)"
msgstr "访问 x 的最低有效位（索引 0）"

#: ../../SpinalHDL/Data types/Int.rst:407
msgid "mySInt.sign"
msgstr "mySInt.sign"

#: ../../SpinalHDL/Data types/Int.rst:408
msgid "Access most sign bit, only SInt"
msgstr "访问最高符号位，仅适用于 SInt。"

#: ../../SpinalHDL/Data types/Int.rst:413
msgid "Some basic examples:"
msgstr "一些基本示例："

#: ../../SpinalHDL/Data types/Int.rst:442
msgid "Subdivide details"
msgstr "分割细节"

#: ../../SpinalHDL/Data types/Int.rst:444
msgid ""
"Both overloads of ``subdivideIn`` have an optional parameter ``strict`` "
"(i.e. ``subdivideIn(slices: SlicesCount, strict: Boolean = true)``). If "
"``strict`` is ``true`` an error will be raised if the input could not be "
"divided into equal parts. If set to ``false`` the last element may be "
"smaller than the other (equal sized) elements."
msgstr ""
"两个 ``subdivideIn`` 函数的所有参数都有一个可选参数 ``strict`` 参数（即 "
"``subdivideIn(slices: SlicesCount, strict: Boolean = true)`` ）。如果 "
"``strict`` 为 ``true``，则如果输入无法等分，将引发错误。如果设置为 "
"``false``，最后一个元素可能比其他（大小相等）元素小。"

#: ../../SpinalHDL/Data types/Int.rst:470
msgid "Misc"
msgstr "杂项"

#: ../../SpinalHDL/Data types/Int.rst:472
msgid ""
"In contrast to the bit extraction operations listed above it's not possible "
"to use the return values to assign to the original signal."
msgstr "与上面列出的位提取操作相反，上述函数不能使用其返回值给原始信号赋值。"

#: ../../SpinalHDL/Data types/Int.rst:482
msgid "x.getWidth"
msgstr "x.getWidth"

#: ../../SpinalHDL/Data types/Int.rst:483
msgid "Return bitcount"
msgstr "返回位数"

#: ../../SpinalHDL/Data types/Int.rst:484 types/Int.rst:487
msgid "Int"
msgstr "Int"

#: ../../SpinalHDL/Data types/Int.rst:485
msgid "x.high"
msgstr "x.high"

#: ../../SpinalHDL/Data types/Int.rst:486
msgid "Return the index of the MSB (highest allowed index for Int)"
msgstr "返回 MSB 的索引（对Int来说是允许的最高索引）"

#: ../../SpinalHDL/Data types/Int.rst:488
msgid "x.bitsRange"
msgstr "x.bitsRange"

#: ../../SpinalHDL/Data types/Int.rst:489
msgid "Return the range (0 to x.high)"
msgstr "返回范围（0 到 x.high）"

#: ../../SpinalHDL/Data types/Int.rst:490 types/Int.rst:499
msgid "Range"
msgstr "范围"

#: ../../SpinalHDL/Data types/Int.rst:491
msgid "x.minValue"
msgstr "x.minValue"

#: ../../SpinalHDL/Data types/Int.rst:492
msgid "Lowest possible value of x (e.g. 0 for UInt)"
msgstr "x 的最低可能值（例如 UInt 为 0）"

#: ../../SpinalHDL/Data types/Int.rst:493 types/Int.rst:496
msgid "BigInt"
msgstr "BigInt"

#: ../../SpinalHDL/Data types/Int.rst:494
msgid "x.maxValue"
msgstr "x.maxValue"

#: ../../SpinalHDL/Data types/Int.rst:495
msgid "Highest possible value of x"
msgstr "x 的最大可能值"

#: ../../SpinalHDL/Data types/Int.rst:497
msgid "x.valueRange"
msgstr "x.valueRange"

#: ../../SpinalHDL/Data types/Int.rst:498
msgid ""
"Return the range from minimum to maximum possible value of x (x.minValue to "
"x.maxValue)."
msgstr "返回 x 的最小到最大可能值的范围（x.minValue 到 x.maxValue）。"

#: ../../SpinalHDL/Data types/Int.rst:500
msgid "x ## y"
msgstr "x ## y"

#: ../../SpinalHDL/Data types/Int.rst:501
msgid "Concatenate, x->high, y->low"
msgstr "连接Bits，x->高位，y->低位"

#: ../../SpinalHDL/Data types/Int.rst:502
msgid "Bits(w(x) + w(y) bits)"
msgstr "Bits(w(x) + w(y) bits)"

#: ../../SpinalHDL/Data types/Int.rst:503
msgid "x #* n"
msgstr "x #* n"

#: ../../SpinalHDL/Data types/Int.rst:504
msgid "Repeat x n-times"
msgstr "n次重复x并合并"

#: ../../SpinalHDL/Data types/Int.rst:505
msgid "Bits(w(x) * n bits)"
msgstr "Bits(w(x) * n bits)"

#: ../../SpinalHDL/Data types/Int.rst:506
msgid "x @@ y"
msgstr "x @@ y"

#: ../../SpinalHDL/Data types/Int.rst:507
msgid "Concatenate x:T with y:Bool/SInt/UInt"
msgstr "将 x:T 与 y:Bool/SInt/UInt 连接"

#: ../../SpinalHDL/Data types/Int.rst:508
msgid "T(w(x) + w(y) bits)"
msgstr "T(w(x) + w(y) bits)"

#: ../../SpinalHDL/Data types/Int.rst:509
msgid "x.resize(y)"
msgstr "x.resize(y)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Return a resized copy of x, if enlarged, it is filled with zero"
msgstr "返回 x 调整大小后的副本，如果位宽变大，则用零填充其他位"

#: ../../SpinalHDL/Data types/Int.rst
msgid "for UInt or filled with the sign for SInt, y: Int"
msgstr "对于 UInt 或 SInt（用符号填充）操作, y: Int"

#: ../../SpinalHDL/Data types/Int.rst:512
msgid "T(y bits)"
msgstr "T(y bits)"

#: ../../SpinalHDL/Data types/Int.rst:513
msgid "x.resized"
msgstr "x.resized"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Return a version of x which is allowed to be automatically"
msgstr "返回自动位宽调整后的 x"

#: ../../SpinalHDL/Data types/Int.rst
msgid "resized where needed"
msgstr "根据需要调整大小"

#: ../../SpinalHDL/Data types/Int.rst:517
msgid "x.expand"
msgstr "x.expand"

#: ../../SpinalHDL/Data types/Int.rst:518
msgid "Return x with 1 bit expand"
msgstr "返回 x 并进行 1 位扩展"

#: ../../SpinalHDL/Data types/Int.rst:519
msgid "T(w(x)+1 bits)"
msgstr "T(w(x)+1 bits)"

#: ../../SpinalHDL/Data types/Int.rst:520
msgid "x.getZero"
msgstr "x.getZero"

#: ../../SpinalHDL/Data types/Int.rst:521
msgid ""
"Return a new instance of type T that is assigned a constant value of zeros "
"the same width as x."
msgstr "返回类型 T 的新实例，该实例被分配与 x 相同宽度的零值（常量）。"

#: ../../SpinalHDL/Data types/Int.rst:522
msgid "T(0, w(x) bits).clearAll()"
msgstr "T(0, w(x) bits).clearAll()"

#: ../../SpinalHDL/Data types/Int.rst:523
msgid "x.getAllTrue"
msgstr "x.getAllTrue"

#: ../../SpinalHDL/Data types/Int.rst:524
msgid ""
"Return a new instance of type T that is assigned a constant value of ones "
"the same width as x."
msgstr "返回类型 T 的新实例，该实例被分配了与 x 宽度相同的常量值。"

#: ../../SpinalHDL/Data types/Int.rst:525
msgid "T(w(x) bits).setAll()"
msgstr "T(w(x) bits).setAll()"

#: ../../SpinalHDL/Data types/Int.rst:528
msgid ""
"`validRange` can only be used for types where the minimum and maximum values"
" fit into a signed 32-bit integer. (This is a limitation given by the Scala "
"``scala.collection.immutable.Range`` type which uses `Int`)"
msgstr ""
"`validRange` 只能用于最小值和最大值能够保存在32 位有符号整数的情况下。 （"
"这是由于 Scala ``scala.collection.immutable.Range`` 类型使用 `Int` "
"作为范围描述）"

#: ../../SpinalHDL/Data types/Int.rst:547
msgid "FixPoint operations"
msgstr "定点小数操作"

#: ../../SpinalHDL/Data types/Int.rst:549
msgid "For fixpoint, we can divide it into two parts:"
msgstr "对于定点小数，我们可以将其分为两部分："

#: ../../SpinalHDL/Data types/Int.rst:551
msgid "Lower bit operations (rounding methods)"
msgstr "低位运算（舍入方法）"

#: ../../SpinalHDL/Data types/Int.rst:552
msgid "High bit operations (saturation operations)"
msgstr "高位运算（饱和运算）"

#: ../../SpinalHDL/Data types/Int.rst:555
msgid "Lower bit operations"
msgstr "低位运算"

#: ../../SpinalHDL/Data types/Int.rst:559
msgid "About Rounding: https://en.wikipedia.org/wiki/Rounding"
msgstr "关于舍入运算: https://en.wikipedia.org/wiki/Rounding"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "SpinalHDL-Name"
msgstr "SpinalHDL中的名称"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Wikipedia-Name"
msgstr "维基百科中的名称"

#: ../../SpinalHDL/Data types/Int.rst:562 types/Int.rst:620
msgid "API"
msgstr "API"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Mathematic Algorithm"
msgstr "数学算法描述"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "return(align=false)"
msgstr "返回类型（align=false）"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Supported"
msgstr "支持情况"

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "FLOOR"
msgstr "FLOOR"

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "RoundDown"
msgstr "RoundDown"

#: ../../SpinalHDL/Data types/Int.rst:564 types/Int.rst:622
msgid "floor"
msgstr "floor"

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "floor(x)"
msgstr "floor(x)"

#: ../../SpinalHDL/Data types/Int.rst:564 types/Int.rst:565 types/Int.rst:622
#: types/Int.rst:623
msgid "w(x)-n   bits"
msgstr "w(x)-n bits"

#: ../../SpinalHDL/Data types/Int.rst:564 types/Int.rst:565 types/Int.rst:566
#: types/Int.rst:567 types/Int.rst:568 types/Int.rst:569 types/Int.rst:570
#: types/Int.rst:571
msgid "Yes"
msgstr "是"

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "FLOORTOZERO"
msgstr "FLOORTOZERO"

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "RoundToZero"
msgstr "RoundToZero"

#: ../../SpinalHDL/Data types/Int.rst:565 types/Int.rst:623
msgid "floorToZero"
msgstr "floorToZero"

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "sign*floor(abs(x))"
msgstr "sign*floor(abs(x))"

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "CEIL"
msgstr "CEIL"

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "RoundUp"
msgstr "RoundUp"

#: ../../SpinalHDL/Data types/Int.rst:566 types/Int.rst:624
msgid "ceil"
msgstr "ceil"

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "ceil(x)"
msgstr "ceil(x)"

#: ../../SpinalHDL/Data types/Int.rst:566 types/Int.rst:567 types/Int.rst:568
#: types/Int.rst:569 types/Int.rst:570 types/Int.rst:571 types/Int.rst:624
#: types/Int.rst:625 types/Int.rst:626 types/Int.rst:627 types/Int.rst:628
#: types/Int.rst:629 types/Int.rst:630
msgid "w(x)-n+1 bits"
msgstr "w(x)-n+1 bits"

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "CEILTOINF"
msgstr "CEILTOINF"

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "RoundToInf"
msgstr "RoundToInf"

#: ../../SpinalHDL/Data types/Int.rst:567 types/Int.rst:625
msgid "ceilToInf"
msgstr "ceilToInf"

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "sign*ceil(abs(x))"
msgstr "sign*ceil(abs(x))"

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "ROUNDUP"
msgstr "ROUNDUP"

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "RoundHalfUp"
msgstr "RoundHalfUp"

#: ../../SpinalHDL/Data types/Int.rst:568 types/Int.rst:626
msgid "roundUp"
msgstr "roundUp"

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "floor(x+0.5)"
msgstr "floor(x+0.5)"

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "ROUNDDOWN"
msgstr "ROUNDDOWN"

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "RoundHalfDown"
msgstr "RoundHalfDown"

#: ../../SpinalHDL/Data types/Int.rst:569 types/Int.rst:627
msgid "roundDown"
msgstr "roundDown"

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "ceil(x-0.5)"
msgstr "ceil(x-0.5)"

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "ROUNDTOZERO"
msgstr "ROUNDTOZERO"

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "RoundHalfToZero"
msgstr "RoundHalfToZero"

#: ../../SpinalHDL/Data types/Int.rst:570 types/Int.rst:629
msgid "roundToZero"
msgstr "roundToZero"

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "sign*ceil(abs(x)-0.5)"
msgstr "sign*ceil(abs(x)-0.5)"

#: ../../SpinalHDL/Data types/Int.rst:571 types/Int.rst:584 types/Int.rst:585
#: types/Int.rst:588
msgid "ROUNDTOINF"
msgstr "ROUNDTOINF"

#: ../../SpinalHDL/Data types/Int.rst:571
msgid "RoundHalfToInf"
msgstr "RoundHalfToInf"

#: ../../SpinalHDL/Data types/Int.rst:571 types/Int.rst:628
msgid "roundToInf"
msgstr "roundToInf"

#: ../../SpinalHDL/Data types/Int.rst:571
msgid "sign*floor(abs(x)+0.5)"
msgstr "sign*floor(abs(x)+0.5)"

#: ../../SpinalHDL/Data types/Int.rst:572 types/Int.rst:586
msgid "ROUNDTOEVEN"
msgstr "ROUNDTOEVEN"

#: ../../SpinalHDL/Data types/Int.rst:572
msgid "RoundHalfToEven"
msgstr "RoundHalfToEven"

#: ../../SpinalHDL/Data types/Int.rst:572
msgid "roundToEven"
msgstr "roundToEven"

#: ../../SpinalHDL/Data types/Int.rst:572 types/Int.rst:573
msgid "No"
msgstr "不支持"

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "ROUNDTOODD"
msgstr "ROUNDTOODD"

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "RoundHalfToOdd"
msgstr "RoundHalfToOdd"

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "roundToOdd"
msgstr "roundToOdd"

#: ../../SpinalHDL/Data types/Int.rst:577
msgid ""
"The **RoundToEven** and **RoundToOdd** modes are very special, and are used "
"in some big data statistical fields with high accuracy concerns, SpinalHDL "
"doesn't support them yet."
msgstr ""
"**RoundToEven** 和 **RoundToOdd** "
"模式非常特殊，用于一些精度要求较高的大数据统计领域，SpinalHDL 尚不支持。"

#: ../../SpinalHDL/Data types/Int.rst:579
msgid ""
"You will find `ROUNDUP`, `ROUNDDOWN`, `ROUNDTOZERO`, `ROUNDTOINF`, "
"`ROUNDTOEVEN`, `ROUNTOODD` are very close in behavior, `ROUNDTOINF` is the "
"most common. The behavior of rounding in different programming languages may"
" be different."
msgstr ""
"你会发现 `ROUNDUP`、`ROUNDDOWN`、`ROUNDTOZERO`、`ROUNDTOINF`、`ROUNDTOEVEN`、"
"`ROUNTOODD` 在行为上非常接近，`ROUNDTOINF` "
"是最常见的。不同编程语言中的舍入行为可能不同。"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "Programming language"
msgstr "编程语言"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "default-RoundType"
msgstr "默认舍入类型"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "Example"
msgstr "示例"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "comments"
msgstr "评论"

#: ../../SpinalHDL/Data types/Int.rst:584
msgid "Matlab"
msgstr "Matlab"

#: ../../SpinalHDL/Data types/Int.rst:584 types/Int.rst:585 types/Int.rst:588
msgid "round(1.5)=2,round(2.5)=3;round(-1.5)=-2,round(-2.5)=-3"
msgstr "round(1.5)=2,round(2.5)=3;round(-1.5)=-2,round(-2.5)=-3"

#: ../../SpinalHDL/Data types/Int.rst:584 types/Int.rst:585 types/Int.rst:588
msgid "round to ±Infinity"
msgstr "四舍五入至±无穷大"

#: ../../SpinalHDL/Data types/Int.rst:585
msgid "python2"
msgstr "python2"

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "python3"
msgstr "蟒蛇3"

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "round(1.5)=round(2.5)=2;  round(-1.5)=round(-2.5)=-2"
msgstr "round(1.5)=round(2.5)=2;  round(-1.5)=round(-2.5)=-2"

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "close to Even"
msgstr "向偶数舍入"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "Scala.math"
msgstr "Scala.math"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "ROUNDTOUP"
msgstr "ROUNDTOUP"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "round(1.5)=2,round(2.5)=3;round(-1.5)=-1,round(-2.5)=-2"
msgstr "round(1.5)=2,round(2.5)=3;round(-1.5)=-1,round(-2.5)=-2"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "always to +Infinity"
msgstr "永远向正无穷舍入"

#: ../../SpinalHDL/Data types/Int.rst:588
msgid "SpinalHDL"
msgstr "SpinalHDL"

#: ../../SpinalHDL/Data types/Int.rst:592
msgid ""
"In SpinalHDL `ROUNDTOINF` is the default RoundType (``round = roundToInf``)"
msgstr "在 SpinalHDL 中，`ROUNDTOINF` 是默认的舍入类型 (``round = roundToInf``)"

#: ../../SpinalHDL/Data types/Int.rst:615
msgid ""
"Only ``floor`` and ``floorToZero`` work without the ``align`` option; they "
"do not need a carry bit. Other rounding operations default to using a carry "
"bit."
msgstr ""
"只有 ``floor`` 和 ``floorToZero`` 可以在没有 ``align`` "
"选项的情况下工作；他们不需要进位位。其他舍入操作默认使用进位位。"

#: ../../SpinalHDL/Data types/Int.rst:617
msgid "**round Api**"
msgstr "**round Api**"

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "description"
msgstr "描述"

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "Return(align=false)"
msgstr "返回类型（align=false）"

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "Return(align=true)"
msgstr "返回类型（align=true）"

#: ../../SpinalHDL/Data types/Int.rst:622 types/Int.rst:624 types/Int.rst:626
#: types/Int.rst:627 types/Int.rst:630
msgid "Both"
msgstr "均支持"

#: ../../SpinalHDL/Data types/Int.rst:622 types/Int.rst:623 types/Int.rst:624
#: types/Int.rst:625 types/Int.rst:626 types/Int.rst:627 types/Int.rst:628
#: types/Int.rst:629 types/Int.rst:630
msgid "w(x)-n bits"
msgstr "w(x)-n bits"

#: ../../SpinalHDL/Data types/Int.rst:623 types/Int.rst:625 types/Int.rst:628
#: types/Int.rst:629
msgid "SInt"
msgstr "SInt"

#: ../../SpinalHDL/Data types/Int.rst:623
msgid "equal to floor in UInt"
msgstr "等于 UInt 类型的下限"

#: ../../SpinalHDL/Data types/Int.rst:625
msgid "equal to ceil in UInt"
msgstr "等于 UInt 类型的 ceil值"

#: ../../SpinalHDL/Data types/Int.rst:626
msgid "simple for HW"
msgstr "硬件实现简单"

#: ../../SpinalHDL/Data types/Int.rst:628
msgid "most Common"
msgstr "最常使用"

#: ../../SpinalHDL/Data types/Int.rst:629
msgid "equal to roundDown in UInt"
msgstr "等于 UInt 类型的roundDown"

#: ../../SpinalHDL/Data types/Int.rst:630
msgid "round"
msgstr "round"

#: ../../SpinalHDL/Data types/Int.rst:630
msgid "SpinalHDL chose roundToInf"
msgstr "SpinalHDL 中等效于 roundToInf"

#: ../../SpinalHDL/Data types/Int.rst:634
msgid ""
"Although ``roundToInf`` is very common, ``roundUp`` has the least cost and "
"good timing, with almost no performance loss. As a result, ``roundUp`` is "
"strongly recommended for production use."
msgstr ""
"虽然 ``roundToInf`` 很常见，但 ``roundUp`` "
"的成本最低，时序也好，几乎没有性能损失。因此，强烈建议在生产环境中使用 "
"``roundUp`` 。"

#: ../../SpinalHDL/Data types/Int.rst:638
msgid "High bit operations"
msgstr "高位操作"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "function"
msgstr "函数"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Operation"
msgstr "操作"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Positive-Op"
msgstr "正向操作"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Negative-Op"
msgstr "负向操作"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "sat"
msgstr "sat"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "Saturation"
msgstr "饱和化"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "when(Top[w-1, w-n].orR) set maxValue"
msgstr "当(Top[w-1, w-n].orR)为真时设置为maxValue"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "When(Top[w-1, w-n].andR) set minValue"
msgstr "当(Top[w-1, w-n].andR)为真时设置为 minValue"

#: ../../SpinalHDL/Data types/Int.rst:646
msgid "trim"
msgstr "trim"

#: ../../SpinalHDL/Data types/Int.rst:646
msgid "Discard"
msgstr "丢弃"

#: ../../SpinalHDL/Data types/Int.rst:646 types/Int.rst:647
msgid "N/A"
msgstr "不适用"

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "symmetry"
msgstr "symmetry"

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "Symmetric"
msgstr "获取对称值"

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "minValue = -maxValue"
msgstr "最小值 = -最大值"

#: ../../SpinalHDL/Data types/Int.rst:650
msgid "Symmetric is only valid for ``SInt``."
msgstr "对称仅对 ``SInt`` 有效。"

#: ../../SpinalHDL/Data types/Int.rst:663
msgid "fixTo function"
msgstr "fixTo 函数"

#: ../../SpinalHDL/Data types/Int.rst:665
msgid "Two ways are provided in ``UInt``/``SInt`` to do fixpoint:"
msgstr "``UInt``/``SInt`` 中提供了两种方法来实现定点小数位宽变化："

#: ../../SpinalHDL/Data types/Int.rst:669
msgid ""
"``fixTo`` is strongly recommended in your RTL work, you don't need to handle"
" carry bit alignment and bit width calculations manually like **Way1** in "
"the above diagram."
msgstr "在 RTL 工作中强烈建议使用 ``fixTo`` 函数，您不需要像上图中的 **Way1** "
"那样手动处理进位对齐和位宽计算。"

#: ../../SpinalHDL/Data types/Int.rst:671
msgid "Factory Fix function with Auto Saturation:"
msgstr "带自动饱和功能的定点数生成函数："

#: ../../SpinalHDL/Data types/Int.rst:674
msgid "Function"
msgstr "函数"

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "fixTo(section, roundType, symmetric)"
msgstr "fixTo(section, roundType, symmetric)"

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "Factory FixFunction"
msgstr "定点数生成"

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "section.size bits"
msgstr "section.size bits"

#~ msgid ""
#~ "The ``UInt``/``SInt`` type corresponds to a vector of bits that can be used "
#~ "for signed/unsigned integer arithmetic."
#~ msgstr "``UInt``/``SInt`` 类型对应于可用于有符号/无符号整数算术的位向量。"

#~ msgid "UInt"
#~ msgstr "单位"

#~ msgid ""
#~ "Create an unsigned/signed integer assigned with 'value' (Base : 'h', 'd', "
#~ "'o', 'b')"
#~ msgstr "创建一个分配有“value”的无符号/有符号整数（基数：“h”、“d”、“o”、“b”）"

#~ msgid "``x rotateLeft y`` and ``x rotateRight y`` are also valid syntax."
#~ msgstr "“xrotateLeft y”和“xrotateRight y”也是有效的语法。"

#~ msgid ""
#~ "Notice the difference between ``x >> 2``:T(w(x)-2) and ``x >> "
#~ "U(2)``:T(w(x))."
#~ msgstr "注意 ``x >> 2``:T(w(x)-2) 和 ``x >> U(2)``:T(w(x)) 之间的区别。"

#~ msgid "Addition by sat carry bit"
#~ msgstr "通过 sat 进位位进行加法"

#~ msgid "Subtraction by sat carry bit"
#~ msgstr "通过 sat 进位位进行减法"

#~ msgid "x(y)"
#~ msgstr "x(y)"

#~ msgid "Readbit, y : Int/UInt"
#~ msgstr "读取位，y：Int/UInt"

#~ msgid "Read bitfield, offset: UInt, width: Int"
#~ msgstr "Read bitfield, offset: UInt, width: Int"

#~ msgid "x(y) := z"
#~ msgstr "x(y) := z"

#~ msgid "x(offset, width) := z"
#~ msgstr "x(offset, width) := z"

#~ msgid "Assign bitfield, offset: UInt, width: Int"
#~ msgstr "分配位域，偏移量：UInt，宽度：Int"

#~ msgid "x(\\ :ref:`range <range>`\\ ) := z"
#~ msgstr "x(\\ :ref:`范围 <范围>`\\ ) := z"

#~ msgid "Assign a range of bit. Ex : myBits(4 downto 2) := U\"010\""
#~ msgstr "指定一个位范围。例如：myBits(4 downto 2) := U\"010\""

#~ msgid "Return the most significant bit"
#~ msgstr "返回最高有效位"

#~ msgid "Return the least significant bit"
#~ msgstr "返回最低有效位"

#~ msgid "Vec(T, w(x)/y)"
#~ msgstr "Vec(T, w(x)/y)"

#~ msgid "Use the two's complement to transform an UInt into an SInt"
#~ msgstr "使用二进制补码将 UInt 转换为 SInt"

#~ msgid "Return most significant bit"
#~ msgstr "返回最高有效位"
