msgid ""
msgstr ""
"Project-Id-Version: SpinalHDLReport-Msgid-Bugs-To:POT-Creation-Date:2023-12-"
"01 11:48+0800PO-Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME "
"<EMAIL@ADDRESS>Language:zh_CNLanguage-Team:zh_CN <LL@li.org>Plural-"
"Forms:nplurals=1; plural=0;MIME-Version:1.0Content-Type:text/plain; "
"charset=UTF-8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESSPOT-Creation-Date:2023-12-02 00:23+0800PO-"
"Revision-Date:YEAR-MO-DA HO:MI+ZONELast-Translator:FULL NAME <EMAIL@ADDRESS"
">Language-Team:LANGUAGE <LL@li.org>MIME-Version:1.0Content-Type:text/plain; "
"charset=UTF-8\n"
"PO-Revision-Date: 2023-12-02 07:17+0000\n"
"Last-Translator: Readon <xydarcher@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"spinaldoc-rtd/spinalhdldata-typesint/zh_Hans/>\n"
"Language: zh_CN\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bitGenerated-By:Babel 2.13.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.3-dev\n"

#: ../../SpinalHDL/Data types/Int.rst:4 types/Int.rst:620
msgid "UInt/SInt"
msgstr "UInt/Sint"

#: ../../SpinalHDL/Data types/Int.rst:6
msgid ""
"The ``UInt``/``SInt`` types are vectors of bits interpreted as two's "
"complement unsigned/signed integers. They can do what ``Bits`` can do, with "
"the addition of unsigned/signed integer arithmetic and comparisons."
msgstr ""
"``UInt``/``SInt`` "
"类型是解释为二进制补码无符号/有符号整数的位向量。他们可以做“Bits”可以做的事情，加上无符号/有符号整数算术和比较。"

#: ../../SpinalHDL/Data types/Int.rst:10
msgid "Declaration"
msgstr "声明"

#: ../../SpinalHDL/Data types/Int.rst:12
msgid ""
"The syntax to declare an integer is as follows:  (everything between [] is "
"optional)"
msgstr ""
"The syntax to declare an integer is as follows:  (everything between [] is "
"optional)"

#: ../../SpinalHDL/Data types/Int.rst:18
msgid "Syntax"
msgstr "语法"

#: ../../SpinalHDL/Data types/Int.rst:19 types/Int.rst:78 types/Int.rst:179
#: types/Int.rst:243 types/Int.rst:292 types/Int.rst:378 types/Int.rst:480
#: types/Int.rst:674
msgid "Description"
msgstr "描述"

#: ../../SpinalHDL/Data types/Int.rst
msgid "UInt[()]"
msgstr "UInt[()]"

#: ../../SpinalHDL/Data types/Int.rst
msgid "SInt[()]"
msgstr "SInt[()]"

#: ../../SpinalHDL/Data types/Int.rst:22
msgid "Create an unsigned/signed integer, bits count is inferred"
msgstr "创建一个无符号/有符号整数，推断位数"

#: ../../SpinalHDL/Data types/Int.rst
msgid "UInt(x bits)"
msgstr "UInt(x 位)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "SInt(x bits)"
msgstr "SInt(x 位)"

#: ../../SpinalHDL/Data types/Int.rst:25
msgid "Create an unsigned/signed integer with x bits"
msgstr "创建一个 x 位的无符号/有符号整数"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U(value: Int[,x bits])"
msgstr "U(值: Int[,x 位])"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U(value: BigInt[,x bits])"
msgstr "U(值: BigInt[,x 位])"

#: ../../SpinalHDL/Data types/Int.rst
msgid "S(value: Int[,x bits])"
msgstr "S(值: Int[,x 位])"

#: ../../SpinalHDL/Data types/Int.rst
msgid "S(value: BigInt[,x bits])"
msgstr "S(值: BigInt[,x 位])"

#: ../../SpinalHDL/Data types/Int.rst types/Int.rst:30
msgid "Create an unsigned/signed integer assigned with 'value'"
msgstr "Create an unsigned/signed integer assigned with 'value'"

#: ../../SpinalHDL/Data types/Int.rst
msgid "U\"[[size']base]value\""
msgstr "U\"[[size']base]值\""

#: ../../SpinalHDL/Data types/Int.rst
msgid "S\"[[size']base]value\""
msgstr "S\"[[size']base]值\""

#: ../../SpinalHDL/Data types/Int.rst
msgid "(base: 'h', 'd', 'o', 'b')"
msgstr "（碱基：'h'、'd'、'o'、'b'）"

#: ../../SpinalHDL/Data types/Int.rst
#, fuzzy
msgid "U([x bits,] elements: Element*)"
msgstr "U([x 位，] 元素：元素*)"

#: ../../SpinalHDL/Data types/Int.rst
#, fuzzy
msgid "S([x bits,] elements: Element*)"
msgstr "S([x 位，] 元素：元素*)"

#: ../../SpinalHDL/Data types/Int.rst:37
#, fuzzy
msgid ""
"Create an unsigned integer assigned with the value specified by "
":ref:`elements <element>`"
msgstr "创建一个无符号整数，并分配由:ref:`elements <element>` 指定的值"

#: ../../SpinalHDL/Data types/Int.rst:66
msgid "Operators"
msgstr "运算符"

#: ../../SpinalHDL/Data types/Int.rst:68
msgid ""
"The following operators are available for the ``UInt`` and ``SInt`` types:"
msgstr "以下运算符可用于“UInt”和“SInt”类型："

#: ../../SpinalHDL/Data types/Int.rst:71
msgid "Logic"
msgstr "逻辑"

#: ../../SpinalHDL/Data types/Int.rst:77 types/Int.rst:178 types/Int.rst:242
#: types/Int.rst:291 types/Int.rst:377 types/Int.rst:479
msgid "Operator"
msgstr "操作员"

#: ../../SpinalHDL/Data types/Int.rst:79 types/Int.rst:244
msgid "Return type"
msgstr "返回类型"

#: ../../SpinalHDL/Data types/Int.rst:80 types/Int.rst:208
msgid "~x"
msgstr "〜x"

#: ../../SpinalHDL/Data types/Int.rst:81
msgid "Bitwise NOT"
msgstr "按位非"

#: ../../SpinalHDL/Data types/Int.rst:82 types/Int.rst:106 types/Int.rst:115
#: types/Int.rst:118 types/Int.rst:122 types/Int.rst:126 types/Int.rst:204
#: types/Int.rst:210 types/Int.rst:516
msgid "T(w(x) bits)"
msgstr "T(w(x) 位)"

#: ../../SpinalHDL/Data types/Int.rst:83
msgid "x & y"
msgstr "坐标"

#: ../../SpinalHDL/Data types/Int.rst:84
msgid "Bitwise AND"
msgstr "按位与"

#: ../../SpinalHDL/Data types/Int.rst:85 types/Int.rst:88 types/Int.rst:91
#: types/Int.rst:183 types/Int.rst:189 types/Int.rst:192 types/Int.rst:198
msgid "T(max(w(x), w(y)) bits)"
msgstr "T(最大(w(x), w(y)) 位)"

#: ../../SpinalHDL/Data types/Int.rst:86
msgid "x | y"
msgstr "x | y"

#: ../../SpinalHDL/Data types/Int.rst:87
msgid "Bitwise OR"
msgstr "按位或"

#: ../../SpinalHDL/Data types/Int.rst:89
msgid "x ^ y"
msgstr "x^y"

#: ../../SpinalHDL/Data types/Int.rst:90
msgid "Bitwise XOR"
msgstr "按位异或"

#: ../../SpinalHDL/Data types/Int.rst:92
msgid "x.xorR"
msgstr "异或R"

#: ../../SpinalHDL/Data types/Int.rst:93
#, fuzzy
msgid "XOR all bits of x (reduction operator)"
msgstr "XOR x 的所有位（归约运算符）"

#: ../../SpinalHDL/Data types/Int.rst:94 types/Int.rst:97 types/Int.rst:100
#: types/Int.rst:247 types/Int.rst:250 types/Int.rst:253 types/Int.rst:256
#: types/Int.rst:259 types/Int.rst:262 types/Int.rst:382 types/Int.rst:385
#: types/Int.rst:403 types/Int.rst:406 types/Int.rst:409
msgid "Bool"
msgstr "布尔"

#: ../../SpinalHDL/Data types/Int.rst:95
msgid "x.orR"
msgstr "x或R"

#: ../../SpinalHDL/Data types/Int.rst:96
#, fuzzy
msgid "OR all bits of x (reduction operator)"
msgstr "OR x 的所有位（归约运算符）"

#: ../../SpinalHDL/Data types/Int.rst:98
msgid "x.andR"
msgstr "x和R"

#: ../../SpinalHDL/Data types/Int.rst:99
#, fuzzy
msgid "AND all bits of x (reduction operator)"
msgstr "AND x 的所有位（归约运算符）"

#: ../../SpinalHDL/Data types/Int.rst:101 types/Int.rst:104
msgid "x \\>\\> y"
msgstr "x \\>\\> y"

#: ../../SpinalHDL/Data types/Int.rst:102
msgid "Arithmetic shift right, y : Int"
msgstr "算术右移，y : Int"

#: ../../SpinalHDL/Data types/Int.rst:103
msgid "T(w(x) - y bits)"
msgstr "T(w(x) - y 位)"

#: ../../SpinalHDL/Data types/Int.rst:105
msgid "Arithmetic shift right, y : UInt"
msgstr "算术右移，y : UInt"

#: ../../SpinalHDL/Data types/Int.rst:107 types/Int.rst:110
msgid "x \\<\\< y"
msgstr "x \\<\\< y"

#: ../../SpinalHDL/Data types/Int.rst:108
msgid "Arithmetic shift left, y : Int"
msgstr "算术左移，y : Int"

#: ../../SpinalHDL/Data types/Int.rst:109
msgid "T(w(x) + y bits)"
msgstr "T(w(x) + y 位)"

#: ../../SpinalHDL/Data types/Int.rst:111
msgid "Arithmetic shift left, y : UInt"
msgstr "算术左移，y : UInt"

#: ../../SpinalHDL/Data types/Int.rst:112
msgid "T(w(x) + max(y) bits)"
msgstr "T(w(x) + max(y) 位)"

#: ../../SpinalHDL/Data types/Int.rst:113
msgid "x \\|\\>\\> y"
msgstr "x \\|\\>\\> y"

#: ../../SpinalHDL/Data types/Int.rst:114
msgid "Logical shift right, y : Int/UInt"
msgstr "逻辑右移，y：Int/UInt"

#: ../../SpinalHDL/Data types/Int.rst:116
msgid "x \\|\\<\\< y"
msgstr "x \\|\\<\\< y"

#: ../../SpinalHDL/Data types/Int.rst:117
msgid "Logical shift left, y : Int/UInt"
msgstr "逻辑左移，y：Int/UInt"

#: ../../SpinalHDL/Data types/Int.rst:119
msgid "x.rotateLeft(y)"
msgstr "x.向左旋转(y)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Logical left rotation, y : UInt/Int"
msgstr "Logical left rotation, y : UInt/Int"

#: ../../SpinalHDL/Data types/Int.rst
msgid "The width of y is constrained to the width of log2Up(x) or less"
msgstr "y 的宽度被限制为 log2Up(x) 的宽度或更小"

#: ../../SpinalHDL/Data types/Int.rst:123
msgid "x.rotateRight(y)"
msgstr "x.rotateRight(y)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Logical right rotation, y : UInt/Int"
msgstr "逻辑右旋转，y：UInt/Int"

#: ../../SpinalHDL/Data types/Int.rst:127
msgid "x.clearAll[()]"
msgstr "x.clearAll[()]"

#: ../../SpinalHDL/Data types/Int.rst:128
msgid "Clear all bits"
msgstr "清除所有位"

#: ../../SpinalHDL/Data types/Int.rst:129 types/Int.rst:132 types/Int.rst:135
#: types/Int.rst:138
msgid "*modifies x*"
msgstr "*修改x*"

#: ../../SpinalHDL/Data types/Int.rst:130
msgid "x.setAll[()]"
msgstr "x.setAll[()]"

#: ../../SpinalHDL/Data types/Int.rst:131
msgid "Set all bits"
msgstr "设置所有位"

#: ../../SpinalHDL/Data types/Int.rst:133
msgid "x.setAllTo(value : Boolean)"
msgstr "x.setAllTo(值：布尔值)"

#: ../../SpinalHDL/Data types/Int.rst:134
msgid "Set all bits to the given Boolean value"
msgstr "将所有位设置为给定的布尔值"

#: ../../SpinalHDL/Data types/Int.rst:136
msgid "x.setAllTo(value : Bool)"
msgstr "x.setAllTo(值：布尔)"

#: ../../SpinalHDL/Data types/Int.rst:137
msgid "Set all bits to the given Bool value"
msgstr "将所有位设置为给定的布尔值"

#: ../../SpinalHDL/Data types/Int.rst:142
msgid ""
"Notice the difference in behaviour between ``x >> 2`` (result 2 bit narrower"
" than x) and ``x >> U(2)`` (keeping width) due to the Scala type of "
":code:`y`."
msgstr "请注意由于 y 的 Scala 类型，“x >> 2”（结果比 x 窄 2 位）和“x >> U(2)”（保持宽度）之间的行为差​​异。"

#: ../../SpinalHDL/Data types/Int.rst:145
#, fuzzy
msgid ""
"In the first case \"2\" is an ``Int`` (which can be seen as an \"elaboration"
" integer constant\"), and in the second case it is a hardware signal (type "
"``UInt``) that may or may not be a constant."
msgstr ""
"在第一种情况下，“2”是一个“Int”（可以看作是“精化整数常量”），在第二种情况下，它是一个硬件信号（类型“UInt”）这可能是也可能不是一个常数。"

#: ../../SpinalHDL/Data types/Int.rst:173
msgid "Arithmetic"
msgstr "算术"

#: ../../SpinalHDL/Data types/Int.rst:180 types/Int.rst:293 types/Int.rst:379
#: types/Int.rst:481 types/Int.rst:674
msgid "Return"
msgstr "返回"

#: ../../SpinalHDL/Data types/Int.rst:181
msgid "x + y"
msgstr "x + y"

#: ../../SpinalHDL/Data types/Int.rst:182
msgid "Addition"
msgstr "添加"

#: ../../SpinalHDL/Data types/Int.rst:184
msgid "x +^ y"
msgstr "x+^y"

#: ../../SpinalHDL/Data types/Int.rst:185
msgid "Addition with carry"
msgstr "带进位的加法"

#: ../../SpinalHDL/Data types/Int.rst:186 types/Int.rst:195
msgid "T(max(w(x), w(y)) + 1 bits)"
msgstr "T(max(w(x), w(y)) + 1 位)"

#: ../../SpinalHDL/Data types/Int.rst:187
msgid "x +| y"
msgstr "x+| y"

#: ../../SpinalHDL/Data types/Int.rst:188
msgid ""
"Addition of addend with `saturation`_ (see also `T.maxValue` and "
"`T.minValue`)"
msgstr "添加带有“饱和度”的加数（另请参见“T.maxValue”和“T.minValue”）"

#: ../../SpinalHDL/Data types/Int.rst:190
msgid "x - y"
msgstr "坐标"

#: ../../SpinalHDL/Data types/Int.rst:191
msgid "Subtraction"
msgstr "减法"

#: ../../SpinalHDL/Data types/Int.rst:193
msgid "x -^ y"
msgstr "x-^y"

#: ../../SpinalHDL/Data types/Int.rst:194
msgid "Subtraction with carry"
msgstr "带进位的减法"

#: ../../SpinalHDL/Data types/Int.rst:196
msgid "x -| y"
msgstr "x-| y"

#: ../../SpinalHDL/Data types/Int.rst:197
msgid ""
"Subtraction of subtrahend with `saturation`_ (see also `T.minValue` and "
"`T.maxValue`)"
msgstr "用 `saturation`_ 减去减数（另请参见 `T.minValue` 和 `T.maxValue`）"

#: ../../SpinalHDL/Data types/Int.rst:199
msgid "x * y"
msgstr "x * y"

#: ../../SpinalHDL/Data types/Int.rst:200
msgid "Multiplication"
msgstr "乘法"

#: ../../SpinalHDL/Data types/Int.rst:201
msgid "T(w(x) + w(y)) bits)"
msgstr "T(w(x) + w(y)) 位)"

#: ../../SpinalHDL/Data types/Int.rst:202
msgid "x / y"
msgstr "x / y"

#: ../../SpinalHDL/Data types/Int.rst:203
msgid "Division"
msgstr "分配"

#: ../../SpinalHDL/Data types/Int.rst:205
msgid "x % y"
msgstr "x % y"

#: ../../SpinalHDL/Data types/Int.rst:206
msgid "Modulo"
msgstr "模数"

#: ../../SpinalHDL/Data types/Int.rst:207
msgid "T(min(w(x), w(y)) bits)"
msgstr "T(min(w(x), w(y)) 位)"

#: ../../SpinalHDL/Data types/Int.rst:209
msgid "Unary One's compliment, Bitwise NOT"
msgstr "一元补码，按位 NOT"

#: ../../SpinalHDL/Data types/Int.rst:211
msgid "-x"
msgstr "-X"

#: ../../SpinalHDL/Data types/Int.rst:212
msgid "Unary Two's compliment of SInt type.  Not available for UInt."
msgstr "SInt 类型的一元二元补码。不适用于 UInt。"

#: ../../SpinalHDL/Data types/Int.rst:213 types/Int.rst:302 types/Int.rst:311
msgid "SInt(w(x) bits)"
msgstr "SInt(w(x) 位)"

#: ../../SpinalHDL/Data types/Int.rst:233
msgid ""
"Notice how simulation assertions are made here (with ``===``), as opposed to"
" elaboration assertions in the previous example (with ``==``)."
msgstr "请注意此处如何进行模拟断言（使用“===”），而不是前面示例中的详细断言（使用“==”）。"

#: ../../SpinalHDL/Data types/Int.rst:237
msgid "Comparison"
msgstr "比较"

#: ../../SpinalHDL/Data types/Int.rst:245
msgid "x === y"
msgstr "x === y"

#: ../../SpinalHDL/Data types/Int.rst:246
msgid "Equality"
msgstr "平等"

#: ../../SpinalHDL/Data types/Int.rst:248
msgid "x =/= y"
msgstr "x =/= y"

#: ../../SpinalHDL/Data types/Int.rst:249
msgid "Inequality"
msgstr "不等式"

#: ../../SpinalHDL/Data types/Int.rst:251
msgid "x > y"
msgstr "x > y"

#: ../../SpinalHDL/Data types/Int.rst:252
msgid "Greater than"
msgstr "比...更棒"

#: ../../SpinalHDL/Data types/Int.rst:254
msgid "x >= y"
msgstr "x >= y"

#: ../../SpinalHDL/Data types/Int.rst:255
msgid "Greater than or equal"
msgstr "大于或等于"

#: ../../SpinalHDL/Data types/Int.rst:257
msgid "x < y"
msgstr "x < y"

#: ../../SpinalHDL/Data types/Int.rst:258
msgid "Less than"
msgstr "少于"

#: ../../SpinalHDL/Data types/Int.rst:260
msgid "x <= y"
msgstr "x <= y"

#: ../../SpinalHDL/Data types/Int.rst:261
msgid "Less than or equal"
msgstr "小于或等于"

#: ../../SpinalHDL/Data types/Int.rst:282
msgid ""
"When comparing ``UInt`` values in a way that allows for \"wraparound\" "
"behavior, meaning that the values will \"wrap around\" to the minimum value "
"when they exceed the maximum value. The ``wrap`` method of ``UInt`` can be "
"used as ``x.wrap < y`` for ``UInt`` variables ``x, y``, the result will be "
"true if ``x`` is less than ``y`` in the wraparound sense."
msgstr ""
"当以允许“环绕”行为的方式比较“UInt”值时，这意味着当这些值超过最大值时，这些值将“环绕”到最小值。 ``UInt`` 的 ``wrap`` "
"方法可以用作 ``UInt`` 变量 ``x, y`` 的 ``x.wrap < y``，如果 ``x, 结果将为 true `` 在环绕意义上小于 "
"``y``。"

#: ../../SpinalHDL/Data types/Int.rst:286
msgid "Type cast"
msgstr "类型转换"

#: ../../SpinalHDL/Data types/Int.rst:294
msgid "x.asBits"
msgstr "x.asBits"

#: ../../SpinalHDL/Data types/Int.rst:295
msgid "Binary cast to Bits"
msgstr "Binary cast to Bits"

#: ../../SpinalHDL/Data types/Int.rst:296
msgid "Bits(w(x) bits)"
msgstr "位（w(x) 位）"

#: ../../SpinalHDL/Data types/Int.rst:297
msgid "x.asUInt"
msgstr "x.asUIt"

#: ../../SpinalHDL/Data types/Int.rst:298
msgid "Binary cast to UInt"
msgstr "二进制转换为 UInt"

#: ../../SpinalHDL/Data types/Int.rst:299 types/Int.rst:314
msgid "UInt(w(x) bits)"
msgstr "UInt(w(x) 位)"

#: ../../SpinalHDL/Data types/Int.rst:300
msgid "x.asSInt"
msgstr "x.asSInt"

#: ../../SpinalHDL/Data types/Int.rst:301
msgid "Binary cast to SInt"
msgstr "二进制转换为 SInt"

#: ../../SpinalHDL/Data types/Int.rst:303
msgid "x.asBools"
msgstr "x.asBools"

#: ../../SpinalHDL/Data types/Int.rst:304
msgid "Cast into a array of Bool"
msgstr "转换为 Bool 数组"

#: ../../SpinalHDL/Data types/Int.rst:305
msgid "Vec(Bool(), w(x))"
msgstr "Vec(Bool(), w(x))"

#: ../../SpinalHDL/Data types/Int.rst:306
msgid "x.asBool"
msgstr "x.asBool"

#: ../../SpinalHDL/Data types/Int.rst:307
msgid "Extract LSB of :code:`x`"
msgstr "提取 :code:`x` 的 LSB"

#: ../../SpinalHDL/Data types/Int.rst:308
msgid "Bool(x.lsb)"
msgstr "Bool(x.lsb)"

#: ../../SpinalHDL/Data types/Int.rst:309
msgid "S(x: T)"
msgstr "S(x:T)"

#: ../../SpinalHDL/Data types/Int.rst:310
msgid "Cast a Data into a SInt"
msgstr "将数据转换为 SInt"

#: ../../SpinalHDL/Data types/Int.rst:312
msgid "U(x: T)"
msgstr "U(x: T)"

#: ../../SpinalHDL/Data types/Int.rst:313
msgid "Cast a Data into an UInt"
msgstr "将数据转换为 UInt"

#: ../../SpinalHDL/Data types/Int.rst:315
msgid "x.intoSInt"
msgstr "x.intoSint"

#: ../../SpinalHDL/Data types/Int.rst:316
msgid "Convert to SInt expanding sign bit"
msgstr "转换为 SInt 扩展符号位"

#: ../../SpinalHDL/Data types/Int.rst:317
msgid "SInt(w(x) + 1 bits)"
msgstr "SInt(w(x) + 1 位)"

#: ../../SpinalHDL/Data types/Int.rst:318
msgid "myUInt.twoComplement(en: Bool)"
msgstr "myUInt.twoComplement(en: Bool)"

#: ../../SpinalHDL/Data types/Int.rst:319
msgid ""
"Generate two's complement of number if ``en`` is ``True``, unchanged "
"otherwise. (``en`` makes result negative)"
msgstr "如果“en”为“True”，则生成数字的二进制补码，否则保持不变。 (``en`` 使结果为负)"

#: ../../SpinalHDL/Data types/Int.rst:320
msgid "SInt(w(myUInt) + 1, bits)"
msgstr "SInt(w(myUInt) + 1, 位)"

#: ../../SpinalHDL/Data types/Int.rst:321
msgid "mySInt.abs"
msgstr "mySInt.abs"

#: ../../SpinalHDL/Data types/Int.rst:322
msgid "Return the absolute value as a UInt value"
msgstr "以 UInt 值形式返回绝对值"

#: ../../SpinalHDL/Data types/Int.rst:323 types/Int.rst:326
#, fuzzy
msgid "UInt(w(mySInt) bits)"
msgstr "UInt(w(mySInt) 位)"

#: ../../SpinalHDL/Data types/Int.rst:324
msgid "mySInt.abs(en: Bool)"
msgstr "mySInt.abs(en: 布尔)"

#: ../../SpinalHDL/Data types/Int.rst:325
#, fuzzy
msgid ""
"Return the absolute value as a UInt value when ``en`` is ``True``, otherwise"
" just reinterpret bits as unsigned"
msgstr "当“en”为“True”时，将绝对值作为 UInt 值返回，否则将位重新解释为无符号"

#: ../../SpinalHDL/Data types/Int.rst:327
msgid "mySInt.absWithSym"
msgstr "mySInt.absWithSym"

#: ../../SpinalHDL/Data types/Int.rst:328
msgid ""
"Return the absolute value of the UInt value with symmetric, shrink 1 bit"
msgstr "返回对称的 UInt 值的绝对值，缩小 1 位"

#: ../../SpinalHDL/Data types/Int.rst:329
msgid "UInt(w(mySInt) - 1 bits)"
msgstr "UInt(w(mySInt) - 1 位)"

#: ../../SpinalHDL/Data types/Int.rst:332
msgid ""
"To cast a ``Bool``, a ``Bits``, or an ``SInt`` into a ``UInt``, you can use "
"``U(something)``. To cast things into an ``SInt``, you can use "
"``S(something)``."
msgstr ""
"要将“Bool”、“Bits”或“SInt”转换为“UInt”，可以使用“U(something)”。要将事物转换为“SInt”，您可以使用“S(something)”。"

#: ../../SpinalHDL/Data types/Int.rst:368
msgid "Bit extraction"
msgstr "位提取"

#: ../../SpinalHDL/Data types/Int.rst:370
msgid ""
"All of the bit extraction operations can be used to read a bit / group of "
"bits. Like in other HDLs the extraction operators can also be used to assign"
" a part of a ``UInt`` / ``SInt`` ."
msgstr "所有位提取操作均可用于读取一个位/一组位。与其他 HDL 一样，提取运算符也可用于分配 ``UInt`` / ``SInt`` 的一部分。"

#: ../../SpinalHDL/Data types/Int.rst:380
msgid "x(y: Int)"
msgstr "x(y: Int)"

#: ../../SpinalHDL/Data types/Int.rst:381
msgid "Static bit access of y-th bit"
msgstr "第 y 位的静态位访问"

#: ../../SpinalHDL/Data types/Int.rst:383
msgid "x(x: UInt)"
msgstr "x(x: UInt)"

#: ../../SpinalHDL/Data types/Int.rst:384
msgid "Variable bit access of y-th bit"
msgstr "第 y 位的可变位访问"

#: ../../SpinalHDL/Data types/Int.rst:386
msgid "x(offset: Int, width bits)"
msgstr "x(offset: Int, width bits)"

#: ../../SpinalHDL/Data types/Int.rst:387
msgid "Fixed part select of fixed width, offset is LSB index"
msgstr "固定宽度的固定部分选择，偏移量为LSB索引"

#: ../../SpinalHDL/Data types/Int.rst:388 types/Int.rst:391
#, fuzzy
msgid "Bits(width bits)"
msgstr "位（宽度位）"

#: ../../SpinalHDL/Data types/Int.rst:389
msgid "x(offset: UInt, width bits)"
msgstr "x(offset: UInt, width bits)"

#: ../../SpinalHDL/Data types/Int.rst:390
msgid "Variable part-select of fixed width, offset is LSB index"
msgstr "固定宽度的可变部分选择，偏移量为LSB索引"

#: ../../SpinalHDL/Data types/Int.rst:392
msgid "x(range: Range)"
msgstr "x(range: Range)"

#: ../../SpinalHDL/Data types/Int.rst:393
msgid "Access a :ref:`range <range>` of bits. Ex : myBits(4 downto 2)"
msgstr "访问Bits :ref:`range <range>` 。例如：myBits(4 downto 2)"

#: ../../SpinalHDL/Data types/Int.rst:394
msgid "Bits(range.size bits)"
msgstr "Bits(range.size bits)"

#: ../../SpinalHDL/Data types/Int.rst:395
msgid "x.subdivideIn(y slices, [strict: Boolean])"
msgstr "x.subdivideIn(y slices, [strict: Boolean])"

#: ../../SpinalHDL/Data types/Int.rst:396
msgid "Subdivide x into y slices, y: Int"
msgstr "将x细分为y片，y：Int"

#: ../../SpinalHDL/Data types/Int.rst:397
msgid "Vec(Bits(...), y)"
msgstr "Vec(Bits(...), y)"

#: ../../SpinalHDL/Data types/Int.rst:398
msgid "x.subdivideIn(y bits, [strict: Boolean])"
msgstr "x.subdivideIn(y bits, [strict: Boolean])"

#: ../../SpinalHDL/Data types/Int.rst:399
#, fuzzy
msgid "Subdivide x in multiple slices of y bits, y: Int"
msgstr "将 x 细分为 y 位的多个切片，y: Int"

#: ../../SpinalHDL/Data types/Int.rst:400
msgid "Vec(Bits(y bit), ...)"
msgstr "Vec(Bits(y bit), ...)"

#: ../../SpinalHDL/Data types/Int.rst:401
msgid "x.msb"
msgstr "x.msb"

#: ../../SpinalHDL/Data types/Int.rst:402
msgid "Access most significant bit of x (highest index, sign bit for SInt)"
msgstr "访问 x 的最高有效位（最高索引，SInt 的符号位）"

#: ../../SpinalHDL/Data types/Int.rst:404
msgid "x.lsb"
msgstr "x.lsb"

#: ../../SpinalHDL/Data types/Int.rst:405
msgid "Access lowest significant bit of x (index 0)"
msgstr "访问 x 的最低有效位（索引 0）"

#: ../../SpinalHDL/Data types/Int.rst:407
msgid "mySInt.sign"
msgstr "mySInt.sign"

#: ../../SpinalHDL/Data types/Int.rst:408
#, fuzzy
msgid "Access most sign bit, only SInt"
msgstr "Access most sign bit, only SInt"

#: ../../SpinalHDL/Data types/Int.rst:413
msgid "Some basic examples:"
msgstr "一些基本示例："

#: ../../SpinalHDL/Data types/Int.rst:442
msgid "Subdivide details"
msgstr "细分细节"

#: ../../SpinalHDL/Data types/Int.rst:444
msgid ""
"Both overloads of ``subdivideIn`` have an optional parameter ``strict`` "
"(i.e. ``subdivideIn(slices: SlicesCount, strict: Boolean = true)``). If "
"``strict`` is ``true`` an error will be raised if the input could not be "
"divided into equal parts. If set to ``false`` the last element may be "
"smaller than the other (equal sized) elements."
msgstr ""
"``subdivideIn`` 的两个重载都有一个可选参数``strict`` （即``subdivideIn(slices: SlicesCount,"
" strict: Boolean = "
"true)``）。如果“strict”为“true”，则如果输入无法分成相等的部分，则会出现错误。如果设置为“false”，最后一个元素可能小于其他（相同大小）元素。"

#: ../../SpinalHDL/Data types/Int.rst:470
msgid "Misc"
msgstr "杂项"

#: ../../SpinalHDL/Data types/Int.rst:472
msgid ""
"In contrast to the bit extraction operations listed above it's not possible "
"to use the return values to assign to the original signal."
msgstr "与上面列出的位提取操作相反，不可能使用返回值分配给原始信号。"

#: ../../SpinalHDL/Data types/Int.rst:482
msgid "x.getWidth"
msgstr "x.getWidth"

#: ../../SpinalHDL/Data types/Int.rst:483
msgid "Return bitcount"
msgstr "返回位数"

#: ../../SpinalHDL/Data types/Int.rst:484 types/Int.rst:487
msgid "Int"
msgstr "INT"

#: ../../SpinalHDL/Data types/Int.rst:485
msgid "x.high"
msgstr "x.高"

#: ../../SpinalHDL/Data types/Int.rst:486
msgid "Return the index of the MSB (highest allowed index for Int)"
msgstr "返回 MSB 的索引（Int 允许的最高索引）"

#: ../../SpinalHDL/Data types/Int.rst:488
msgid "x.bitsRange"
msgstr "x.bitsRange"

#: ../../SpinalHDL/Data types/Int.rst:489
msgid "Return the range (0 to x.high)"
msgstr "返回范围（0 到 x.high）"

#: ../../SpinalHDL/Data types/Int.rst:490 types/Int.rst:499
msgid "Range"
msgstr "范围"

#: ../../SpinalHDL/Data types/Int.rst:491
msgid "x.minValue"
msgstr "x.min值"

#: ../../SpinalHDL/Data types/Int.rst:492
msgid "Lowest possible value of x (e.g. 0 for UInt)"
msgstr "x 的最低可能值（例如 UInt 为 0）"

#: ../../SpinalHDL/Data types/Int.rst:493 types/Int.rst:496
msgid "BigInt"
msgstr "大整型"

#: ../../SpinalHDL/Data types/Int.rst:494
msgid "x.maxValue"
msgstr "x.max值"

#: ../../SpinalHDL/Data types/Int.rst:495
msgid "Highest possible value of x"
msgstr "x 的最大可能值"

#: ../../SpinalHDL/Data types/Int.rst:497
msgid "x.valueRange"
msgstr "x.valueRange"

#: ../../SpinalHDL/Data types/Int.rst:498
msgid ""
"Return the range from minimum to maximum possible value of x (x.minValue to "
"x.maxValue)."
msgstr "返回 x 的最小到最大可能值的范围（x.minValue 到 x.maxValue）。"

#: ../../SpinalHDL/Data types/Int.rst:500
msgid "x ## y"
msgstr "x##y"

#: ../../SpinalHDL/Data types/Int.rst:501
msgid "Concatenate, x->high, y->low"
msgstr "连接，x->高，y->低"

#: ../../SpinalHDL/Data types/Int.rst:502
msgid "Bits(w(x) + w(y) bits)"
msgstr "Bits(w(x) + w(y) bits)"

#: ../../SpinalHDL/Data types/Int.rst:503
msgid "x #* n"
msgstr "x #* n"

#: ../../SpinalHDL/Data types/Int.rst:504
msgid "Repeat x n-times"
msgstr "重复 x n 次"

#: ../../SpinalHDL/Data types/Int.rst:505
msgid "Bits(w(x) * n bits)"
msgstr "Bits(w(x) * n bits)"

#: ../../SpinalHDL/Data types/Int.rst:506
msgid "x @@ y"
msgstr "x @@ y"

#: ../../SpinalHDL/Data types/Int.rst:507
msgid "Concatenate x:T with y:Bool/SInt/UInt"
msgstr "将 x:T 与 y:Bool/SInt/UInt 连接"

#: ../../SpinalHDL/Data types/Int.rst:508
msgid "T(w(x) + w(y) bits)"
msgstr "T(w(x) + w(y) 位)"

#: ../../SpinalHDL/Data types/Int.rst:509
msgid "x.resize(y)"
msgstr "x.调整大小(y)"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Return a resized copy of x, if enlarged, it is filled with zero"
msgstr "返回 x 的调整大小副本，如果放大，则用零填充"

#: ../../SpinalHDL/Data types/Int.rst
msgid "for UInt or filled with the sign for SInt, y: Int"
msgstr "对于 UInt 或用符号填充 SInt, y: Int"

#: ../../SpinalHDL/Data types/Int.rst:512
msgid "T(y bits)"
msgstr "T(y 位)"

#: ../../SpinalHDL/Data types/Int.rst:513
msgid "x.resized"
msgstr "x.调整大小"

#: ../../SpinalHDL/Data types/Int.rst
msgid "Return a version of x which is allowed to be automatically"
msgstr "返回允许自动执行的 x 版本"

#: ../../SpinalHDL/Data types/Int.rst
msgid "resized where needed"
msgstr "根据需要调整大小"

#: ../../SpinalHDL/Data types/Int.rst:517
msgid "x.expand"
msgstr "x.展开"

#: ../../SpinalHDL/Data types/Int.rst:518
msgid "Return x with 1 bit expand"
msgstr "返回 x 并进行 1 位扩展"

#: ../../SpinalHDL/Data types/Int.rst:519
msgid "T(w(x)+1 bits)"
msgstr "T(w(x)+1 位)"

#: ../../SpinalHDL/Data types/Int.rst:520
msgid "x.getZero"
msgstr "x.getZero"

#: ../../SpinalHDL/Data types/Int.rst:521
msgid ""
"Return a new instance of type T that is assigned a constant value of zeros "
"the same width as x."
msgstr "返回类型 T 的新实例，该实例被分配与 x 相同宽度的零常量值。"

#: ../../SpinalHDL/Data types/Int.rst:522
#, fuzzy
msgid "T(0, w(x) bits).clearAll()"
msgstr "T(0, w(x) 位).clearAll()"

#: ../../SpinalHDL/Data types/Int.rst:523
msgid "x.getAllTrue"
msgstr "x.getAllTrue"

#: ../../SpinalHDL/Data types/Int.rst:524
msgid ""
"Return a new instance of type T that is assigned a constant value of ones "
"the same width as x."
msgstr "返回类型 T 的新实例，该实例被分配了与 x 宽度相同的常量值。"

#: ../../SpinalHDL/Data types/Int.rst:525
#, fuzzy
msgid "T(w(x) bits).setAll()"
msgstr "T(w(x) 位).setAll()"

#: ../../SpinalHDL/Data types/Int.rst:528
msgid ""
"`validRange` can only be used for types where the minimum and maximum values"
" fit into a signed 32-bit integer. (This is a limitation given by the Scala "
"``scala.collection.immutable.Range`` type which uses `Int`)"
msgstr ""
"`validRange` 只能用于最小值和最大值能够保存在32 位有符号整数的情况下。 （"
"这是 Scala ``scala.collection.immutable.Range`` 类型使用 `Int` 给出的限制）"

#: ../../SpinalHDL/Data types/Int.rst:547
msgid "FixPoint operations"
msgstr "定点操作"

#: ../../SpinalHDL/Data types/Int.rst:549
msgid "For fixpoint, we can divide it into two parts:"
msgstr "对于fixpoint，我们可以将其分为两部分："

#: ../../SpinalHDL/Data types/Int.rst:551
msgid "Lower bit operations (rounding methods)"
msgstr "低位运算（舍入方法）"

#: ../../SpinalHDL/Data types/Int.rst:552
msgid "High bit operations (saturation operations)"
msgstr "高位运算（饱和运算）"

#: ../../SpinalHDL/Data types/Int.rst:555
msgid "Lower bit operations"
msgstr "低位运算"

#: ../../SpinalHDL/Data types/Int.rst:559
msgid "About Rounding: https://en.wikipedia.org/wiki/Rounding"
msgstr "About Rounding: https://en.wikipedia.org/wiki/Rounding"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "SpinalHDL-Name"
msgstr "SpinalHDL-名称"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Wikipedia-Name"
msgstr "维基百科名称"

#: ../../SpinalHDL/Data types/Int.rst:562 types/Int.rst:620
msgid "API"
msgstr "应用程序编程接口"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Mathematic Algorithm"
msgstr "数学算法"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "return(align=false)"
msgstr "返回（对齐=假）"

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Supported"
msgstr "支持的"

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "FLOOR"
msgstr "FLOOR"

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "RoundDown"
msgstr "向下舍入"

#: ../../SpinalHDL/Data types/Int.rst:564 types/Int.rst:622
msgid "floor"
msgstr "地面"

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "floor(x)"
msgstr "楼层(x)"

#: ../../SpinalHDL/Data types/Int.rst:564 types/Int.rst:565 types/Int.rst:622
#: types/Int.rst:623
msgid "w(x)-n   bits"
msgstr "w(x)-n 位"

#: ../../SpinalHDL/Data types/Int.rst:564 types/Int.rst:565 types/Int.rst:566
#: types/Int.rst:567 types/Int.rst:568 types/Int.rst:569 types/Int.rst:570
#: types/Int.rst:571
msgid "Yes"
msgstr "是的"

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "FLOORTOZERO"
msgstr "零点"

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "RoundToZero"
msgstr "舍入到零"

#: ../../SpinalHDL/Data types/Int.rst:565 types/Int.rst:623
msgid "floorToZero"
msgstr "归零"

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "sign*floor(abs(x))"
msgstr "符号*地板(abs(x))"

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "CEIL"
msgstr "CEIL"

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "RoundUp"
msgstr "围捕"

#: ../../SpinalHDL/Data types/Int.rst:566 types/Int.rst:624
msgid "ceil"
msgstr "天花板"

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "ceil(x)"
msgstr "上限(x)"

#: ../../SpinalHDL/Data types/Int.rst:566 types/Int.rst:567 types/Int.rst:568
#: types/Int.rst:569 types/Int.rst:570 types/Int.rst:571 types/Int.rst:624
#: types/Int.rst:625 types/Int.rst:626 types/Int.rst:627 types/Int.rst:628
#: types/Int.rst:629 types/Int.rst:630
msgid "w(x)-n+1 bits"
msgstr "w(x)-n+1 位"

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "CEILTOINF"
msgstr "CEILTOINF"

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "RoundToInf"
msgstr "舍入信息"

#: ../../SpinalHDL/Data types/Int.rst:567 types/Int.rst:625
msgid "ceilToInf"
msgstr "细胞转信息"

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "sign*ceil(abs(x))"
msgstr "符号*ceil(abs(x))"

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "ROUNDUP"
msgstr "围捕"

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "RoundHalfUp"
msgstr "圆半向上"

#: ../../SpinalHDL/Data types/Int.rst:568 types/Int.rst:626
msgid "roundUp"
msgstr "围捕"

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "floor(x+0.5)"
msgstr "楼层(x+0.5)"

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "ROUNDDOWN"
msgstr "ROUNDDOWN"

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "RoundHalfDown"
msgstr "RoundHalfDown"

#: ../../SpinalHDL/Data types/Int.rst:569 types/Int.rst:627
msgid "roundDown"
msgstr "向下舍入"

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "ceil(x-0.5)"
msgstr "天花板(x-0.5)"

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "ROUNDTOZERO"
msgstr "舍入"

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "RoundHalfToZero"
msgstr "舍半归零"

#: ../../SpinalHDL/Data types/Int.rst:570 types/Int.rst:629
msgid "roundToZero"
msgstr "舍入归零"

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "sign*ceil(abs(x)-0.5)"
msgstr "符号*ceil(abs(x)-0.5)"

#: ../../SpinalHDL/Data types/Int.rst:571 types/Int.rst:584 types/Int.rst:585
#: types/Int.rst:588
msgid "ROUNDTOINF"
msgstr "舍入式"

#: ../../SpinalHDL/Data types/Int.rst:571
msgid "RoundHalfToInf"
msgstr "RoundHalfToInf"

#: ../../SpinalHDL/Data types/Int.rst:571 types/Int.rst:628
msgid "roundToInf"
msgstr "舍入信息"

#: ../../SpinalHDL/Data types/Int.rst:571
msgid "sign*floor(abs(x)+0.5)"
msgstr "符号*下限(abs(x)+0.5)"

#: ../../SpinalHDL/Data types/Int.rst:572 types/Int.rst:586
msgid "ROUNDTOEVEN"
msgstr "圆平"

#: ../../SpinalHDL/Data types/Int.rst:572
msgid "RoundHalfToEven"
msgstr "半对偶回合"

#: ../../SpinalHDL/Data types/Int.rst:572
msgid "roundToEven"
msgstr "舍入到偶数"

#: ../../SpinalHDL/Data types/Int.rst:572 types/Int.rst:573
msgid "No"
msgstr "不"

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "ROUNDTOODD"
msgstr "圆头"

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "RoundHalfToOdd"
msgstr "半圆到奇数"

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "roundToOdd"
msgstr "舍入到奇数"

#: ../../SpinalHDL/Data types/Int.rst:577
msgid ""
"The **RoundToEven** and **RoundToOdd** modes are very special, and are used "
"in some big data statistical fields with high accuracy concerns, SpinalHDL "
"doesn't support them yet."
msgstr ""
"**RoundToEven** 和 **RoundToOdd** 模式非常特殊，用于一些精度要求较高的大数据统计领域，SpinalHDL 尚不支持。"

#: ../../SpinalHDL/Data types/Int.rst:579
msgid ""
"You will find `ROUNDUP`, `ROUNDDOWN`, `ROUNDTOZERO`, `ROUNDTOINF`, "
"`ROUNDTOEVEN`, `ROUNTOODD` are very close in behavior, `ROUNDTOINF` is the "
"most common. The behavior of rounding in different programming languages may"
" be different."
msgstr ""
"你会发现`ROUNDUP`、`ROUNDDOWN`、`ROUNDTOZERO`、`ROUNDTOINF`、`ROUNDTOEVEN`、`ROUNTOODD`在行为上非常接近，`ROUNDTOINF`是最常见的。不同编程语言中的舍入行为可能不同。"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "Programming language"
msgstr "编程语言"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "default-RoundType"
msgstr "默认RoundType"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "Example"
msgstr "例子"

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "comments"
msgstr "评论"

#: ../../SpinalHDL/Data types/Int.rst:584
msgid "Matlab"
msgstr "MATLAB"

#: ../../SpinalHDL/Data types/Int.rst:584 types/Int.rst:585 types/Int.rst:588
msgid "round(1.5)=2,round(2.5)=3;round(-1.5)=-2,round(-2.5)=-3"
msgstr "圆(1.5)=2,圆(2.5)=3;圆(-1.5)=-2,圆(-2.5)=-3"

#: ../../SpinalHDL/Data types/Int.rst:584 types/Int.rst:585 types/Int.rst:588
msgid "round to ±Infinity"
msgstr "四舍五入至±无穷大"

#: ../../SpinalHDL/Data types/Int.rst:585
msgid "python2"
msgstr "蟒蛇2"

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "python3"
msgstr "蟒蛇3"

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "round(1.5)=round(2.5)=2;  round(-1.5)=round(-2.5)=-2"
msgstr "轮(1.5)=轮(2.5)=2;回合(-1.5)=回合(-2.5)=-2"

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "close to Even"
msgstr "接近偶数"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "Scala.math"
msgstr "斯卡拉数学"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "ROUNDTOUP"
msgstr "圆顶"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "round(1.5)=2,round(2.5)=3;round(-1.5)=-1,round(-2.5)=-2"
msgstr "圆(1.5)=2,圆(2.5)=3;圆(-1.5)=-1,圆(-2.5)=-2"

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "always to +Infinity"
msgstr "always to +Infinity"

#: ../../SpinalHDL/Data types/Int.rst:588
msgid "SpinalHDL"
msgstr "脊髓HDL"

#: ../../SpinalHDL/Data types/Int.rst:592
msgid ""
"In SpinalHDL `ROUNDTOINF` is the default RoundType (``round = roundToInf``)"
msgstr "在 SpinalHDL 中，`ROUNDTOINF` 是默认的 RoundType (``round = roundToInf``)"

#: ../../SpinalHDL/Data types/Int.rst:615
msgid ""
"Only ``floor`` and ``floorToZero`` work without the ``align`` option; they "
"do not need a carry bit. Other rounding operations default to using a carry "
"bit."
msgstr ""
"只有 ``floor`` 和 ``floorToZero`` 可以在没有 ``align`` "
"选项的情况下工作；他们不需要进位位。其他舍入操作默认使用进位位。"

#: ../../SpinalHDL/Data types/Int.rst:617
msgid "**round Api**"
msgstr "**round Api**"

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "description"
msgstr "描述"

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "Return(align=false)"
msgstr "返回（对齐=假）"

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "Return(align=true)"
msgstr "返回（对齐=真）"

#: ../../SpinalHDL/Data types/Int.rst:622 types/Int.rst:624 types/Int.rst:626
#: types/Int.rst:627 types/Int.rst:630
msgid "Both"
msgstr "两个都"

#: ../../SpinalHDL/Data types/Int.rst:622 types/Int.rst:623 types/Int.rst:624
#: types/Int.rst:625 types/Int.rst:626 types/Int.rst:627 types/Int.rst:628
#: types/Int.rst:629 types/Int.rst:630
msgid "w(x)-n bits"
msgstr "w(x)-n 位"

#: ../../SpinalHDL/Data types/Int.rst:623 types/Int.rst:625 types/Int.rst:628
#: types/Int.rst:629
msgid "SInt"
msgstr "斯内特"

#: ../../SpinalHDL/Data types/Int.rst:623
msgid "equal to floor in UInt"
msgstr "等于 UInt 中的下限"

#: ../../SpinalHDL/Data types/Int.rst:625
msgid "equal to ceil in UInt"
msgstr "等于 UInt 中的 cel"

#: ../../SpinalHDL/Data types/Int.rst:626
msgid "simple for HW"
msgstr "硬件简单"

#: ../../SpinalHDL/Data types/Int.rst:628
msgid "most Common"
msgstr "最常见的"

#: ../../SpinalHDL/Data types/Int.rst:629
msgid "equal to roundDown in UInt"
msgstr "等于 UInt 中的舍入"

#: ../../SpinalHDL/Data types/Int.rst:630
msgid "round"
msgstr "round"

#: ../../SpinalHDL/Data types/Int.rst:630
msgid "SpinalHDL chose roundToInf"
msgstr "SpinalHDL chose roundToInf"

#: ../../SpinalHDL/Data types/Int.rst:634
msgid ""
"Although ``roundToInf`` is very common, ``roundUp`` has the least cost and "
"good timing, with almost no performance loss. As a result, ``roundUp`` is "
"strongly recommended for production use."
msgstr ""
"虽然“roundToInf”很常见，但“roundUp”的成本最低，时机也好，几乎没有性能损失。因此，强烈建议在生产环境中使用“roundUp”。"

#: ../../SpinalHDL/Data types/Int.rst:638
msgid "High bit operations"
msgstr "高位操作"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "function"
msgstr "功能"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Operation"
msgstr "Operation"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Positive-Op"
msgstr "正向操作"

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Negative-Op"
msgstr "阴性操作"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "sat"
msgstr "坐"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "Saturation"
msgstr "饱和"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "when(Top[w-1, w-n].orR) set maxValue"
msgstr "when(Top[w-1, w-n].orR) 设置 maxValue"

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "When(Top[w-1, w-n].andR) set minValue"
msgstr "When(Top[w-1, w-n].andR) 设置 minValue"

#: ../../SpinalHDL/Data types/Int.rst:646
msgid "trim"
msgstr "trim"

#: ../../SpinalHDL/Data types/Int.rst:646
msgid "Discard"
msgstr "丢弃"

#: ../../SpinalHDL/Data types/Int.rst:646 types/Int.rst:647
msgid "N/A"
msgstr "不适用"

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "symmetry"
msgstr "对称"

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "Symmetric"
msgstr "对称"

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "minValue = -maxValue"
msgstr "最小值 = -最大值"

#: ../../SpinalHDL/Data types/Int.rst:650
msgid "Symmetric is only valid for ``SInt``."
msgstr "对称仅对“SInt”有效。"

#: ../../SpinalHDL/Data types/Int.rst:663
msgid "fixTo function"
msgstr "修复函数"

#: ../../SpinalHDL/Data types/Int.rst:665
msgid "Two ways are provided in ``UInt``/``SInt`` to do fixpoint:"
msgstr "``UInt``/``SInt`` 中提供了两种方法来执行固定点："

#: ../../SpinalHDL/Data types/Int.rst:669
msgid ""
"``fixTo`` is strongly recommended in your RTL work, you don't need to handle"
" carry bit alignment and bit width calculations manually like **Way1** in "
"the above diagram."
msgstr "在 RTL 工作中强烈建议使用“fixTo”，您不需要像上图中的 **Way1** 那样手动处理进位对齐和位宽计算。"

#: ../../SpinalHDL/Data types/Int.rst:671
msgid "Factory Fix function with Auto Saturation:"
msgstr "带自动饱和功能的工厂修复功能："

#: ../../SpinalHDL/Data types/Int.rst:674
msgid "Function"
msgstr "功能"

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "fixTo(section, roundType, symmetric)"
msgstr "fixTo（部分，圆形类型，对称）"

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "Factory FixFunction"
msgstr "工厂修复功能"

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "section.size bits"
msgstr "节大小位"

#~ msgid ""
#~ "The ``UInt``/``SInt`` type corresponds to a vector of bits that can be used "
#~ "for signed/unsigned integer arithmetic."
#~ msgstr "``UInt``/``SInt`` 类型对应于可用于有符号/无符号整数算术的位向量。"

#~ msgid "UInt"
#~ msgstr "单位"

#~ msgid ""
#~ "Create an unsigned/signed integer assigned with 'value' (Base : 'h', 'd', "
#~ "'o', 'b')"
#~ msgstr "创建一个分配有“value”的无符号/有符号整数（基数：“h”、“d”、“o”、“b”）"

#~ msgid "``x rotateLeft y`` and ``x rotateRight y`` are also valid syntax."
#~ msgstr "“xrotateLeft y”和“xrotateRight y”也是有效的语法。"

#~ msgid ""
#~ "Notice the difference between ``x >> 2``:T(w(x)-2) and ``x >> "
#~ "U(2)``:T(w(x))."
#~ msgstr "注意 ``x >> 2``:T(w(x)-2) 和 ``x >> U(2)``:T(w(x)) 之间的区别。"

#~ msgid "Addition by sat carry bit"
#~ msgstr "通过 sat 进位位进行加法"

#~ msgid "Subtraction by sat carry bit"
#~ msgstr "通过 sat 进位位进行减法"

#~ msgid "x(y)"
#~ msgstr "x(y)"

#~ msgid "Readbit, y : Int/UInt"
#~ msgstr "读取位，y：Int/UInt"

#~ msgid "Read bitfield, offset: UInt, width: Int"
#~ msgstr "Read bitfield, offset: UInt, width: Int"

#~ msgid "x(y) := z"
#~ msgstr "x(y) := z"

#~ msgid "x(offset, width) := z"
#~ msgstr "x(offset, width) := z"

#~ msgid "Assign bitfield, offset: UInt, width: Int"
#~ msgstr "分配位域，偏移量：UInt，宽度：Int"

#~ msgid "x(\\ :ref:`range <range>`\\ ) := z"
#~ msgstr "x(\\ :ref:`范围 <范围>`\\ ) := z"

#~ msgid "Assign a range of bit. Ex : myBits(4 downto 2) := U\"010\""
#~ msgstr "指定一个位范围。例如：myBits(4 downto 2) := U\"010\""

#~ msgid "Return the most significant bit"
#~ msgstr "返回最高有效位"

#~ msgid "Return the least significant bit"
#~ msgstr "返回最低有效位"

#~ msgid "Vec(T, w(x)/y)"
#~ msgstr "Vec(T, w(x)/y)"

#~ msgid "Use the two's complement to transform an UInt into an SInt"
#~ msgstr "使用二进制补码将 UInt 转换为 SInt"

#~ msgid "Return most significant bit"
#~ msgstr "返回最高有效位"
