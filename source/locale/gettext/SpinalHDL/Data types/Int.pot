# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018 - 2024, SpinalHDL
# This file is distributed under the same license as the SpinalHDL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SpinalHDL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-02 16:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../SpinalHDL/Data types/Int.rst:4
#: ../../SpinalHDL/Data types/Int.rst:620
msgid "UInt/SInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:6
msgid "The ``UInt``/``SInt`` types are vectors of bits interpreted as two's complement unsigned/signed integers. They can do what ``Bits`` can do, with the addition of unsigned/signed integer arithmetic and comparisons."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:10
msgid "Declaration"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:12
msgid "The syntax to declare an integer is as follows:  (everything between [] is optional)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:18
msgid "Syntax"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:19
#: ../../SpinalHDL/Data types/Int.rst:78
#: ../../SpinalHDL/Data types/Int.rst:179
#: ../../SpinalHDL/Data types/Int.rst:243
#: ../../SpinalHDL/Data types/Int.rst:292
#: ../../SpinalHDL/Data types/Int.rst:378
#: ../../SpinalHDL/Data types/Int.rst:480
#: ../../SpinalHDL/Data types/Int.rst:674
msgid "Description"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "UInt[()]"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "SInt[()]"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:22
msgid "Create an unsigned/signed integer, bits count is inferred"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "UInt(x bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "SInt(x bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:25
msgid "Create an unsigned/signed integer with x bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "U(value: Int[,x bits])"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "U(value: BigInt[,x bits])"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "S(value: Int[,x bits])"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "S(value: BigInt[,x bits])"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
#: ../../SpinalHDL/Data types/Int.rst:30
msgid "Create an unsigned/signed integer assigned with 'value'"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "U\"[[size']base]value\""
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "S\"[[size']base]value\""
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "(base: 'h', 'd', 'o', 'b')"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "U([x bits,] elements: Element*)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "S([x bits,] elements: Element*)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:37
msgid "Create an unsigned integer assigned with the value specified by :ref:`elements <element>`"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:66
msgid "Operators"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:68
msgid "The following operators are available for the ``UInt`` and ``SInt`` types:"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:71
msgid "Logic"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:77
#: ../../SpinalHDL/Data types/Int.rst:178
#: ../../SpinalHDL/Data types/Int.rst:242
#: ../../SpinalHDL/Data types/Int.rst:291
#: ../../SpinalHDL/Data types/Int.rst:377
#: ../../SpinalHDL/Data types/Int.rst:479
msgid "Operator"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:79
#: ../../SpinalHDL/Data types/Int.rst:244
msgid "Return type"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:80
#: ../../SpinalHDL/Data types/Int.rst:208
msgid "~x"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:81
msgid "Bitwise NOT"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:82
#: ../../SpinalHDL/Data types/Int.rst:106
#: ../../SpinalHDL/Data types/Int.rst:115
#: ../../SpinalHDL/Data types/Int.rst:118
#: ../../SpinalHDL/Data types/Int.rst:122
#: ../../SpinalHDL/Data types/Int.rst:126
#: ../../SpinalHDL/Data types/Int.rst:204
#: ../../SpinalHDL/Data types/Int.rst:210
#: ../../SpinalHDL/Data types/Int.rst:516
msgid "T(w(x) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:83
msgid "x & y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:84
msgid "Bitwise AND"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:85
#: ../../SpinalHDL/Data types/Int.rst:88
#: ../../SpinalHDL/Data types/Int.rst:91
#: ../../SpinalHDL/Data types/Int.rst:183
#: ../../SpinalHDL/Data types/Int.rst:189
#: ../../SpinalHDL/Data types/Int.rst:192
#: ../../SpinalHDL/Data types/Int.rst:198
msgid "T(max(w(x), w(y)) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:86
msgid "x | y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:87
msgid "Bitwise OR"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:89
msgid "x ^ y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:90
msgid "Bitwise XOR"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:92
msgid "x.xorR"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:93
msgid "XOR all bits of x (reduction operator)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:94
#: ../../SpinalHDL/Data types/Int.rst:97
#: ../../SpinalHDL/Data types/Int.rst:100
#: ../../SpinalHDL/Data types/Int.rst:247
#: ../../SpinalHDL/Data types/Int.rst:250
#: ../../SpinalHDL/Data types/Int.rst:253
#: ../../SpinalHDL/Data types/Int.rst:256
#: ../../SpinalHDL/Data types/Int.rst:259
#: ../../SpinalHDL/Data types/Int.rst:262
#: ../../SpinalHDL/Data types/Int.rst:382
#: ../../SpinalHDL/Data types/Int.rst:385
#: ../../SpinalHDL/Data types/Int.rst:403
#: ../../SpinalHDL/Data types/Int.rst:406
#: ../../SpinalHDL/Data types/Int.rst:409
msgid "Bool"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:95
msgid "x.orR"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:96
msgid "OR all bits of x (reduction operator)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:98
msgid "x.andR"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:99
msgid "AND all bits of x (reduction operator)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:101
#: ../../SpinalHDL/Data types/Int.rst:104
msgid "x \\>\\> y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:102
msgid "Arithmetic shift right, y : Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:103
msgid "T(w(x) - y bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:105
msgid "Arithmetic shift right, y : UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:107
#: ../../SpinalHDL/Data types/Int.rst:110
msgid "x \\<\\< y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:108
msgid "Arithmetic shift left, y : Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:109
msgid "T(w(x) + y bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:111
msgid "Arithmetic shift left, y : UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:112
msgid "T(w(x) + max(y) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:113
msgid "x \\|\\>\\> y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:114
msgid "Logical shift right, y : Int/UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:116
msgid "x \\|\\<\\< y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:117
msgid "Logical shift left, y : Int/UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:119
msgid "x.rotateLeft(y)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "Logical left rotation, y : UInt/Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "The width of y is constrained to the width of log2Up(x) or less"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:123
msgid "x.rotateRight(y)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "Logical right rotation, y : UInt/Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:127
msgid "x.clearAll[()]"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:128
msgid "Clear all bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:129
#: ../../SpinalHDL/Data types/Int.rst:132
#: ../../SpinalHDL/Data types/Int.rst:135
#: ../../SpinalHDL/Data types/Int.rst:138
msgid "*modifies x*"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:130
msgid "x.setAll[()]"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:131
msgid "Set all bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:133
msgid "x.setAllTo(value : Boolean)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:134
msgid "Set all bits to the given Boolean value"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:136
msgid "x.setAllTo(value : Bool)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:137
msgid "Set all bits to the given Bool value"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:142
msgid "Notice the difference in behaviour between ``x >> 2`` (result 2 bit narrower than x) and ``x >> U(2)`` (keeping width) due to the Scala type of :code:`y`."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:145
msgid "In the first case \"2\" is an ``Int`` (which can be seen as an \"elaboration integer constant\"), and in the second case it is a hardware signal (type ``UInt``) that may or may not be a constant."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:173
msgid "Arithmetic"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:180
#: ../../SpinalHDL/Data types/Int.rst:293
#: ../../SpinalHDL/Data types/Int.rst:379
#: ../../SpinalHDL/Data types/Int.rst:481
#: ../../SpinalHDL/Data types/Int.rst:674
msgid "Return"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:181
msgid "x + y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:182
msgid "Addition"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:184
msgid "x +^ y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:185
msgid "Addition with carry"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:186
#: ../../SpinalHDL/Data types/Int.rst:195
msgid "T(max(w(x), w(y)) + 1 bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:187
msgid "x +| y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:188
msgid "Addition of addend with `saturation`_ (see also `T.maxValue` and `T.minValue`)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:190
msgid "x - y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:191
msgid "Subtraction"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:193
msgid "x -^ y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:194
msgid "Subtraction with carry"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:196
msgid "x -| y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:197
msgid "Subtraction of subtrahend with `saturation`_ (see also `T.minValue` and `T.maxValue`)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:199
msgid "x * y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:200
msgid "Multiplication"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:201
msgid "T(w(x) + w(y)) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:202
msgid "x / y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:203
msgid "Division"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:205
msgid "x % y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:206
msgid "Modulo"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:207
msgid "T(min(w(x), w(y)) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:209
msgid "Unary One's compliment, Bitwise NOT"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:211
msgid "-x"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:212
msgid "Unary Two's compliment of SInt type.  Not available for UInt."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:213
#: ../../SpinalHDL/Data types/Int.rst:302
#: ../../SpinalHDL/Data types/Int.rst:311
msgid "SInt(w(x) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:233
msgid "Notice how simulation assertions are made here (with ``===``), as opposed to elaboration assertions in the previous example (with ``==``)."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:237
msgid "Comparison"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:245
msgid "x === y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:246
msgid "Equality"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:248
msgid "x =/= y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:249
msgid "Inequality"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:251
msgid "x > y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:252
msgid "Greater than"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:254
msgid "x >= y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:255
msgid "Greater than or equal"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:257
msgid "x < y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:258
msgid "Less than"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:260
msgid "x <= y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:261
msgid "Less than or equal"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:282
msgid "When comparing ``UInt`` values in a way that allows for \"wraparound\" behavior, meaning that the values will \"wrap around\" to the minimum value when they exceed the maximum value. The ``wrap`` method of ``UInt`` can be used as ``x.wrap < y`` for ``UInt`` variables ``x, y``, the result will be true if ``x`` is less than ``y`` in the wraparound sense."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:286
msgid "Type cast"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:294
msgid "x.asBits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:295
msgid "Binary cast to Bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:296
msgid "Bits(w(x) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:297
msgid "x.asUInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:298
msgid "Binary cast to UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:299
#: ../../SpinalHDL/Data types/Int.rst:314
msgid "UInt(w(x) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:300
msgid "x.asSInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:301
msgid "Binary cast to SInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:303
msgid "x.asBools"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:304
msgid "Cast into a array of Bool"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:305
msgid "Vec(Bool(), w(x))"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:306
msgid "x.asBool"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:307
msgid "Extract LSB of :code:`x`"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:308
msgid "Bool(x.lsb)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:309
msgid "S(x: T)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:310
msgid "Cast a Data into a SInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:312
msgid "U(x: T)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:313
msgid "Cast a Data into an UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:315
msgid "x.intoSInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:316
msgid "Convert to SInt expanding sign bit"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:317
msgid "SInt(w(x) + 1 bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:318
msgid "myUInt.twoComplement(en: Bool)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:319
msgid "Generate two's complement of number if ``en`` is ``True``, unchanged otherwise. (``en`` makes result negative)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:320
msgid "SInt(w(myUInt) + 1, bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:321
msgid "mySInt.abs"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:322
msgid "Return the absolute value as a UInt value"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:323
#: ../../SpinalHDL/Data types/Int.rst:326
msgid "UInt(w(mySInt) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:324
msgid "mySInt.abs(en: Bool)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:325
msgid "Return the absolute value as a UInt value when ``en`` is ``True``, otherwise just reinterpret bits as unsigned"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:327
msgid "mySInt.absWithSym"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:328
msgid "Return the absolute value of the UInt value with symmetric, shrink 1 bit"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:329
msgid "UInt(w(mySInt) - 1 bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:332
msgid "To cast a ``Bool``, a ``Bits``, or an ``SInt`` into a ``UInt``, you can use ``U(something)``. To cast things into an ``SInt``, you can use ``S(something)``."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:368
msgid "Bit extraction"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:370
msgid "All of the bit extraction operations can be used to read a bit / group of bits. Like in other HDLs the extraction operators can also be used to assign a part of a ``UInt`` / ``SInt`` ."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:380
msgid "x(y: Int)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:381
msgid "Static bit access of y-th bit"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:383
msgid "x(x: UInt)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:384
msgid "Variable bit access of y-th bit"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:386
msgid "x(offset: Int, width bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:387
msgid "Fixed part select of fixed width, offset is LSB index"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:388
#: ../../SpinalHDL/Data types/Int.rst:391
msgid "Bits(width bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:389
msgid "x(offset: UInt, width bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:390
msgid "Variable part-select of fixed width, offset is LSB index"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:392
msgid "x(range: Range)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:393
msgid "Access a :ref:`range <range>` of bits. Ex : myBits(4 downto 2)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:394
msgid "Bits(range.size bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:395
msgid "x.subdivideIn(y slices, [strict: Boolean])"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:396
msgid "Subdivide x into y slices, y: Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:397
msgid "Vec(Bits(...), y)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:398
msgid "x.subdivideIn(y bits, [strict: Boolean])"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:399
msgid "Subdivide x in multiple slices of y bits, y: Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:400
msgid "Vec(Bits(y bit), ...)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:401
msgid "x.msb"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:402
msgid "Access most significant bit of x (highest index, sign bit for SInt)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:404
msgid "x.lsb"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:405
msgid "Access lowest significant bit of x (index 0)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:407
msgid "mySInt.sign"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:408
msgid "Access most sign bit, only SInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:413
msgid "Some basic examples:"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:442
msgid "Subdivide details"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:444
msgid "Both overloads of ``subdivideIn`` have an optional parameter ``strict`` (i.e. ``subdivideIn(slices: SlicesCount, strict: Boolean = true)``). If ``strict`` is ``true`` an error will be raised if the input could not be divided into equal parts. If set to ``false`` the last element may be smaller than the other (equal sized) elements."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:470
msgid "Misc"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:472
msgid "In contrast to the bit extraction operations listed above it's not possible to use the return values to assign to the original signal."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:482
msgid "x.getWidth"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:483
msgid "Return bitcount"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:484
#: ../../SpinalHDL/Data types/Int.rst:487
msgid "Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:485
msgid "x.high"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:486
msgid "Return the index of the MSB (highest allowed index for Int)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:488
msgid "x.bitsRange"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:489
msgid "Return the range (0 to x.high)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:490
#: ../../SpinalHDL/Data types/Int.rst:499
msgid "Range"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:491
msgid "x.minValue"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:492
msgid "Lowest possible value of x (e.g. 0 for UInt)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:493
#: ../../SpinalHDL/Data types/Int.rst:496
msgid "BigInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:494
msgid "x.maxValue"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:495
msgid "Highest possible value of x"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:497
msgid "x.valueRange"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:498
msgid "Return the range from minimum to maximum possible value of x (x.minValue to x.maxValue)."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:500
msgid "x ## y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:501
msgid "Concatenate, x->high, y->low"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:502
msgid "Bits(w(x) + w(y) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:503
msgid "x #* n"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:504
msgid "Repeat x n-times"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:505
msgid "Bits(w(x) * n bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:506
msgid "x @@ y"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:507
msgid "Concatenate x:T with y:Bool/SInt/UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:508
msgid "T(w(x) + w(y) bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:509
msgid "x.resize(y)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "Return a resized copy of x, if enlarged, it is filled with zero"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "for UInt or filled with the sign for SInt, y: Int"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:512
msgid "T(y bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:513
msgid "x.resized"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "Return a version of x which is allowed to be automatically"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:0
msgid "resized where needed"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:517
msgid "x.expand"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:518
msgid "Return x with 1 bit expand"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:519
msgid "T(w(x)+1 bits)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:520
msgid "x.getZero"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:521
msgid "Return a new instance of type T that is assigned a constant value of zeros the same width as x."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:522
msgid "T(0, w(x) bits).clearAll()"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:523
msgid "x.getAllTrue"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:524
msgid "Return a new instance of type T that is assigned a constant value of ones the same width as x."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:525
msgid "T(w(x) bits).setAll()"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:528
msgid "`validRange` can only be used for types where the minimum and maximum values fit into a signed 32-bit integer. (This is a limitation given by the Scala ``scala.collection.immutable.Range`` type which uses `Int`)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:547
msgid "FixPoint operations"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:549
msgid "For fixpoint, we can divide it into two parts:"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:551
msgid "Lower bit operations (rounding methods)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:552
msgid "High bit operations (saturation operations)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:555
msgid "Lower bit operations"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:559
msgid "About Rounding: https://en.wikipedia.org/wiki/Rounding"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "SpinalHDL-Name"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Wikipedia-Name"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:562
#: ../../SpinalHDL/Data types/Int.rst:620
msgid "API"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Mathematic Algorithm"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "return(align=false)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:562
msgid "Supported"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "FLOOR"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "RoundDown"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:564
#: ../../SpinalHDL/Data types/Int.rst:622
msgid "floor"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:564
msgid "floor(x)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:564
#: ../../SpinalHDL/Data types/Int.rst:565
#: ../../SpinalHDL/Data types/Int.rst:622
#: ../../SpinalHDL/Data types/Int.rst:623
msgid "w(x)-n   bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:564
#: ../../SpinalHDL/Data types/Int.rst:565
#: ../../SpinalHDL/Data types/Int.rst:566
#: ../../SpinalHDL/Data types/Int.rst:567
#: ../../SpinalHDL/Data types/Int.rst:568
#: ../../SpinalHDL/Data types/Int.rst:569
#: ../../SpinalHDL/Data types/Int.rst:570
#: ../../SpinalHDL/Data types/Int.rst:571
msgid "Yes"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "FLOORTOZERO"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "RoundToZero"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:565
#: ../../SpinalHDL/Data types/Int.rst:623
msgid "floorToZero"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:565
msgid "sign*floor(abs(x))"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "CEIL"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "RoundUp"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:566
#: ../../SpinalHDL/Data types/Int.rst:624
msgid "ceil"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:566
msgid "ceil(x)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:566
#: ../../SpinalHDL/Data types/Int.rst:567
#: ../../SpinalHDL/Data types/Int.rst:568
#: ../../SpinalHDL/Data types/Int.rst:569
#: ../../SpinalHDL/Data types/Int.rst:570
#: ../../SpinalHDL/Data types/Int.rst:571
#: ../../SpinalHDL/Data types/Int.rst:624
#: ../../SpinalHDL/Data types/Int.rst:625
#: ../../SpinalHDL/Data types/Int.rst:626
#: ../../SpinalHDL/Data types/Int.rst:627
#: ../../SpinalHDL/Data types/Int.rst:628
#: ../../SpinalHDL/Data types/Int.rst:629
#: ../../SpinalHDL/Data types/Int.rst:630
msgid "w(x)-n+1 bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "CEILTOINF"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "RoundToInf"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:567
#: ../../SpinalHDL/Data types/Int.rst:625
msgid "ceilToInf"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:567
msgid "sign*ceil(abs(x))"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "ROUNDUP"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "RoundHalfUp"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:568
#: ../../SpinalHDL/Data types/Int.rst:626
msgid "roundUp"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:568
msgid "floor(x+0.5)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "ROUNDDOWN"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "RoundHalfDown"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:569
#: ../../SpinalHDL/Data types/Int.rst:627
msgid "roundDown"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:569
msgid "ceil(x-0.5)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "ROUNDTOZERO"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "RoundHalfToZero"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:570
#: ../../SpinalHDL/Data types/Int.rst:629
msgid "roundToZero"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:570
msgid "sign*ceil(abs(x)-0.5)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:571
#: ../../SpinalHDL/Data types/Int.rst:584
#: ../../SpinalHDL/Data types/Int.rst:585
#: ../../SpinalHDL/Data types/Int.rst:588
msgid "ROUNDTOINF"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:571
msgid "RoundHalfToInf"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:571
#: ../../SpinalHDL/Data types/Int.rst:628
msgid "roundToInf"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:571
msgid "sign*floor(abs(x)+0.5)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:572
#: ../../SpinalHDL/Data types/Int.rst:586
msgid "ROUNDTOEVEN"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:572
msgid "RoundHalfToEven"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:572
msgid "roundToEven"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:572
#: ../../SpinalHDL/Data types/Int.rst:573
msgid "No"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "ROUNDTOODD"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "RoundHalfToOdd"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:573
msgid "roundToOdd"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:577
msgid "The **RoundToEven** and **RoundToOdd** modes are very special, and are used in some big data statistical fields with high accuracy concerns, SpinalHDL doesn't support them yet."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:579
msgid "You will find `ROUNDUP`, `ROUNDDOWN`, `ROUNDTOZERO`, `ROUNDTOINF`, `ROUNDTOEVEN`, `ROUNTOODD` are very close in behavior, `ROUNDTOINF` is the most common. The behavior of rounding in different programming languages may be different."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "Programming language"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "default-RoundType"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "Example"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:582
msgid "comments"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:584
msgid "Matlab"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:584
#: ../../SpinalHDL/Data types/Int.rst:585
#: ../../SpinalHDL/Data types/Int.rst:588
msgid "round(1.5)=2,round(2.5)=3;round(-1.5)=-2,round(-2.5)=-3"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:584
#: ../../SpinalHDL/Data types/Int.rst:585
#: ../../SpinalHDL/Data types/Int.rst:588
msgid "round to ±Infinity"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:585
msgid "python2"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "python3"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "round(1.5)=round(2.5)=2;  round(-1.5)=round(-2.5)=-2"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:586
msgid "close to Even"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "Scala.math"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "ROUNDTOUP"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "round(1.5)=2,round(2.5)=3;round(-1.5)=-1,round(-2.5)=-2"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:587
msgid "always to +Infinity"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:588
msgid "SpinalHDL"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:592
msgid "In SpinalHDL `ROUNDTOINF` is the default RoundType (``round = roundToInf``)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:615
msgid "Only ``floor`` and ``floorToZero`` work without the ``align`` option; they do not need a carry bit. Other rounding operations default to using a carry bit."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:617
msgid "**round Api**"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "description"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "Return(align=false)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:620
msgid "Return(align=true)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:622
#: ../../SpinalHDL/Data types/Int.rst:624
#: ../../SpinalHDL/Data types/Int.rst:626
#: ../../SpinalHDL/Data types/Int.rst:627
#: ../../SpinalHDL/Data types/Int.rst:630
msgid "Both"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:622
#: ../../SpinalHDL/Data types/Int.rst:623
#: ../../SpinalHDL/Data types/Int.rst:624
#: ../../SpinalHDL/Data types/Int.rst:625
#: ../../SpinalHDL/Data types/Int.rst:626
#: ../../SpinalHDL/Data types/Int.rst:627
#: ../../SpinalHDL/Data types/Int.rst:628
#: ../../SpinalHDL/Data types/Int.rst:629
#: ../../SpinalHDL/Data types/Int.rst:630
msgid "w(x)-n bits"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:623
#: ../../SpinalHDL/Data types/Int.rst:625
#: ../../SpinalHDL/Data types/Int.rst:628
#: ../../SpinalHDL/Data types/Int.rst:629
msgid "SInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:623
msgid "equal to floor in UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:625
msgid "equal to ceil in UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:626
msgid "simple for HW"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:628
msgid "most Common"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:629
msgid "equal to roundDown in UInt"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:630
msgid "round"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:630
msgid "SpinalHDL chose roundToInf"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:634
msgid "Although ``roundToInf`` is very common, ``roundUp`` has the least cost and good timing, with almost no performance loss. As a result, ``roundUp`` is strongly recommended for production use."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:638
msgid "High bit operations"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "function"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Operation"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Positive-Op"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:643
msgid "Negative-Op"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "sat"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "Saturation"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "when(Top[w-1, w-n].orR) set maxValue"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:645
msgid "When(Top[w-1, w-n].andR) set minValue"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:646
msgid "trim"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:646
msgid "Discard"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:646
#: ../../SpinalHDL/Data types/Int.rst:647
msgid "N/A"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "symmetry"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "Symmetric"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:647
msgid "minValue = -maxValue"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:650
msgid "Symmetric is only valid for ``SInt``."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:663
msgid "fixTo function"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:665
msgid "Two ways are provided in ``UInt``/``SInt`` to do fixpoint:"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:669
msgid "``fixTo`` is strongly recommended in your RTL work, you don't need to handle carry bit alignment and bit width calculations manually like **Way1** in the above diagram."
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:671
msgid "Factory Fix function with Auto Saturation:"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:674
msgid "Function"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "fixTo(section, roundType, symmetric)"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "Factory FixFunction"
msgstr ""

#: ../../SpinalHDL/Data types/Int.rst:676
msgid "section.size bits"
msgstr ""
